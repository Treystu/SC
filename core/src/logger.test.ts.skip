/**
 * Unit tests for Logger
 */
import { logger, Logger, LogLevel } from './logger';

describe('Logger', () => {

  beforeEach(() => {
    // Logger is a singleton instance, no need to get instance
  });

  afterEach(() => {
    // Clean up is handled by logger internally
  });

  describe('Singleton pattern', () => {
    it('should have a single logger instance', () => {
      expect(logger).toBeInstanceOf(Logger);
    });
  });

  describe('Log levels', () => {
    it('should log at DEBUG level', () => {
      logger.setLevel(LogLevel.DEBUG);
      logger.debug('Debug message');
      
      const logs = logger.getRecentLogs();
      expect(logs).toHaveLength(1);
      expect(logs[0].level).toBe(LogLevel.DEBUG);
      expect(logs[0].message).toBe('Debug message');
    });

    it('should log at INFO level', () => {
      logger.info('Info message');
      
      const logs = logger.getRecentLogs();
      expect(logs).toHaveLength(1);
      expect(logs[0].level).toBe(LogLevel.INFO);
    });

    it('should log at WARN level', () => {
      logger.warn('Warning message');
      
      const logs = logger.getRecentLogs();
      expect(logs).toHaveLength(1);
      expect(logs[0].level).toBe(LogLevel.WARN);
    });

    it('should log at ERROR level', () => {
      logger.error('Error message');
      
      const logs = logger.getRecentLogs();
      expect(logs).toHaveLength(1);
      expect(logs[0].level).toBe(LogLevel.ERROR);
    });
  });

  describe('Log filtering by level', () => {
    it('should filter out DEBUG when level is INFO', () => {
      logger.setLevel(LogLevel.INFO);
      logger.debug('Should not appear');
      logger.info('Should appear');
      
      const logs = logger.getRecentLogs();
      expect(logs).toHaveLength(1);
      expect(logs[0].level).toBe(LogLevel.INFO);
    });

    it('should filter out DEBUG and INFO when level is WARN', () => {
      logger.setLevel(LogLevel.WARN);
      logger.debug('No');
      logger.info('No');
      logger.warn('Yes');
      logger.error('Yes');
      
      const logs = logger.getRecentLogs();
      expect(logs).toHaveLength(2);
      expect(logs[0].level).toBe(LogLevel.WARN);
      expect(logs[1].level).toBe(LogLevel.ERROR);
    });

    it('should only log ERROR when level is ERROR', () => {
      logger.setLevel(LogLevel.ERROR);
      logger.debug('No');
      logger.info('No');
      logger.warn('No');
      logger.error('Yes');
      
      const logs = logger.getRecentLogs();
      expect(logs).toHaveLength(1);
      expect(logs[0].level).toBe(LogLevel.ERROR);
    });
  });

  describe('Module filtering', () => {
    it('should log from enabled modules', () => {
      logger.enableModule('auth');
      logger.info('General message');
      logger.info('Auth message', 'auth');
      
      const logs = logger.getRecentLogs();
      // When module filters are active, only enabled modules are logged
      const authLogs = logs.filter(l => l.module === 'auth');
      expect(authLogs.length).toBeGreaterThan(0);
    });

    it('should not log from disabled modules', () => {
      logger.clearLogs(); // Clear any previous logs
      logger.enableModule('auth');
      logger.enableModule('network'); // Keep another module enabled
      logger.info('Auth message', 'auth');
      logger.disableModule('auth');
      logger.clearLogs(); // Clear logs including the first auth message
      logger.info('Auth message 2', 'auth');
      logger.info('Network message', 'network'); // This should be logged
      
      const logs = logger.getRecentLogs();
      // After disabling auth, no new auth logs should appear (since filters are still active)
      const authLogs = logs.filter(l => l.message === 'Auth message 2');
      expect(authLogs).toHaveLength(0);
      // But network logs should appear
      const networkLogs = logs.filter(l => l.message === 'Network message');
      expect(networkLogs).toHaveLength(1);
    });

    it('should handle multiple enabled modules', () => {
      logger.enableModule('auth');
      logger.enableModule('network');
      logger.info('Auth message', 'auth');
      logger.info('Network message', 'network');
      logger.info('Other message', 'other');
      
      const logs = logger.getRecentLogs();
      expect(logs.length).toBeGreaterThanOrEqual(2);
    });
  });

  describe('Structured logging', () => {
    it('should include timestamp', () => {
      const before = Date.now();
      logger.info('Test');
      const after = Date.now();
      
      const logs = logger.getRecentLogs();
      expect(logs[0].timestamp).toBeGreaterThanOrEqual(before);
      expect(logs[0].timestamp).toBeLessThanOrEqual(after);
    });

    it('should include additional data', () => {
      logger.info('Test', undefined, { userId: '123', action: 'login' });
      
      const logs = logger.getRecentLogs();
      expect(logs[0].data).toEqual({ userId: '123', action: 'login' });
    });

    it('should include module name', () => {
      logger.info('Test', 'auth');
      
      const logs = logger.getRecentLogs();
      expect(logs[0].module).toBe('auth');
    });
  });

  describe('Buffer management', () => {
    it('should clear logs', () => {
      logger.info('Message 1');
      logger.info('Message 2');
      expect(logger.getRecentLogs()).toHaveLength(2);
      
      logger.clearLogs();
      expect(logger.getRecentLogs()).toHaveLength(0);
    });

    it('should limit buffer size', () => {
      // This assumes the logger has a max buffer size
      // We'd need to check the implementation to know the exact limit
      for (let i = 0; i < 10000; i++) {
        logger.info(`Message ${i}`);
      }
      
      const logs = logger.getRecentLogs(10000);
      // Should not exceed max buffer size (typically 5000)
      expect(logs.length).toBeLessThanOrEqual(5000);
    });

    it('should retrieve logs in order', () => {
      logger.info('First');
      logger.info('Second');
      logger.info('Third');
      
      const logs = logger.getRecentLogs();
      expect(logs[0].message).toBe('First');
      expect(logs[1].message).toBe('Second');
      expect(logs[2].message).toBe('Third');
    });
  });

  describe('Query functionality', () => {
    beforeEach(() => {
      logger.clearLogs();
      logger.debug('Debug 1', 'module-a');
      logger.info('Info 1', 'module-a');
      logger.warn('Warn 1', 'module-b');
      logger.error('Error 1', 'module-b');
    });

    it('should get logs by level', () => {
      const errorLogs = logger.getLogsByLevel(LogLevel.ERROR);
      expect(errorLogs).toHaveLength(1);
      expect(errorLogs[0].level).toBe(LogLevel.ERROR);
    });

    it('should get logs by module', () => {
      const moduleALogs = logger.getLogsByModule('module-a');
      expect(moduleALogs).toHaveLength(2);
      expect(moduleALogs.every(l => l.module === 'module-a')).toBe(true);
    });

    it('should get logs by time range', () => {
      const now = Date.now();
      const logs = logger.getLogsByTimeRange(now - 10000, now + 10000);
      expect(logs.length).toBeGreaterThan(0);
    });
  });

  describe('Export functionality', () => {
    it('should export logs as JSON', () => {
      logger.clearLogs();
      logger.info('Test message', 'test-module', { key: 'value' });
      
      const exported = logger.exportLogs();
      expect(typeof exported).toBe('string');
      
      const parsed = JSON.parse(exported);
      expect(Array.isArray(parsed)).toBe(true);
      expect(parsed.length).toBeGreaterThan(0);
      expect(parsed[parsed.length - 1].message).toBe('Test message');
    });
  });

  describe('Statistics', () => {
    it('should provide log statistics', () => {
      // Clear logs by getting initial count
      const initialLogs = logger.getLogs();
      logger.info('test', 'Info 1');
      logger.info('test', 'Info 2');
      logger.error('test', 'Error 1');
      logger.warn('module-a', 'Warn 1');
      
      const allLogs = logger.getLogs();
      const newLogs = allLogs.slice(initialLogs.length);
      
      expect(newLogs.length).toBeGreaterThanOrEqual(4);
      const infoLogs = newLogs.filter(l => l.level === LogLevel.INFO);
      const errorLogs = newLogs.filter(l => l.level === LogLevel.ERROR);
      const warnLogs = newLogs.filter(l => l.level === LogLevel.WARN);
      const moduleALogs = newLogs.filter(l => l.component === 'module-a');
      
      expect(infoLogs.length).toBeGreaterThanOrEqual(2);
      expect(errorLogs.length).toBeGreaterThanOrEqual(1);
      expect(warnLogs.length).toBeGreaterThanOrEqual(1);
      expect(moduleALogs.length).toBeGreaterThanOrEqual(1);
    });
  });
});
