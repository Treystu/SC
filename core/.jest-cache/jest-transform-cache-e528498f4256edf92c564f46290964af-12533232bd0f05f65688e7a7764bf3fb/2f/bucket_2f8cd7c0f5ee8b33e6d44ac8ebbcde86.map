{"file":"/Users/christymaxwell/Desktop/Luke_Stuff/GitHub/SC/core/src/mesh/dht/bucket.ts","mappings":"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","names":[],"sources":["/Users/christymaxwell/Desktop/Luke_Stuff/GitHub/SC/core/src/mesh/dht/bucket.ts"],"sourcesContent":["/**\n * K-Bucket Implementation for Kademlia DHT\n * \n * Each K-bucket stores up to k contacts for a specific distance range\n * from the local node. Implements LRU eviction and staleness checking.\n */\n\nimport type { DHTContact, NodeId, KBucketConfig } from './types.js';\nimport { nodeIdsEqual, copyNodeId } from './node-id.js';\n\n/** Default K-bucket configuration */\nconst DEFAULT_BUCKET_CONFIG: KBucketConfig = {\n  k: 20,\n  pingTimeout: 5000,\n  alpha: 3,\n};\n\n/**\n * K-Bucket - stores contacts within a specific XOR distance range\n */\nexport class KBucket {\n  /** Maximum number of contacts in this bucket */\n  readonly k: number;\n  \n  /** Contacts stored in this bucket (ordered by last seen, most recent first) */\n  private contacts: DHTContact[] = [];\n  \n  /** Replacement cache for contacts that couldn't be added */\n  private replacementCache: DHTContact[] = [];\n  \n  /** Maximum size of replacement cache */\n  private readonly maxReplacementCacheSize: number;\n  \n  /** Last time this bucket was refreshed */\n  private lastRefreshed: number = Date.now();\n  \n  /** Bucket index (for debugging/logging) */\n  readonly index: number;\n\n  constructor(index: number, config: Partial<KBucketConfig> = {}) {\n    this.index = index;\n    this.k = config.k ?? DEFAULT_BUCKET_CONFIG.k;\n    this.maxReplacementCacheSize = Math.ceil(this.k / 2);\n  }\n\n  /**\n   * Get the number of contacts in this bucket\n   */\n  get size(): number {\n    return this.contacts.length;\n  }\n\n  /**\n   * Check if the bucket is full\n   */\n  get isFull(): boolean {\n    return this.contacts.length >= this.k;\n  }\n\n  /**\n   * Get all contacts in this bucket\n   */\n  getContacts(): DHTContact[] {\n    return [...this.contacts];\n  }\n\n  /**\n   * Get a contact by node ID\n   */\n  getContact(nodeId: NodeId): DHTContact | undefined {\n    return this.contacts.find(c => nodeIdsEqual(c.nodeId, nodeId));\n  }\n\n  /**\n   * Check if a contact exists in this bucket\n   */\n  hasContact(nodeId: NodeId): boolean {\n    return this.contacts.some(c => nodeIdsEqual(c.nodeId, nodeId));\n  }\n\n  /**\n   * Add or update a contact in the bucket\n   * \n   * @param contact - Contact to add\n   * @returns Object indicating result: added, updated, or needs ping check\n   */\n  addContact(contact: DHTContact): {\n    added: boolean;\n    updated: boolean;\n    needsPing?: DHTContact;\n  } {\n    // Check if contact already exists\n    const existingIndex = this.contacts.findIndex(c => \n      nodeIdsEqual(c.nodeId, contact.nodeId)\n    );\n\n    if (existingIndex !== -1) {\n      // Update existing contact and move to front (most recently seen)\n      const existing = this.contacts[existingIndex];\n      this.contacts.splice(existingIndex, 1);\n      this.contacts.unshift({\n        ...existing,\n        ...contact,\n        lastSeen: Date.now(),\n        nodeId: copyNodeId(contact.nodeId),\n      });\n      return { added: false, updated: true };\n    }\n\n    // Contact is new\n    if (!this.isFull) {\n      // Bucket has space, add the contact\n      this.contacts.unshift({\n        ...contact,\n        lastSeen: Date.now(),\n        nodeId: copyNodeId(contact.nodeId),\n      });\n      return { added: true, updated: false };\n    }\n\n    // Bucket is full - need to ping least recently seen contact\n    const leastRecent = this.contacts[this.contacts.length - 1];\n    \n    // Add to replacement cache for potential later use\n    this.addToReplacementCache(contact);\n    \n    return {\n      added: false,\n      updated: false,\n      needsPing: leastRecent,\n    };\n  }\n\n  /**\n   * Add contact to replacement cache\n   */\n  private addToReplacementCache(contact: DHTContact): void {\n    // Remove if already exists\n    const existingIndex = this.replacementCache.findIndex(c =>\n      nodeIdsEqual(c.nodeId, contact.nodeId)\n    );\n    if (existingIndex !== -1) {\n      this.replacementCache.splice(existingIndex, 1);\n    }\n\n    // Add to front\n    this.replacementCache.unshift({\n      ...contact,\n      nodeId: copyNodeId(contact.nodeId),\n    });\n\n    // Trim if over capacity\n    if (this.replacementCache.length > this.maxReplacementCacheSize) {\n      this.replacementCache.pop();\n    }\n  }\n\n  /**\n   * Remove a contact from the bucket\n   * \n   * @param nodeId - Node ID of contact to remove\n   * @returns The removed contact, or undefined if not found\n   */\n  removeContact(nodeId: NodeId): DHTContact | undefined {\n    const index = this.contacts.findIndex(c => nodeIdsEqual(c.nodeId, nodeId));\n    if (index === -1) return undefined;\n\n    const [removed] = this.contacts.splice(index, 1);\n\n    // Try to promote from replacement cache\n    if (this.replacementCache.length > 0) {\n      const replacement = this.replacementCache.shift()!;\n      this.contacts.push(replacement);\n    }\n\n    return removed;\n  }\n\n  /**\n   * Update a contact's last seen time\n   */\n  updateLastSeen(nodeId: NodeId): boolean {\n    const index = this.contacts.findIndex(c => nodeIdsEqual(c.nodeId, nodeId));\n    if (index === -1) return false;\n\n    // Splice out, update timestamp, and move to front - more efficient than filter\n    const [contact] = this.contacts.splice(index, 1);\n    contact.lastSeen = Date.now();\n    this.contacts.unshift(contact);\n    return true;\n  }\n\n  /**\n   * Record a failed contact attempt\n   */\n  recordFailure(nodeId: NodeId): void {\n    const contact = this.contacts.find(c => nodeIdsEqual(c.nodeId, nodeId));\n    if (contact) {\n      contact.failureCount++;\n    }\n  }\n\n  /**\n   * Reset failure count for a contact\n   */\n  resetFailures(nodeId: NodeId): void {\n    const contact = this.contacts.find(c => nodeIdsEqual(c.nodeId, nodeId));\n    if (contact) {\n      contact.failureCount = 0;\n    }\n  }\n\n  /**\n   * Get the least recently seen contact\n   */\n  getLeastRecentlySeen(): DHTContact | undefined {\n    return this.contacts.length > 0 \n      ? this.contacts[this.contacts.length - 1] \n      : undefined;\n  }\n\n  /**\n   * Get stale contacts (not seen within timeout)\n   */\n  getStaleContacts(staleThresholdMs: number): DHTContact[] {\n    const cutoff = Date.now() - staleThresholdMs;\n    return this.contacts.filter(c => c.lastSeen < cutoff);\n  }\n\n  /**\n   * Replace a stale contact with one from replacement cache\n   */\n  replaceStaleContact(staleNodeId: NodeId): DHTContact | undefined {\n    if (this.replacementCache.length === 0) return undefined;\n\n    const removed = this.removeContact(staleNodeId);\n    if (removed) {\n      // The removeContact method already promotes from replacement cache\n      return this.contacts.find(c => !nodeIdsEqual(c.nodeId, staleNodeId));\n    }\n    return undefined;\n  }\n\n  /**\n   * Get the last refresh time\n   */\n  getLastRefreshed(): number {\n    return this.lastRefreshed;\n  }\n\n  /**\n   * Mark the bucket as refreshed\n   */\n  markRefreshed(): void {\n    this.lastRefreshed = Date.now();\n  }\n\n  /**\n   * Check if bucket needs refresh\n   */\n  needsRefresh(refreshIntervalMs: number): boolean {\n    return Date.now() - this.lastRefreshed > refreshIntervalMs;\n  }\n\n  /**\n   * Clear all contacts from the bucket\n   */\n  clear(): void {\n    this.contacts = [];\n    this.replacementCache = [];\n  }\n\n  /**\n   * Get replacement cache contacts\n   */\n  getReplacementCache(): DHTContact[] {\n    return [...this.replacementCache];\n  }\n\n  /**\n   * Get bucket statistics\n   */\n  getStats(): {\n    contacts: number;\n    replacementCache: number;\n    avgLastSeen: number;\n    avgFailures: number;\n  } {\n    const now = Date.now();\n    \n    const avgLastSeen = this.contacts.length > 0\n      ? this.contacts.reduce((sum, c) => sum + (now - c.lastSeen), 0) / this.contacts.length\n      : 0;\n    \n    const avgFailures = this.contacts.length > 0\n      ? this.contacts.reduce((sum, c) => sum + c.failureCount, 0) / this.contacts.length\n      : 0;\n\n    return {\n      contacts: this.contacts.length,\n      replacementCache: this.replacementCache.length,\n      avgLastSeen,\n      avgFailures,\n    };\n  }\n}\n\n/**\n * K-Bucket Manager - manages all k-buckets for a node\n */\nexport class KBucketManager {\n  /** All k-buckets indexed by distance prefix length */\n  private buckets: KBucket[];\n  \n  /** Local node ID */\n  readonly localNodeId: NodeId;\n  \n  /** K parameter */\n  readonly k: number;\n\n  constructor(localNodeId: NodeId, config: Partial<KBucketConfig> = {}) {\n    this.localNodeId = copyNodeId(localNodeId);\n    this.k = config.k ?? DEFAULT_BUCKET_CONFIG.k;\n    \n    // Create 160 buckets (one for each possible prefix length)\n    this.buckets = Array.from(\n      { length: 160 },\n      (_, i) => new KBucket(i, config)\n    );\n  }\n\n  /**\n   * Get a specific bucket by index\n   */\n  getBucket(index: number): KBucket | undefined {\n    return this.buckets[index];\n  }\n\n  /**\n   * Get all buckets\n   */\n  getAllBuckets(): KBucket[] {\n    return [...this.buckets];\n  }\n\n  /**\n   * Get all contacts from all buckets\n   */\n  getAllContacts(): DHTContact[] {\n    return this.buckets.flatMap(bucket => bucket.getContacts());\n  }\n\n  /**\n   * Get total number of contacts\n   */\n  getTotalContacts(): number {\n    return this.buckets.reduce((sum, bucket) => sum + bucket.size, 0);\n  }\n\n  /**\n   * Get number of non-empty buckets\n   */\n  getActiveBucketCount(): number {\n    return this.buckets.filter(bucket => bucket.size > 0).length;\n  }\n\n  /**\n   * Get buckets that need refresh\n   */\n  getBucketsNeedingRefresh(refreshIntervalMs: number): KBucket[] {\n    return this.buckets.filter(bucket => \n      bucket.size > 0 && bucket.needsRefresh(refreshIntervalMs)\n    );\n  }\n\n  /**\n   * Get overall statistics\n   */\n  getStats(): {\n    totalContacts: number;\n    activeBuckets: number;\n    bucketDistribution: number[];\n    avgContactsPerBucket: number;\n  } {\n    const bucketDistribution = this.buckets.map(b => b.size);\n    const activeBuckets = bucketDistribution.filter(s => s > 0).length;\n    const totalContacts = bucketDistribution.reduce((a, b) => a + b, 0);\n    \n    return {\n      totalContacts,\n      activeBuckets,\n      bucketDistribution,\n      avgContactsPerBucket: activeBuckets > 0 ? totalContacts / activeBuckets : 0,\n    };\n  }\n}\n"],"version":3}