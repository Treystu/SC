82a804bea3fee1b7087ece449bf86bc7
"use strict";
/**
 * Shamir's Secret Sharing Implementation
 * Uses GF(2^8) arithmetic with Rijndael's finite field (poly: 0x11b)
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.split = split;
exports.combine = combine;
// Rijndael's finite field polynomial: x^8 + x^4 + x^3 + x + 1 (0x11b)
// We precompute log and exp tables for fast multiplication/division
const LOG_TABLE = new Uint8Array(256);
const EXP_TABLE = new Uint8Array(256);
function initTables() {
    let x = 1;
    for (let i = 0; i < 255; i++) {
        EXP_TABLE[i] = x;
        LOG_TABLE[x] = i;
        // Multiply by 3: (x * 2) ^ x
        // x * 2 computation with reduction
        let x2 = x << 1;
        if (x & 0x80) {
            // Check high bit of byte (since x is byte)
            x2 ^= 0x11b;
        }
        // Result is x2 ^ x (which is x*3)
        x = x2 ^ x;
        // ensure x is byte
        x &= 0xff;
    }
    // LOG[0] is undefined ideally, but we won't use it
}
initTables();
// GF(2^8) Addition/Subtraction (XOR)
function add(a, b) {
    return a ^ b;
}
// GF(2^8) Multiplication
function mul(a, b) {
    if (a === 0 || b === 0)
        return 0;
    const logA = LOG_TABLE[a];
    const logB = LOG_TABLE[b];
    const logSum = (logA + logB) % 255;
    return EXP_TABLE[logSum];
}
// GF(2^8) Division
function div(a, b) {
    if (b === 0)
        throw new Error("Division by zero");
    if (a === 0)
        return 0;
    const logA = LOG_TABLE[a];
    const logB = LOG_TABLE[b];
    const logDiff = (logA - logB + 255) % 255;
    return EXP_TABLE[logDiff];
}
/**
 * Generate n distinct random shares for a secret, such that any k are required to reconstruct.
 * @param secret The secret bytes (Uint8Array)
 * @param n Total number of shares to generate
 * @param k Threshold number of shares to reconstruct
 */
function split(secret, n, k) {
    if (k > n)
        throw new Error("Threshold k cannot be greater than n");
    if (k < 1)
        throw new Error("Threshold k must be at least 1");
    const len = secret.length;
    const shares = [];
    // Initialize shares
    for (let i = 0; i < n; i++) {
        shares.push({ x: i + 1, y: new Uint8Array(len) });
    }
    // Generate random polynomials for each byte of the secret
    for (let i = 0; i < len; i++) {
        // Polynomial: s + a1*x + a2*x^2 + ... + ak-1*x^(k-1)
        // coeffs[0] is the secret byte
        const coeffs = new Uint8Array(k);
        coeffs[0] = secret[i];
        // Generate random coefficients a1...ak-1
        if (k > 1) {
            const randomBytes = new Uint8Array(k - 1);
            crypto.getRandomValues(randomBytes);
            for (let j = 1; j < k; j++) {
                coeffs[j] = randomBytes[j - 1];
            }
        }
        // Evaluate polynomial for each share (x=1..n)
        for (let j = 0; j < n; j++) {
            const x = j + 1;
            // Horner's method or direct? Direct is simpler for small k
            // y = c0 + c1*x + c2*x^2 ...
            // Correct Horner's:
            // P(x) = c0 + x(c1 + x(c2 + ...))
            let val = 0;
            // Reverse coefficient iteration for Horner's not totally standard,
            // let's do direct sum for clarity on small finite fields
            // Val = Sum( c_m * x^m )
            for (let m = 0; m < k; m++) {
                // Calculate x^m
                let xPow = 1;
                for (let p = 0; p < m; p++)
                    xPow = mul(xPow, x);
                const term = mul(coeffs[m], xPow);
                val = add(val, term);
            }
            shares[j].y[i] = val;
        }
    }
    return shares;
}
/**
 * Reconstruct the secret from k shares.
 * @param shares The array of shares (objects with x and y)
 */
function combine(shares) {
    if (shares.length === 0)
        throw new Error("No shares provided");
    const len = shares[0].y.length;
    // We need at least k shares, but we assume the provided shares ARE the k shares (or more)
    // We use Lagrange Interpolation at x=0
    const reconstructed = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
        // For each byte position
        let secretByte = 0;
        for (let j = 0; j < shares.length; j++) {
            const { x: xj, y: yBlock } = shares[j];
            const yj = yBlock[i];
            // Compute Lagrange basis polynomial L_j(0)
            // L_j(0) = Product ( (0 - xm) / (xj - xm) ) for m != j
            let numerator = 1;
            let denominator = 1;
            for (let m = 0; m < shares.length; m++) {
                if (m === j)
                    continue;
                const xm = shares[m].x;
                // (0 - xm) = -xm = xm in GF(2^n) because addition is XOR
                numerator = mul(numerator, xm);
                // (xj - xm) = xj ^ xm
                denominator = mul(denominator, add(xj, xm));
            }
            const lagrange = mul(numerator, div(1, denominator)); // num * (1/den)
            const term = mul(yj, lagrange);
            secretByte = add(secretByte, term);
        }
        reconstructed[i] = secretByte;
    }
    return reconstructed;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL2NocmlzdHltYXh3ZWxsL0Rlc2t0b3AvTHVrZV9TdHVmZi9HaXRIdWIvU0MvY29yZS9zcmMvY3J5cHRvL3NoYW1pci50cyIsIm1hcHBpbmdzIjoiO0FBQUE7OztHQUdHOztBQTRESCxzQkEwREM7QUFNRCwwQkEyQ0M7QUFyS0Qsc0VBQXNFO0FBQ3RFLG9FQUFvRTtBQUNwRSxNQUFNLFNBQVMsR0FBRyxJQUFJLFVBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUN0QyxNQUFNLFNBQVMsR0FBRyxJQUFJLFVBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUV0QyxTQUFTLFVBQVU7SUFDakIsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ1YsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEdBQUcsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDO1FBQzdCLFNBQVMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDakIsU0FBUyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUVqQiw2QkFBNkI7UUFDN0IsbUNBQW1DO1FBQ25DLElBQUksRUFBRSxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDaEIsSUFBSSxDQUFDLEdBQUcsSUFBSSxFQUFFLENBQUM7WUFDYiwyQ0FBMkM7WUFDM0MsRUFBRSxJQUFJLEtBQUssQ0FBQztRQUNkLENBQUM7UUFDRCxrQ0FBa0M7UUFDbEMsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUM7UUFDWCxtQkFBbUI7UUFDbkIsQ0FBQyxJQUFJLElBQUksQ0FBQztJQUNaLENBQUM7SUFDRCxtREFBbUQ7QUFDckQsQ0FBQztBQUVELFVBQVUsRUFBRSxDQUFDO0FBRWIscUNBQXFDO0FBQ3JDLFNBQVMsR0FBRyxDQUFDLENBQVMsRUFBRSxDQUFTO0lBQy9CLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUNmLENBQUM7QUFFRCx5QkFBeUI7QUFDekIsU0FBUyxHQUFHLENBQUMsQ0FBUyxFQUFFLENBQVM7SUFD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QUMsVUFBVSxFQUFFLElBQUksQ0FBQyxDQUFDO1FBQ3JDLENBQUM7UUFFRCxhQUFhLENBQUMsQ0FBQyxDQUFDLEdBQUcsVUFBVSxDQUFDO0lBQ2hDLENBQUM7SUFFRCxPQUFPLGFBQWEsQ0FBQztBQUN2QixDQUFDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIi9Vc2Vycy9jaHJpc3R5bWF4d2VsbC9EZXNrdG9wL0x1a2VfU3R1ZmYvR2l0SHViL1NDL2NvcmUvc3JjL2NyeXB0by9zaGFtaXIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBTaGFtaXIncyBTZWNyZXQgU2hhcmluZyBJbXBsZW1lbnRhdGlvblxuICogVXNlcyBHRigyXjgpIGFyaXRobWV0aWMgd2l0aCBSaWpuZGFlbCdzIGZpbml0ZSBmaWVsZCAocG9seTogMHgxMWIpXG4gKi9cblxuLy8gUmlqbmRhZWwncyBmaW5pdGUgZmllbGQgcG9seW5vbWlhbDogeF44ICsgeF40ICsgeF4zICsgeCArIDEgKDB4MTFiKVxuLy8gV2UgcHJlY29tcHV0ZSBsb2cgYW5kIGV4cCB0YWJsZXMgZm9yIGZhc3QgbXVsdGlwbGljYXRpb24vZGl2aXNpb25cbmNvbnN0IExPR19UQUJMRSA9IG5ldyBVaW50OEFycmF5KDI1Nik7XG5jb25zdCBFWFBfVEFCTEUgPSBuZXcgVWludDhBcnJheSgyNTYpO1xuXG5mdW5jdGlvbiBpbml0VGFibGVzKCkge1xuICBsZXQgeCA9IDE7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgMjU1OyBpKyspIHtcbiAgICBFWFBfVEFCTEVbaV0gPSB4O1xuICAgIExPR19UQUJMRVt4XSA9IGk7XG5cbiAgICAvLyBNdWx0aXBseSBieSAzOiAoeCAqIDIpIF4geFxuICAgIC8vIHggKiAyIGNvbXB1dGF0aW9uIHdpdGggcmVkdWN0aW9uXG4gICAgbGV0IHgyID0geCA8PCAxO1xuICAgIGlmICh4ICYgMHg4MCkge1xuICAgICAgLy8gQ2hlY2sgaGlnaCBiaXQgb2YgYnl0ZSAoc2luY2UgeCBpcyBieXRlKVxuICAgICAgeDIgXj0gMHgxMWI7XG4gICAgfVxuICAgIC8vIFJlc3VsdCBpcyB4MiBeIHggKHdoaWNoIGlzIHgqMylcbiAgICB4ID0geDIgXiB4O1xuICAgIC8vIGVuc3VyZSB4IGlzIGJ5dGVcbiAgICB4ICY9IDB4ZmY7XG4gIH1cbiAgLy8gTE9HWzBdIGlzIHVuZGVmaW5lZCBpZGVhbGx5LCBidXQgd2Ugd29uJ3QgdXNlIGl0XG59XG5cbmluaXRUYWJsZXMoKTtcblxuLy8gR0YoMl44KSBBZGRpdGlvbi9TdWJ0cmFjdGlvbiAoWE9SKVxuZnVuY3Rpb24gYWRkKGE6IG51bWJlciwgYjogbnVtYmVyKTogbnVtYmVyIHtcbiAgcmV0dXJuIGEgXiBiO1xufVxuXG4vLyBHRigyXjgpIE11bHRpcGxpY2F0aW9uXG5mdW5jdGlvbiBtdWwoYTogbnVtYmVyLCBiOiBudW1iZXIpOiBudW1iZXIge1xuICBpZiAoYSA9PT0gMCB8fCBiID09PSAwKSByZXR1cm4gMDtcbiAgY29uc3QgbG9nQSA9IExPR19UQUJMRVthXTtcbiAgY29uc3QgbG9nQiA9IExPR19UQUJMRVtiXTtcbiAgY29uc3QgbG9nU3VtID0gKGxvZ0EgKyBsb2dCKSAlIDI1NTtcbiAgcmV0dXJuIEVYUF9UQUJMRVtsb2dTdW1dO1xufVxuXG4vLyBHRigyXjgpIERpdmlzaW9uXG5mdW5jdGlvbiBkaXYoYTogbnVtYmVyLCBiOiBudW1iZXIpOiBudW1iZXIge1xuICBpZiAoYiA9PT0gMCkgdGhyb3cgbmV3IEVycm9yKFwiRGl2aXNpb24gYnkgemVyb1wiKTtcbiAgaWYgKGEgPT09IDApIHJldHVybiAwO1xuICBjb25zdCBsb2dBID0gTE9HX1RBQkxFW2FdO1xuICBjb25zdCBsb2dCID0gTE9HX1RBQkxFW2JdO1xuICBjb25zdCBsb2dEaWZmID0gKGxvZ0EgLSBsb2dCICsgMjU1KSAlIDI1NTtcbiAgcmV0dXJuIEVYUF9UQUJMRVtsb2dEaWZmXTtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBuIGRpc3RpbmN0IHJhbmRvbSBzaGFyZXMgZm9yIGEgc2VjcmV0LCBzdWNoIHRoYXQgYW55IGsgYXJlIHJlcXVpcmVkIHRvIHJlY29uc3RydWN0LlxuICogQHBhcmFtIHNlY3JldCBUaGUgc2VjcmV0IGJ5dGVzIChVaW50OEFycmF5KVxuICogQHBhcmFtIG4gVG90YWwgbnVtYmVyIG9mIHNoYXJlcyB0byBnZW5lcmF0ZVxuICogQHBhcmFtIGsgVGhyZXNob2xkIG51bWJlciBvZiBzaGFyZXMgdG8gcmVjb25zdHJ1Y3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNwbGl0KFxuICBzZWNyZXQ6IFVpbnQ4QXJyYXksXG4gIG46IG51bWJlcixcbiAgazogbnVtYmVyLFxuKTogQXJyYXk8eyB4OiBudW1iZXI7IHk6IFVpbnQ4QXJyYXkgfT4ge1xuICBpZiAoayA+IG4pIHRocm93IG5ldyBFcnJvcihcIlRocmVzaG9sZCBrIGNhbm5vdCBiZSBncmVhdGVyIHRoYW4gblwiKTtcbiAgaWYgKGsgPCAxKSB0aHJvdyBuZXcgRXJyb3IoXCJUaHJlc2hvbGQgayBtdXN0IGJlIGF0IGxlYXN0IDFcIik7XG5cbiAgY29uc3QgbGVuID0gc2VjcmV0Lmxlbmd0aDtcbiAgY29uc3Qgc2hhcmVzOiBBcnJheTx7IHg6IG51bWJlcjsgeTogVWludDhBcnJheSB9PiA9IFtdO1xuXG4gIC8vIEluaXRpYWxpemUgc2hhcmVzXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgc2hhcmVzLnB1c2goeyB4OiBpICsgMSwgeTogbmV3IFVpbnQ4QXJyYXkobGVuKSB9KTtcbiAgfVxuXG4gIC8vIEdlbmVyYXRlIHJhbmRvbSBwb2x5bm9taWFscyBmb3IgZWFjaCBieXRlIG9mIHRoZSBzZWNyZXRcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIC8vIFBvbHlub21pYWw6IHMgKyBhMSp4ICsgYTIqeF4yICsgLi4uICsgYWstMSp4XihrLTEpXG4gICAgLy8gY29lZmZzWzBdIGlzIHRoZSBzZWNyZXQgYnl0ZVxuICAgIGNvbnN0IGNvZWZmcyA9IG5ldyBVaW50OEFycmF5KGspO1xuICAgIGNvZWZmc1swXSA9IHNlY3JldFtpXTtcblxuICAgIC8vIEdlbmVyYXRlIHJhbmRvbSBjb2VmZmljaWVudHMgYTEuLi5hay0xXG4gICAgaWYgKGsgPiAxKSB7XG4gICAgICBjb25zdCByYW5kb21CeXRlcyA9IG5ldyBVaW50OEFycmF5KGsgLSAxKTtcbiAgICAgIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMocmFuZG9tQnl0ZXMpO1xuICAgICAgZm9yIChsZXQgaiA9IDE7IGogPCBrOyBqKyspIHtcbiAgICAgICAgY29lZmZzW2pdID0gcmFuZG9tQnl0ZXNbaiAtIDFdO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEV2YWx1YXRlIHBvbHlub21pYWwgZm9yIGVhY2ggc2hhcmUgKHg9MS4ubilcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IG47IGorKykge1xuICAgICAgY29uc3QgeCA9IGogKyAxO1xuICAgICAgLy8gSG9ybmVyJ3MgbWV0aG9kIG9yIGRpcmVjdD8gRGlyZWN0IGlzIHNpbXBsZXIgZm9yIHNtYWxsIGtcbiAgICAgIC8vIHkgPSBjMCArIGMxKnggKyBjMip4XjIgLi4uXG5cbiAgICAgIC8vIENvcnJlY3QgSG9ybmVyJ3M6XG4gICAgICAvLyBQKHgpID0gYzAgKyB4KGMxICsgeChjMiArIC4uLikpXG4gICAgICBsZXQgdmFsID0gMDtcbiAgICAgIC8vIFJldmVyc2UgY29lZmZpY2llbnQgaXRlcmF0aW9uIGZvciBIb3JuZXIncyBub3QgdG90YWxseSBzdGFuZGFyZCxcbiAgICAgIC8vIGxldCdzIGRvIGRpcmVjdCBzdW0gZm9yIGNsYXJpdHkgb24gc21hbGwgZmluaXRlIGZpZWxkc1xuXG4gICAgICAvLyBWYWwgPSBTdW0oIGNfbSAqIHhebSApXG4gICAgICBmb3IgKGxldCBtID0gMDsgbSA8IGs7IG0rKykge1xuICAgICAgICAvLyBDYWxjdWxhdGUgeF5tXG4gICAgICAgIGxldCB4UG93ID0gMTtcbiAgICAgICAgZm9yIChsZXQgcCA9IDA7IHAgPCBtOyBwKyspIHhQb3cgPSBtdWwoeFBvdywgeCk7XG5cbiAgICAgICAgY29uc3QgdGVybSA9IG11bChjb2VmZnNbbV0sIHhQb3cpO1xuICAgICAgICB2YWwgPSBhZGQodmFsLCB0ZXJtKTtcbiAgICAgIH1cbiAgICAgIHNoYXJlc1tqXS55W2ldID0gdmFsO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzaGFyZXM7XG59XG5cbi8qKlxuICogUmVjb25zdHJ1Y3QgdGhlIHNlY3JldCBmcm9tIGsgc2hhcmVzLlxuICogQHBhcmFtIHNoYXJlcyBUaGUgYXJyYXkgb2Ygc2hhcmVzIChvYmplY3RzIHdpdGggeCBhbmQgeSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbWJpbmUoXG4gIHNoYXJlczogQXJyYXk8eyB4OiBudW1iZXI7IHk6IFVpbnQ4QXJyYXkgfT4sXG4pOiBVaW50OEFycmF5IHtcbiAgaWYgKHNoYXJlcy5sZW5ndGggPT09IDApIHRocm93IG5ldyBFcnJvcihcIk5vIHNoYXJlcyBwcm92aWRlZFwiKTtcbiAgY29uc3QgbGVuID0gc2hhcmVzWzBdLnkubGVuZ3RoO1xuICAvLyBXZSBuZWVkIGF0IGxlYXN0IGsgc2hhcmVzLCBidXQgd2UgYXNzdW1lIHRoZSBwcm92aWRlZCBzaGFyZXMgQVJFIHRoZSBrIHNoYXJlcyAob3IgbW9yZSlcbiAgLy8gV2UgdXNlIExhZ3JhbmdlIEludGVycG9sYXRpb24gYXQgeD0wXG5cbiAgY29uc3QgcmVjb25zdHJ1Y3RlZCA9IG5ldyBVaW50OEFycmF5KGxlbik7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIC8vIEZvciBlYWNoIGJ5dGUgcG9zaXRpb25cbiAgICBsZXQgc2VjcmV0Qnl0ZSA9IDA7XG5cbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IHNoYXJlcy5sZW5ndGg7IGorKykge1xuICAgICAgY29uc3QgeyB4OiB4aiwgeTogeUJsb2NrIH0gPSBzaGFyZXNbal07XG4gICAgICBjb25zdCB5aiA9IHlCbG9ja1tpXTtcblxuICAgICAgLy8gQ29tcHV0ZSBMYWdyYW5nZSBiYXNpcyBwb2x5bm9taWFsIExfaigwKVxuICAgICAgLy8gTF9qKDApID0gUHJvZHVjdCAoICgwIC0geG0pIC8gKHhqIC0geG0pICkgZm9yIG0gIT0galxuICAgICAgbGV0IG51bWVyYXRvciA9IDE7XG4gICAgICBsZXQgZGVub21pbmF0b3IgPSAxO1xuXG4gICAgICBmb3IgKGxldCBtID0gMDsgbSA8IHNoYXJlcy5sZW5ndGg7IG0rKykge1xuICAgICAgICBpZiAobSA9PT0gaikgY29udGludWU7XG4gICAgICAgIGNvbnN0IHhtID0gc2hhcmVzW21dLng7XG5cbiAgICAgICAgLy8gKDAgLSB4bSkgPSAteG0gPSB4bSBpbiBHRigyXm4pIGJlY2F1c2UgYWRkaXRpb24gaXMgWE9SXG4gICAgICAgIG51bWVyYXRvciA9IG11bChudW1lcmF0b3IsIHhtKTtcbiAgICAgICAgLy8gKHhqIC0geG0pID0geGogXiB4bVxuICAgICAgICBkZW5vbWluYXRvciA9IG11bChkZW5vbWluYXRvciwgYWRkKHhqLCB4bSkpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBsYWdyYW5nZSA9IG11bChudW1lcmF0b3IsIGRpdigxLCBkZW5vbWluYXRvcikpOyAvLyBudW0gKiAoMS9kZW4pXG4gICAgICBjb25zdCB0ZXJtID0gbXVsKHlqLCBsYWdyYW5nZSk7XG5cbiAgICAgIHNlY3JldEJ5dGUgPSBhZGQoc2VjcmV0Qnl0ZSwgdGVybSk7XG4gICAgfVxuXG4gICAgcmVjb25zdHJ1Y3RlZFtpXSA9IHNlY3JldEJ5dGU7XG4gIH1cblxuICByZXR1cm4gcmVjb25zdHJ1Y3RlZDtcbn1cbiJdLCJ2ZXJzaW9uIjozfQ==