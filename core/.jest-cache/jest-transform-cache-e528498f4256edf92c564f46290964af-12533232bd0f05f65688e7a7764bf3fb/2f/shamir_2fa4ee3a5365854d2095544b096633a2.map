{"file":"/Users/christymaxwell/Desktop/Luke_Stuff/GitHub/SC/core/src/crypto/shamir.ts","mappings":"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","names":[],"sources":["/Users/christymaxwell/Desktop/Luke_Stuff/GitHub/SC/core/src/crypto/shamir.ts"],"sourcesContent":["/**\n * Shamir's Secret Sharing Implementation\n * Uses GF(2^8) arithmetic with Rijndael's finite field (poly: 0x11b)\n */\n\n// Rijndael's finite field polynomial: x^8 + x^4 + x^3 + x + 1 (0x11b)\n// We precompute log and exp tables for fast multiplication/division\nconst LOG_TABLE = new Uint8Array(256);\nconst EXP_TABLE = new Uint8Array(256);\n\nfunction initTables() {\n  let x = 1;\n  for (let i = 0; i < 255; i++) {\n    EXP_TABLE[i] = x;\n    LOG_TABLE[x] = i;\n\n    // Multiply by 3: (x * 2) ^ x\n    // x * 2 computation with reduction\n    let x2 = x << 1;\n    if (x & 0x80) {\n      // Check high bit of byte (since x is byte)\n      x2 ^= 0x11b;\n    }\n    // Result is x2 ^ x (which is x*3)\n    x = x2 ^ x;\n    // ensure x is byte\n    x &= 0xff;\n  }\n  // LOG[0] is undefined ideally, but we won't use it\n}\n\ninitTables();\n\n// GF(2^8) Addition/Subtraction (XOR)\nfunction add(a: number, b: number): number {\n  return a ^ b;\n}\n\n// GF(2^8) Multiplication\nfunction mul(a: number, b: number): number {\n  if (a === 0 || b === 0) return 0;\n  const logA = LOG_TABLE[a];\n  const logB = LOG_TABLE[b];\n  const logSum = (logA + logB) % 255;\n  return EXP_TABLE[logSum];\n}\n\n// GF(2^8) Division\nfunction div(a: number, b: number): number {\n  if (b === 0) throw new Error(\"Division by zero\");\n  if (a === 0) return 0;\n  const logA = LOG_TABLE[a];\n  const logB = LOG_TABLE[b];\n  const logDiff = (logA - logB + 255) % 255;\n  return EXP_TABLE[logDiff];\n}\n\n/**\n * Generate n distinct random shares for a secret, such that any k are required to reconstruct.\n * @param secret The secret bytes (Uint8Array)\n * @param n Total number of shares to generate\n * @param k Threshold number of shares to reconstruct\n */\nexport function split(\n  secret: Uint8Array,\n  n: number,\n  k: number,\n): Array<{ x: number; y: Uint8Array }> {\n  if (k > n) throw new Error(\"Threshold k cannot be greater than n\");\n  if (k < 1) throw new Error(\"Threshold k must be at least 1\");\n\n  const len = secret.length;\n  const shares: Array<{ x: number; y: Uint8Array }> = [];\n\n  // Initialize shares\n  for (let i = 0; i < n; i++) {\n    shares.push({ x: i + 1, y: new Uint8Array(len) });\n  }\n\n  // Generate random polynomials for each byte of the secret\n  for (let i = 0; i < len; i++) {\n    // Polynomial: s + a1*x + a2*x^2 + ... + ak-1*x^(k-1)\n    // coeffs[0] is the secret byte\n    const coeffs = new Uint8Array(k);\n    coeffs[0] = secret[i];\n\n    // Generate random coefficients a1...ak-1\n    if (k > 1) {\n      const randomBytes = new Uint8Array(k - 1);\n      crypto.getRandomValues(randomBytes);\n      for (let j = 1; j < k; j++) {\n        coeffs[j] = randomBytes[j - 1];\n      }\n    }\n\n    // Evaluate polynomial for each share (x=1..n)\n    for (let j = 0; j < n; j++) {\n      const x = j + 1;\n      // Horner's method or direct? Direct is simpler for small k\n      // y = c0 + c1*x + c2*x^2 ...\n\n      // Correct Horner's:\n      // P(x) = c0 + x(c1 + x(c2 + ...))\n      let val = 0;\n      // Reverse coefficient iteration for Horner's not totally standard,\n      // let's do direct sum for clarity on small finite fields\n\n      // Val = Sum( c_m * x^m )\n      for (let m = 0; m < k; m++) {\n        // Calculate x^m\n        let xPow = 1;\n        for (let p = 0; p < m; p++) xPow = mul(xPow, x);\n\n        const term = mul(coeffs[m], xPow);\n        val = add(val, term);\n      }\n      shares[j].y[i] = val;\n    }\n  }\n\n  return shares;\n}\n\n/**\n * Reconstruct the secret from k shares.\n * @param shares The array of shares (objects with x and y)\n */\nexport function combine(\n  shares: Array<{ x: number; y: Uint8Array }>,\n): Uint8Array {\n  if (shares.length === 0) throw new Error(\"No shares provided\");\n  const len = shares[0].y.length;\n  // We need at least k shares, but we assume the provided shares ARE the k shares (or more)\n  // We use Lagrange Interpolation at x=0\n\n  const reconstructed = new Uint8Array(len);\n\n  for (let i = 0; i < len; i++) {\n    // For each byte position\n    let secretByte = 0;\n\n    for (let j = 0; j < shares.length; j++) {\n      const { x: xj, y: yBlock } = shares[j];\n      const yj = yBlock[i];\n\n      // Compute Lagrange basis polynomial L_j(0)\n      // L_j(0) = Product ( (0 - xm) / (xj - xm) ) for m != j\n      let numerator = 1;\n      let denominator = 1;\n\n      for (let m = 0; m < shares.length; m++) {\n        if (m === j) continue;\n        const xm = shares[m].x;\n\n        // (0 - xm) = -xm = xm in GF(2^n) because addition is XOR\n        numerator = mul(numerator, xm);\n        // (xj - xm) = xj ^ xm\n        denominator = mul(denominator, add(xj, xm));\n      }\n\n      const lagrange = mul(numerator, div(1, denominator)); // num * (1/den)\n      const term = mul(yj, lagrange);\n\n      secretByte = add(secretByte, term);\n    }\n\n    reconstructed[i] = secretByte;\n  }\n\n  return reconstructed;\n}\n"],"version":3}