{"file":"/Users/christymaxwell/Desktop/Luke_Stuff/GitHub/SC/core/src/discovery/reachability.ts","mappings":"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","names":[],"sources":["/Users/christymaxwell/Desktop/Luke_Stuff/GitHub/SC/core/src/discovery/reachability.ts"],"sourcesContent":["/**\n * Enhanced Reachability Verification\n * Task 56: Implement comprehensive peer reachability testing\n * \n * Features:\n * - Ping/pong protocol\n * - Latency measurement\n * - Reachability caching\n * - Event notifications\n * - Multi-method testing\n */\n\nexport interface PingMessage {\n  type: 'ping';\n  id: string;              // Unique ping ID\n  timestamp: number;       // Send timestamp\n  method: ReachabilityMethod;\n}\n\nexport interface PongMessage {\n  type: 'pong';\n  id: string;              // Same ID as ping\n  pingTimestamp: number;   // Original ping timestamp\n  pongTimestamp: number;   // Pong send timestamp\n}\n\nexport type ReachabilityMethod = 'direct' | 'webrtc' | 'relay' | 'ble';\n\nexport interface ReachabilityResult {\n  peerId: string;\n  reachable: boolean;\n  latency?: number;        // Round-trip time in ms\n  method?: ReachabilityMethod;\n  timestamp: number;\n  attempts: number;\n  error?: string;\n}\n\nexport interface ReachabilityOptions {\n  timeout: number;         // Timeout per attempt (ms)\n  maxAttempts: number;     // Max retry attempts\n  methods: ReachabilityMethod[];  // Methods to try\n  cacheTimeout: number;    // Cache validity (ms)\n}\n\nconst DEFAULT_OPTIONS: ReachabilityOptions = {\n  timeout: 5000,           // 5 seconds\n  maxAttempts: 3,\n  methods: ['direct', 'webrtc', 'relay'],\n  cacheTimeout: 60000,     // 1 minute\n};\n\ninterface Unrefable {\n  unref: () => void;\n}\n\nexport class ReachabilityVerifier {\n  private options: ReachabilityOptions;\n  private cache = new Map<string, ReachabilityResult>();\n  private pendingPings = new Map<string, {\n    resolve: (result: ReachabilityResult) => void;\n    reject: (error: Error) => void;\n    timestamp: number;\n    timeout: NodeJS.Timeout;\n  }>();\n  private listeners = new Map<string, Set<(...args: any[]) => any>>();\n\n  constructor(options: Partial<ReachabilityOptions> = {}) {\n    this.options = { ...DEFAULT_OPTIONS, ...options };\n  }\n\n  /**\n   * Test peer reachability\n   */\n  async testReachability(\n    peerId: string,\n    onSendPing: (peerId: string, ping: PingMessage) => Promise<void>\n  ): Promise<ReachabilityResult> {\n    // Check cache first\n    const cached = this.getCached(peerId);\n    if (cached && this.isCacheValid(cached)) {\n      return cached;\n    }\n\n    // Try each method until one succeeds\n    let lastError: string | undefined;\n    \n    for (const method of this.options.methods) {\n      try {\n        const result = await this.testWithMethod(peerId, method, onSendPing);\n        \n        if (result.reachable) {\n          // Cache successful result\n          this.cache.set(peerId, result);\n          this.emit('reachable', result);\n          return result;\n        }\n        \n        lastError = result.error;\n      } catch (error) {\n        lastError = error instanceof Error ? error.message : 'Unknown error';\n      }\n    }\n\n    // All methods failed\n    const failedResult: ReachabilityResult = {\n      peerId,\n      reachable: false,\n      timestamp: Date.now(),\n      attempts: this.options.methods.length * this.options.maxAttempts,\n      error: lastError,\n    };\n\n    this.cache.set(peerId, failedResult);\n    this.emit('unreachable', failedResult);\n    \n    return failedResult;\n  }\n\n  /**\n   * Test reachability with specific method\n   */\n  private async testWithMethod(\n    peerId: string,\n    method: ReachabilityMethod,\n    onSendPing: (peerId: string, ping: PingMessage) => Promise<void>\n  ): Promise<ReachabilityResult> {\n    let attempts = 0;\n    let lastError: string | undefined;\n\n    while (attempts < this.options.maxAttempts) {\n      attempts++;\n\n      try {\n        const ping: PingMessage = {\n          type: 'ping',\n          id: this.generatePingId(),\n          timestamp: Date.now(),\n          method,\n        };\n\n        // Send ping\n        const sendTime = Date.now();\n        await onSendPing(peerId, ping);\n\n        // Wait for pong\n        const _pong = await this.waitForPong(ping.id, this.options.timeout);\n        const receiveTime = Date.now();\n\n        // Calculate latency\n        const latency = receiveTime - sendTime;\n\n        return {\n          peerId,\n          reachable: true,\n          latency,\n          method,\n          timestamp: Date.now(),\n          attempts,\n        };\n      } catch (error) {\n        lastError = error instanceof Error ? error.message : 'Ping timeout';\n        \n        // Exponential backoff before retry\n        if (attempts < this.options.maxAttempts) {\n          await this.delay(Math.min(1000 * attempts, 5000));\n        }\n      }\n    }\n\n    return {\n      peerId,\n      reachable: false,\n      method,\n      timestamp: Date.now(),\n      attempts,\n      error: lastError,\n    };\n  }\n\n  /**\n   * Handle incoming pong message\n   */\n  handlePong(pong: PongMessage): void {\n    const pending = this.pendingPings.get(pong.id);\n    \n    if (!pending) {\n      // Unsolicited pong or already handled\n      return;\n    }\n\n    clearTimeout(pending.timeout);\n    this.pendingPings.delete(pong.id);\n    \n    // Resolve the waiting promise\n    pending.resolve(pong as any);\n  }\n\n  /**\n   * Wait for pong response\n   */\n  private waitForPong(pingId: string, timeout: number): Promise<PongMessage> {\n    return new Promise((resolve, reject) => {\n      const timeoutHandle = setTimeout(() => {\n        this.pendingPings.delete(pingId);\n        reject(new Error('Ping timeout'));\n      }, timeout);\n      this.unrefTimeout(timeoutHandle);\n\n      this.pendingPings.set(pingId, {\n        resolve: (result) => {\n          // This is called from handlePong\n          resolve(result as any);\n        },\n        reject,\n        timestamp: Date.now(),\n        timeout: timeoutHandle,\n      });\n    });\n  }\n\n  /**\n   * Create pong response\n   */\n  createPong(ping: PingMessage): PongMessage {\n    return {\n      type: 'pong',\n      id: ping.id,\n      pingTimestamp: ping.timestamp,\n      pongTimestamp: Date.now(),\n    };\n  }\n\n  /**\n   * Get cached reachability result\n   */\n  getCached(peerId: string): ReachabilityResult | null {\n    const cached = this.cache.get(peerId);\n    \n    if (!cached) {\n      return null;\n    }\n\n    if (!this.isCacheValid(cached)) {\n      this.cache.delete(peerId);\n      return null;\n    }\n\n    return cached;\n  }\n\n  /**\n   * Check if cached result is still valid\n   */\n  private isCacheValid(result: ReachabilityResult): boolean {\n    const age = Date.now() - result.timestamp;\n    return age < this.options.cacheTimeout;\n  }\n\n  /**\n   * Get reachability status\n   */\n  getStatus(peerId: string): 'reachable' | 'unreachable' | 'unknown' {\n    const cached = this.getCached(peerId);\n    \n    if (!cached) {\n      return 'unknown';\n    }\n\n    return cached.reachable ? 'reachable' : 'unreachable';\n  }\n\n  /**\n   * Clear cache for peer\n   */\n  clearCache(peerId: string): void {\n    this.cache.delete(peerId);\n  }\n\n  /**\n   * Clear all cached results\n   */\n  clearAllCache(): void {\n    this.cache.clear();\n  }\n\n  /**\n   * Get all cached results\n   */\n  getAllCached(): Map<string, ReachabilityResult> {\n    // Filter out expired entries\n    for (const [peerId, result] of this.cache.entries()) {\n      if (!this.isCacheValid(result)) {\n        this.cache.delete(peerId);\n      }\n    }\n    \n    return new Map(this.cache);\n  }\n\n  /**\n   * Measure latency to peer\n   */\n  async measureLatency(\n    peerId: string,\n    onSendPing: (peerId: string, ping: PingMessage) => Promise<void>,\n    samples: number = 5\n  ): Promise<number[]> {\n    const latencies: number[] = [];\n\n    for (let i = 0; i < samples; i++) {\n      const result = await this.testReachability(peerId, onSendPing);\n      \n      if (result.reachable && result.latency !== undefined) {\n        latencies.push(result.latency);\n      }\n\n      // Small delay between pings\n      if (i < samples - 1) {\n        await this.delay(100);\n      }\n    }\n\n    return latencies;\n  }\n\n  /**\n   * Get average latency\n   */\n  static getAverageLatency(latencies: number[]): number {\n    if (latencies.length === 0) return 0;\n    return latencies.reduce((sum, val) => sum + val, 0) / latencies.length;\n  }\n\n  /**\n   * Get median latency (more robust than average)\n   */\n  static getMedianLatency(latencies: number[]): number {\n    if (latencies.length === 0) return 0;\n    \n    const sorted = [...latencies].sort((a, b) => a - b);\n    const mid = Math.floor(sorted.length / 2);\n    \n    if (sorted.length % 2 === 0) {\n      return (sorted[mid - 1] + sorted[mid]) / 2;\n    }\n    \n    return sorted[mid];\n  }\n\n  /**\n   * Get latency statistics\n   */\n  static getLatencyStats(latencies: number[]): {\n    min: number;\n    max: number;\n    avg: number;\n    median: number;\n    jitter: number;  // Variance in latency\n  } {\n    if (latencies.length === 0) {\n      return { min: 0, max: 0, avg: 0, median: 0, jitter: 0 };\n    }\n\n    const min = Math.min(...latencies);\n    const max = Math.max(...latencies);\n    const avg = this.getAverageLatency(latencies);\n    const median = this.getMedianLatency(latencies);\n    \n    // Calculate jitter (standard deviation)\n    const variance = latencies.reduce((sum, val) => {\n      return sum + Math.pow(val - avg, 2);\n    }, 0) / latencies.length;\n    const jitter = Math.sqrt(variance);\n\n    return { min, max, avg, median, jitter };\n  }\n\n  /**\n   * Register event listener\n   */\n  on(event: 'reachable' | 'unreachable' | 'timeout', callback: (result: ReachabilityResult) => void): void {\n    if (!this.listeners.has(event)) {\n      this.listeners.set(event, new Set());\n    }\n    this.listeners.get(event)!.add(callback);\n  }\n\n  /**\n   * Unregister event listener\n   */\n  off(event: string, callback: (...args: any[]) => any): void {\n    const handlers = this.listeners.get(event);\n    if (handlers) {\n      handlers.delete(callback);\n    }\n  }\n\n  /**\n   * Emit event\n   */\n  private emit(event: string, data: any): void {\n    const handlers = this.listeners.get(event);\n    if (handlers) {\n      handlers.forEach(handler => handler(data));\n    }\n  }\n\n  /**\n   * Generate unique ping ID\n   */\n  private generatePingId(): string {\n    return `ping-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;\n  }\n\n  /**\n   * Delay helper\n   */\n  private delay(ms: number): Promise<void> {\n    return new Promise(resolve => {\n      // Used for simple backoff; no cancellation/rejection path is needed\n      const handle = setTimeout(resolve, ms);\n      this.unrefTimeout(handle);\n    });\n  }\n\n  /**\n   * Ensure timers don't keep the event loop alive in Node environments\n   */\n  private unrefTimeout(handle: unknown): void {\n    // In browser runtimes this is a no-op; Node supports unref to avoid holding the event loop\n    if (this.isUnrefable(handle)) {\n      handle.unref();\n    }\n  }\n\n  private isUnrefable(handle: unknown): handle is Unrefable {\n    if (!handle || typeof handle !== 'object') {\n      return false;\n    }\n    const maybe = handle as Partial<Unrefable>;\n    return typeof maybe.unref === 'function';\n  }\n\n  /**\n   * Cleanup resources\n   */\n  cleanup(): void {\n    // Clear all pending pings\n    for (const [_id, pending] of this.pendingPings.entries()) {\n      clearTimeout(pending.timeout);\n      pending.reject(new Error('Verifier cleanup'));\n    }\n    \n    this.pendingPings.clear();\n    this.cache.clear();\n    this.listeners.clear();\n  }\n}\n\n/**\n * Utility function to test reachability with default settings\n */\nexport async function testPeerReachability(\n  peerId: string,\n  onSendPing: (peerId: string, ping: PingMessage) => Promise<void>\n): Promise<ReachabilityResult> {\n  const verifier = new ReachabilityVerifier();\n  try {\n    return await verifier.testReachability(peerId, onSendPing);\n  } finally {\n    verifier.cleanup();\n  }\n}\n"],"version":3}