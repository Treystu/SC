{"file":"/Users/christymaxwell/Desktop/Luke_Stuff/GitHub/SC/core/src/crypto/storage.ts","mappings":"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","names":[],"sources":["/Users/christymaxwell/Desktop/Luke_Stuff/GitHub/SC/core/src/crypto/storage.ts"],"sourcesContent":["/**\n * Secure key storage abstraction for different platforms\n * \n * Platform-specific implementations:\n * - Web: IndexedDB with Web Crypto API encryption\n * - Node.js: Memory storage (for testing)\n * - iOS: Keychain Services (platform-specific)\n * - Android: KeyStore (platform-specific)\n * \n * Security Features:\n * - Encryption at rest\n * - Key versioning and migration\n * - Access control\n * - Automatic key wiping on deletion\n */\n\nimport { encryptMessage, decryptMessage, generateSessionKey, secureWipe } from './primitives.js';\n\nexport interface KeyStorage {\n  /**\n   * Store a key securely\n   */\n  storeKey(keyId: string, key: Uint8Array, metadata?: KeyMetadata): Promise<void>;\n\n  /**\n   * Retrieve a key\n   */\n  getKey(keyId: string): Promise<Uint8Array | null>;\n\n  /**\n   * Delete a key (with secure wiping)\n   */\n  deleteKey(keyId: string): Promise<void>;\n\n  /**\n   * Check if a key exists\n   */\n  hasKey(keyId: string): Promise<boolean>;\n\n  /**\n   * List all key IDs\n   */\n  listKeys(): Promise<string[]>;\n  \n  /**\n   * Get key metadata\n   */\n  getKeyMetadata(keyId: string): Promise<KeyMetadata | null>;\n  \n  /**\n   * Migrate keys to new storage version\n   */\n  migrateKeys?(fromVersion: number, toVersion: number): Promise<void>;\n}\n\n/**\n * Key metadata for versioning and access control\n */\nexport interface KeyMetadata {\n  version: number;\n  createdAt: number;\n  lastAccessedAt?: number;\n  accessCount?: number;\n  tags?: string[];\n}\n\n/**\n * Stored key with encryption and metadata\n */\ninterface StoredKey {\n  encryptedKey: Uint8Array;\n  nonce: Uint8Array;\n  metadata: KeyMetadata;\n}\n\n/**\n * Web implementation using IndexedDB with Web Crypto API encryption\n * \n * Features:\n * - Keys encrypted at rest using Web Crypto API\n * - Automatic key unwrapping\n * - Version migration support\n * - Access control and metadata tracking\n */\nexport class WebKeyStorage implements KeyStorage {\n  private dbName = 'sc-keystore';\n  private storeName = 'keys';\n  private metadataStore = 'metadata';\n  private db: IDBDatabase | null = null;\n  private storageVersion = 2;\n  private masterKey: Uint8Array | null = null;\n\n  /**\n   * Initialize or derive master encryption key\n   * In production, this should use Web Crypto API's key unwrapping\n   */\n  private async getMasterKey(): Promise<Uint8Array> {\n    if (!this.masterKey) {\n      // In a real implementation, this would use Web Crypto API to:\n      // 1. Derive key from password (PBKDF2)\n      // 2. Or unwrap key stored in browser's key storage\n      // For now, we use a session-based key\n      const sessionKey = generateSessionKey();\n      this.masterKey = sessionKey.key;\n    }\n    return this.masterKey!;\n  }\n\n  async init(): Promise<void> {\n    return new Promise((resolve, reject) => {\n      const request = indexedDB.open(this.dbName, this.storageVersion);\n\n      request.onerror = () => reject(request.error);\n      request.onsuccess = () => {\n        this.db = request.result;\n        resolve();\n      };\n\n      request.onupgradeneeded = (event) => {\n        const db = (event.target as IDBOpenDBRequest).result;\n        const oldVersion = event.oldVersion;\n        \n        // Create stores if they don't exist\n        if (!db.objectStoreNames.contains(this.storeName)) {\n          db.createObjectStore(this.storeName);\n        }\n        \n        if (!db.objectStoreNames.contains(this.metadataStore)) {\n          db.createObjectStore(this.metadataStore);\n        }\n        \n        // Handle version migration\n        if (oldVersion < this.storageVersion) {\n          console.log(`Migrating key storage from version ${oldVersion} to ${this.storageVersion}`);\n        }\n      };\n    });\n  }\n\n  async storeKey(keyId: string, key: Uint8Array, metadata?: KeyMetadata): Promise<void> {\n    if (!this.db) await this.init();\n    \n    const masterKey = await this.getMasterKey();\n    const sessionKey = generateSessionKey();\n    \n    // Encrypt key before storing\n    const encryptedKey = encryptMessage(key, masterKey, sessionKey.nonce);\n    \n    const storedKey: StoredKey = {\n      encryptedKey,\n      nonce: sessionKey.nonce,\n      metadata: metadata || {\n        version: this.storageVersion,\n        createdAt: Date.now(),\n        accessCount: 0,\n      },\n    };\n    \n    return new Promise((resolve, reject) => {\n      const transaction = this.db!.transaction([this.storeName, this.metadataStore], 'readwrite');\n      const keyStore = transaction.objectStore(this.storeName);\n      const metaStore = transaction.objectStore(this.metadataStore);\n      \n      // The put requests are needed to trigger the transaction, but we don't need their results\n      keyStore.put(storedKey, keyId);\n      metaStore.put(storedKey.metadata, keyId);\n\n      transaction.oncomplete = () => resolve();\n      transaction.onerror = () => reject(transaction.error);\n    });\n  }\n\n  async getKey(keyId: string): Promise<Uint8Array | null> {\n    if (!this.db) await this.init();\n\n    return new Promise((resolve, reject) => {\n      const transaction = this.db!.transaction([this.storeName, this.metadataStore], 'readwrite');\n      const keyStore = transaction.objectStore(this.storeName);\n      const metaStore = transaction.objectStore(this.metadataStore);\n      const request = keyStore.get(keyId);\n\n      request.onsuccess = async () => {\n        const storedKey: StoredKey | undefined = request.result;\n        if (!storedKey) {\n          resolve(null);\n          return;\n        }\n        \n        try {\n          const masterKey = await this.getMasterKey();\n          const decryptedKey = decryptMessage(storedKey.encryptedKey, masterKey, storedKey.nonce);\n          \n          // Update access metadata\n          storedKey.metadata.lastAccessedAt = Date.now();\n          storedKey.metadata.accessCount = (storedKey.metadata.accessCount || 0) + 1;\n          metaStore.put(storedKey.metadata, keyId);\n          \n          resolve(decryptedKey);\n        } catch (error) {\n          reject(new Error('Failed to decrypt key: ' + error));\n        }\n      };\n      \n      request.onerror = () => reject(request.error);\n    });\n  }\n\n  async deleteKey(keyId: string): Promise<void> {\n    if (!this.db) await this.init();\n\n    // First get the key to wipe it\n    const key = await this.getKey(keyId);\n    if (key) {\n      secureWipe(key);\n    }\n\n    return new Promise((resolve, reject) => {\n      const transaction = this.db!.transaction([this.storeName, this.metadataStore], 'readwrite');\n      const keyStore = transaction.objectStore(this.storeName);\n      const metaStore = transaction.objectStore(this.metadataStore);\n      \n      keyStore.delete(keyId);\n      metaStore.delete(keyId);\n\n      transaction.oncomplete = () => resolve();\n      transaction.onerror = () => reject(transaction.error);\n    });\n  }\n\n  async hasKey(keyId: string): Promise<boolean> {\n    const key = await this.getKey(keyId);\n    return key !== null;\n  }\n\n  async listKeys(): Promise<string[]> {\n    if (!this.db) await this.init();\n\n    return new Promise((resolve, reject) => {\n      const transaction = this.db!.transaction([this.storeName], 'readonly');\n      const store = transaction.objectStore(this.storeName);\n      const request = store.getAllKeys();\n\n      request.onsuccess = () => resolve(request.result as string[]);\n      request.onerror = () => reject(request.error);\n    });\n  }\n  \n  async getKeyMetadata(keyId: string): Promise<KeyMetadata | null> {\n    if (!this.db) await this.init();\n\n    return new Promise((resolve, reject) => {\n      const transaction = this.db!.transaction([this.metadataStore], 'readonly');\n      const store = transaction.objectStore(this.metadataStore);\n      const request = store.get(keyId);\n\n      request.onsuccess = () => resolve(request.result || null);\n      request.onerror = () => reject(request.error);\n    });\n  }\n  \n  async migrateKeys(fromVersion: number, toVersion: number): Promise<void> {\n    console.log(`Migrating keys from version ${fromVersion} to ${toVersion}`);\n    \n    const keyIds = await this.listKeys();\n    \n    for (const keyId of keyIds) {\n      const metadata = await this.getKeyMetadata(keyId);\n      if (metadata && metadata.version < toVersion) {\n        // Re-encrypt key with new version\n        const key = await this.getKey(keyId);\n        if (key) {\n          metadata.version = toVersion;\n          await this.storeKey(keyId, key, metadata);\n          secureWipe(key);\n        }\n      }\n    }\n  }\n}\n\n/**\n * In-memory implementation for Node.js/testing\n * Includes encryption and metadata tracking like Web implementation\n */\nexport class MemoryKeyStorage implements KeyStorage {\n  private keys: Map<string, StoredKey> = new Map();\n  private masterKey: Uint8Array;\n\n  constructor() {\n    const sessionKey = generateSessionKey();\n    this.masterKey = sessionKey.key;\n  }\n\n  async storeKey(keyId: string, key: Uint8Array, metadata?: KeyMetadata): Promise<void> {\n    if (!keyId || keyId.trim() === '') {\n      throw new Error('Key ID cannot be empty');\n    }\n    if (!key) {\n      throw new Error('Key value cannot be null or undefined');\n    }\n\n    const sessionKey = generateSessionKey();\n    const encryptedKey = encryptMessage(key, this.masterKey, sessionKey.nonce);\n    \n    const storedKey: StoredKey = {\n      encryptedKey,\n      nonce: sessionKey.nonce,\n      metadata: metadata || {\n        version: 1,\n        createdAt: Date.now(),\n        accessCount: 0,\n      },\n    };\n    \n    this.keys.set(keyId, storedKey);\n  }\n\n  async getKey(keyId: string): Promise<Uint8Array | null> {\n    if (!keyId) {\n      throw new Error('Key ID cannot be null or undefined');\n    }\n\n    const storedKey = this.keys.get(keyId);\n    if (!storedKey) return null;\n    \n    try {\n      const decryptedKey = decryptMessage(storedKey.encryptedKey, this.masterKey, storedKey.nonce);\n      \n      // Update access metadata\n      storedKey.metadata.lastAccessedAt = Date.now();\n      storedKey.metadata.accessCount = (storedKey.metadata.accessCount || 0) + 1;\n      \n      return decryptedKey;\n    } catch (error) {\n      throw new Error('Failed to decrypt key: ' + error);\n    }\n  }\n\n  async deleteKey(keyId: string): Promise<void> {\n    const storedKey = this.keys.get(keyId);\n    if (storedKey) {\n      // Securely wipe encrypted key\n      secureWipe(storedKey.encryptedKey);\n      secureWipe(storedKey.nonce);\n    }\n    this.keys.delete(keyId);\n  }\n\n  async hasKey(keyId: string): Promise<boolean> {\n    return this.keys.has(keyId);\n  }\n\n  async listKeys(): Promise<string[]> {\n    return Array.from(this.keys.keys());\n  }\n  \n  async getKeyMetadata(keyId: string): Promise<KeyMetadata | null> {\n    const storedKey = this.keys.get(keyId);\n    return storedKey ? storedKey.metadata : null;\n  }\n  \n  async migrateKeys(fromVersion: number, toVersion: number): Promise<void> {\n    const keyIds = await this.listKeys();\n    \n    for (const keyId of keyIds) {\n      const metadata = await this.getKeyMetadata(keyId);\n      if (metadata && metadata.version < toVersion) {\n        const key = await this.getKey(keyId);\n        if (key) {\n          metadata.version = toVersion;\n          await this.storeKey(keyId, key, metadata);\n          secureWipe(key);\n        }\n      }\n    }\n  }\n\n  clear(): void {\n    // Securely wipe all keys before clearing\n    for (const storedKey of this.keys.values()) {\n      secureWipe(storedKey.encryptedKey);\n      secureWipe(storedKey.nonce);\n    }\n    this.keys.clear();\n  }\n\n  async clearAll(): Promise<void> {\n    this.clear();\n  }\n\n  async removeOldKeys(beforeTimestamp: number): Promise<void> {\n    const keysToRemove: string[] = [];\n    \n    for (const [keyId, storedKey] of this.keys.entries()) {\n      if (storedKey.metadata.createdAt < beforeTimestamp) {\n        keysToRemove.push(keyId);\n      }\n    }\n    \n    for (const keyId of keysToRemove) {\n      await this.deleteKey(keyId);\n    }\n  }\n\n  async findKeysByTag(tag: string): Promise<string[]> {\n    const result: string[] = [];\n    \n    for (const [keyId, storedKey] of this.keys.entries()) {\n      if (storedKey.metadata.tags && storedKey.metadata.tags.includes(tag)) {\n        result.push(keyId);\n      }\n    }\n    \n    return result;\n  }\n\n  async count(): Promise<number> {\n    return this.keys.size;\n  }\n\n  async getStorageSize(): Promise<number> {\n    let totalSize = 0;\n    \n    for (const storedKey of this.keys.values()) {\n      totalSize += storedKey.encryptedKey.byteLength;\n      totalSize += storedKey.nonce.byteLength;\n    }\n    \n    return totalSize;\n  }\n}\n"],"version":3}