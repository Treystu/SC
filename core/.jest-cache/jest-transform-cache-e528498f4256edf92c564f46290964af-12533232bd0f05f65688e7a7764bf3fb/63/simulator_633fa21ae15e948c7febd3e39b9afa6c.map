{"file":"/Users/christymaxwell/Desktop/Luke_Stuff/GitHub/SC/core/src/simulation/simulator.ts","mappings":"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","names":[],"sources":["/Users/christymaxwell/Desktop/Luke_Stuff/GitHub/SC/core/src/simulation/simulator.ts"],"sourcesContent":["import { MeshNetwork } from \"../mesh/network.js\";\nimport { IdentityKeyPair, generateIdentity } from \"../crypto/primitives.js\";\n\ninterface SimNode {\n  id: string;\n  network: MeshNetwork;\n  identity: IdentityKeyPair;\n}\n\nexport class NetworkSimulator {\n  nodes: Map<string, SimNode> = new Map();\n  latency: number = 10; // ms\n  dropRate: number = 0.0;\n\n  constructor() {}\n\n  async createNode(): Promise<SimNode> {\n    const identity = await generateIdentity();\n    const network = new MeshNetwork({\n      identity: identity,\n      maxPeers: 50,\n    });\n\n    // Hook up transport\n    network.registerOutboundTransport(async (targetId, data) => {\n      await this.deliver(identity.publicKey, targetId, data);\n    });\n\n    const id = Buffer.from(identity.publicKey).toString(\"hex\");\n    const node: SimNode = { id, network, identity };\n    this.nodes.set(id, node);\n\n    // Start network\n    // We don't need to await this if it's just setting up listeners\n    // network.start(); // Assuming start method exists or is implicitly ready\n\n    return node;\n  }\n\n  async deliver(senderKey: Uint8Array, targetId: string, data: Uint8Array) {\n    // Simulate network delay\n    await new Promise((r) => setTimeout(r, this.latency));\n\n    if (Math.random() < this.dropRate) return;\n\n    const target = this.nodes.get(targetId);\n    if (target) {\n      // console.log(`DELIVER: ${Buffer.from(senderKey).toString('hex').substring(0,8)} -> ${targetId.substring(0,8)} (${data.length} bytes)`);\n      const senderId = Buffer.from(senderKey).toString(\"hex\");\n      // We need to pass the sender ID to handleIncomingPacket so it knows who it's from\n      // The MeshNetwork.handleIncomingPacket signature is (peerId: string, data: Uint8Array)\n      await target.network.handleIncomingPacket(senderId, data);\n    } else {\n      console.warn(`DELIVER FAIL: Target ${targetId} not found`);\n    }\n  }\n\n  /**\n   * Connect two nodes (Virtual Connection)\n   * This forces them to know each other in their routing tables.\n   */\n  async connect(nodeA: SimNode, nodeB: SimNode) {\n    // Manually inject into routing tables to simulate connection\n    const peerA = {\n      id: nodeA.id,\n      publicKey: nodeA.identity.publicKey,\n      lastSeen: Date.now(),\n      transportType: \"native\",\n      state: \"connected\",\n      metadata: { capabilities: {} },\n    };\n\n    const peerB = {\n      id: nodeB.id,\n      publicKey: nodeB.identity.publicKey,\n      lastSeen: Date.now(),\n      transportType: \"native\",\n      state: \"connected\",\n      metadata: { capabilities: {} },\n    };\n\n    // Access private routingTable via cast\n    (nodeA.network as any).routingTable.addPeer(peerB);\n    (nodeB.network as any).routingTable.addPeer(peerA);\n  }\n}\n"],"version":3}