{"file":"/Users/christymaxwell/Desktop/Luke_Stuff/GitHub/SC/core/src/mesh/traffic-padding.ts","mappings":"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","names":[],"sources":["/Users/christymaxwell/Desktop/Luke_Stuff/GitHub/SC/core/src/mesh/traffic-padding.ts"],"sourcesContent":["/**\n * Traffic Padding for Metadata Privacy\n * \n * Implements message padding to prevent traffic analysis based on message size.\n * Messages are padded to fixed size buckets to obscure actual content length.\n * \n * Security Benefits:\n * - Prevents message size analysis (e.g., \"short message = yes/no answer\")\n * - Obscures message type (text, image, file, etc.)\n * - Makes traffic analysis more difficult\n * \n * Trade-offs:\n * - Increased bandwidth (10-30% overhead typical)\n * - Slight increase in processing time\n * - Battery impact on mobile devices\n * \n * Configuration:\n * - Multiple size buckets (256, 512, 1024, 2048, 4096 bytes)\n * - Padding algorithm (PKCS7-style or random)\n * - Optional compression before padding\n */\n\n/**\n * Standard message size buckets (in bytes)\n * \n * These sizes are chosen to:\n * - Cover common message sizes efficiently\n * - Limit bandwidth overhead\n * - Provide good privacy/efficiency trade-off\n */\nexport const MESSAGE_SIZE_BUCKETS = [\n  256,   // Short messages, status updates\n  512,   // Medium text messages\n  1024,  // Long messages, small images\n  2048,  // Files, larger images\n  4096,  // Large files (chunked)\n  8192,  // Very large content (chunked)\n  16384  // Maximum single message size\n] as const;\n\n/**\n * Padding configuration\n */\nexport interface PaddingConfig {\n  /** Whether padding is enabled */\n  enabled: boolean;\n  \n  /** Size buckets to use */\n  sizeBuckets: readonly number[];\n  \n  /** Padding strategy */\n  strategy: 'pkcs7' | 'random' | 'zero';\n  \n  /** Whether to compress before padding */\n  compress: boolean;\n  \n  /** Maximum message size (messages larger will be rejected) */\n  maxMessageSize: number;\n}\n\n/**\n * Default padding configuration\n */\nexport const DEFAULT_PADDING_CONFIG: PaddingConfig = {\n  enabled: true,\n  sizeBuckets: MESSAGE_SIZE_BUCKETS,\n  strategy: 'random',\n  compress: false, // Compression can leak information\n  maxMessageSize: 16384\n};\n\n/**\n * Padded message structure\n */\nexport interface PaddedMessage {\n  /** Padded data */\n  data: Uint8Array;\n  \n  /** Original size (stored in last 2 bytes) */\n  originalSize: number;\n  \n  /** Bucket size used */\n  bucketSize: number;\n  \n  /** Padding overhead (bytes) */\n  overhead: number;\n}\n\n/**\n * Traffic padding manager\n */\nexport class TrafficPadding {\n  private config: PaddingConfig;\n  private stats = {\n    messagesPadded: 0,\n    messagesUnpadded: 0,\n    totalOverhead: 0,\n    averageOverhead: 0\n  };\n  \n  constructor(config: Partial<PaddingConfig> = {}) {\n    this.config = { ...DEFAULT_PADDING_CONFIG, ...config };\n  }\n  \n  /**\n   * Pad a message to the next size bucket\n   * \n   * @param message - Original message\n   * @returns Padded message\n   * @throws Error if message exceeds maximum size\n   */\n  pad(message: Uint8Array): PaddedMessage {\n    if (!this.config.enabled) {\n      // Padding disabled, return as-is\n      return {\n        data: message,\n        originalSize: message.length,\n        bucketSize: message.length,\n        overhead: 0\n      };\n    }\n    \n    const originalSize = message.length;\n    \n    // Check maximum size\n    if (originalSize > this.config.maxMessageSize) {\n      throw new Error(`Message size ${originalSize} exceeds maximum ${this.config.maxMessageSize}`);\n    }\n    \n    // Find next bucket size\n    const bucketSize = this.findBucketSize(originalSize);\n    \n    // Create padded array\n    const padded = new Uint8Array(bucketSize);\n    \n    // Copy original message\n    padded.set(message, 0);\n    \n    // Add padding\n    const paddingLength = bucketSize - originalSize - 2; // Reserve 2 bytes for size\n    \n    if (paddingLength < 0) {\n      throw new Error('Invalid bucket size calculation');\n    }\n    \n    switch (this.config.strategy) {\n      case 'random': {\n        // Random padding (most secure but higher cost)\n        const randomPadding = crypto.getRandomValues(new Uint8Array(paddingLength));\n        padded.set(randomPadding, originalSize);\n        break;\n      }\n        \n      case 'zero':\n        // Zero padding (efficient but less secure)\n        // Array is already zero-filled\n        break;\n        \n      case 'pkcs7': {\n        // PKCS7-style padding (repeating padding length byte)\n        const pkcs7Value = paddingLength & 0xFF;\n        for (let i = originalSize; i < originalSize + paddingLength; i++) {\n          padded[i] = pkcs7Value;\n        }\n        break;\n      }\n    }\n    \n    // Store original size in last 2 bytes (big-endian)\n    const view = new DataView(padded.buffer);\n    view.setUint16(bucketSize - 2, originalSize, false);\n    \n    // Update statistics\n    this.stats.messagesPadded++;\n    const overhead = bucketSize - originalSize;\n    this.stats.totalOverhead += overhead;\n    this.stats.averageOverhead = this.stats.totalOverhead / this.stats.messagesPadded;\n    \n    return {\n      data: padded,\n      originalSize,\n      bucketSize,\n      overhead\n    };\n  }\n  \n  /**\n   * Unpad a message to recover original content\n   * \n   * @param paddedData - Padded message data\n   * @returns Original message\n   * @throws Error if unpadding fails (corrupted data)\n   */\n  unpad(paddedData: Uint8Array): Uint8Array {\n    if (!this.config.enabled) {\n      // Padding disabled, return as-is\n      return paddedData;\n    }\n    \n    if (paddedData.length < 2) {\n      throw new Error('Padded data too short');\n    }\n    \n    // Read original size from last 2 bytes\n    const view = new DataView(paddedData.buffer, paddedData.byteOffset);\n    const originalSize = view.getUint16(paddedData.length - 2, false);\n    \n    // Validate original size\n    if (originalSize > paddedData.length - 2) {\n      throw new Error('Invalid original size: possible corruption');\n    }\n    \n    if (originalSize < 0) {\n      throw new Error('Invalid original size: negative value');\n    }\n    \n    // Extract original message\n    const original = paddedData.slice(0, originalSize);\n    \n    // Update statistics\n    this.stats.messagesUnpadded++;\n    \n    return original;\n  }\n  \n  /**\n   * Find appropriate bucket size for message\n   * \n   * @param messageSize - Original message size\n   * @returns Bucket size to use\n   */\n  private findBucketSize(messageSize: number): number {\n    // Need to account for 2-byte size field\n    const sizeWithField = messageSize + 2;\n    \n    // Find smallest bucket that fits\n    for (const bucket of this.config.sizeBuckets) {\n      if (sizeWithField <= bucket) {\n        return bucket;\n      }\n    }\n    \n    // Message too large for any bucket\n    throw new Error(`Message size ${messageSize} too large for available buckets`);\n  }\n  \n  /**\n   * Calculate padding overhead for a message size\n   * \n   * @param messageSize - Original message size\n   * @returns Overhead in bytes and percentage\n   */\n  calculateOverhead(messageSize: number): { bytes: number; percentage: number } {\n    if (!this.config.enabled) {\n      return { bytes: 0, percentage: 0 };\n    }\n    \n    try {\n      const bucketSize = this.findBucketSize(messageSize);\n      const overhead = bucketSize - messageSize;\n      const percentage = (overhead / messageSize) * 100;\n      \n      return { bytes: overhead, percentage };\n    } catch {\n      return { bytes: -1, percentage: -1 };\n    }\n  }\n  \n  /**\n   * Get bucket distribution statistics\n   * \n   * @param messageSizes - Array of message sizes\n   * @returns Distribution of messages across buckets\n   */\n  getBucketDistribution(messageSizes: number[]): Map<number, number> {\n    const distribution = new Map<number, number>();\n    \n    for (const bucket of this.config.sizeBuckets) {\n      distribution.set(bucket, 0);\n    }\n    \n    for (const size of messageSizes) {\n      try {\n        const bucket = this.findBucketSize(size);\n        distribution.set(bucket, (distribution.get(bucket) || 0) + 1);\n      } catch {\n        // Message too large, skip\n      }\n    }\n    \n    return distribution;\n  }\n  \n  /**\n   * Update configuration\n   * \n   * @param updates - Partial config updates\n   */\n  updateConfig(updates: Partial<PaddingConfig>): void {\n    this.config = { ...this.config, ...updates };\n  }\n  \n  /**\n   * Get current configuration\n   */\n  getConfig(): Readonly<PaddingConfig> {\n    return { ...this.config };\n  }\n  \n  /**\n   * Get statistics\n   */\n  getStats() {\n    return { ...this.stats };\n  }\n  \n  /**\n   * Reset statistics\n   */\n  resetStats(): void {\n    this.stats = {\n      messagesPadded: 0,\n      messagesUnpadded: 0,\n      totalOverhead: 0,\n      averageOverhead: 0\n    };\n  }\n  \n  /**\n   * Estimate bandwidth overhead for a traffic pattern\n   * \n   * @param messageSizes - Array of typical message sizes\n   * @returns Estimated overhead percentage\n   */\n  static estimateBandwidthOverhead(\n    messageSizes: number[],\n    config: Partial<PaddingConfig> = {}\n  ): number {\n    const padding = new TrafficPadding(config);\n    \n    let totalOriginal = 0;\n    let totalPadded = 0;\n    \n    for (const size of messageSizes) {\n      try {\n        const padded = padding.pad(new Uint8Array(size));\n        totalOriginal += size;\n        totalPadded += padded.bucketSize;\n      } catch {\n        // Skip messages that are too large\n      }\n    }\n    \n    if (totalOriginal === 0) {\n      return 0;\n    }\n    \n    const overhead = totalPadded - totalOriginal;\n    return (overhead / totalOriginal) * 100;\n  }\n}\n\n/**\n * Adaptive padding strategy that adjusts based on network conditions\n */\nexport class AdaptivePadding extends TrafficPadding {\n  private networkLatency: number = 0;\n  private bandwidthLimit: number = 0;\n  \n  /**\n   * Update network conditions\n   * \n   * @param latency - Network latency in ms\n   * @param bandwidth - Available bandwidth in bytes/sec\n   */\n  updateNetworkConditions(latency: number, bandwidth: number): void {\n    this.networkLatency = latency;\n    this.bandwidthLimit = bandwidth;\n    \n    // Adjust padding strategy based on conditions\n    if (bandwidth < 100000) {\n      // Low bandwidth: reduce padding\n      this.updateConfig({\n        sizeBuckets: [512, 1024, 2048],\n        strategy: 'zero' // Faster than random\n      });\n    } else if (bandwidth > 1000000) {\n      // High bandwidth: use full padding for privacy\n      this.updateConfig({\n        sizeBuckets: MESSAGE_SIZE_BUCKETS,\n        strategy: 'random'\n      });\n    }\n  }\n  \n  /**\n   * Decide whether to pad based on network conditions\n   * \n   * @param messageSize - Size of message to potentially pad\n   * @returns Whether padding should be applied\n   */\n  shouldPad(messageSize: number): boolean {\n    // Always pad if configured\n    const config = this.getConfig();\n    if (!config.enabled) {\n      return false;\n    }\n    \n    // Skip padding for very small messages on low bandwidth\n    if (this.bandwidthLimit < 100000 && messageSize < 128) {\n      return false;\n    }\n    \n    return true;\n  }\n}\n\n/**\n * Timing obfuscation (send dummy messages to hide traffic patterns)\n * \n * Note: This is more advanced and may not be suitable for all use cases.\n * It increases bandwidth usage significantly.\n */\nexport class TimingObfuscation {\n  private dummyMessageInterval: number = 10000; // 10 seconds\n  private enabled: boolean = false;\n  private intervalId?: number;\n  \n  /**\n   * Start sending dummy messages at regular intervals\n   * \n   * @param callback - Function to send dummy message\n   * @param interval - Interval in milliseconds\n   */\n  start(callback: () => void, interval: number = 10000): void {\n    this.enabled = true;\n    this.dummyMessageInterval = interval;\n    \n    const t = setInterval(callback, interval);\n    this.intervalId = t as unknown as number;\n    try {\n      if (t && typeof (t as any).unref === 'function') {\n        (t as any).unref();\n      }\n    } catch (e) { /* no-op */ }\n  }\n  \n  /**\n   * Stop sending dummy messages\n   */\n  stop(): void {\n    this.enabled = false;\n    \n    if (this.intervalId !== undefined) {\n      clearInterval(this.intervalId);\n      this.intervalId = undefined;\n    }\n  }\n  \n  /**\n   * Check if timing obfuscation is active\n   */\n  isActive(): boolean {\n    return this.enabled;\n  }\n}\n"],"version":3}