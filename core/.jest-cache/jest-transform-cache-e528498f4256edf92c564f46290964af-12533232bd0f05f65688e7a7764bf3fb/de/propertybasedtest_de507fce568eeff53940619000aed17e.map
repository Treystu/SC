{"file":"/Users/christymaxwell/Desktop/Luke_Stuff/GitHub/SC/core/src/crypto/property-based.test.ts","mappings":"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","names":[],"sources":["/Users/christymaxwell/Desktop/Luke_Stuff/GitHub/SC/core/src/crypto/property-based.test.ts"],"sourcesContent":["/**\n * Property-based tests for crypto primitives\n */\nimport fc from \"fast-check\";\nimport {\n  generateIdentity,\n  signMessage,\n  verifySignature,\n  performKeyExchange,\n  deriveSharedSecret,\n  encryptMessage,\n  decryptMessage,\n  randomBytes,\n} from \"./primitives\";\n\ndescribe(\"Crypto Property-Based Tests\", () => {\n  describe(\"Identity generation\", () => {\n    it(\"should generate unique identities\", async () => {\n      await fc.assert(\n        fc.asyncProperty(fc.nat(10), async () => {\n          const identity1 = await generateIdentity();\n          const identity2 = await generateIdentity();\n\n          // Public keys should be different\n          expect(\n            Buffer.from(identity1.publicKey).equals(\n              Buffer.from(identity2.publicKey),\n            ),\n          ).toBe(false);\n          // Private keys should be different\n          expect(\n            Buffer.from(identity1.privateKey).equals(\n              Buffer.from(identity2.privateKey),\n            ),\n          ).toBe(false);\n        }),\n        { numRuns: 10 },\n      );\n    });\n\n    it(\"should generate valid key pairs\", async () => {\n      await fc.assert(\n        fc.asyncProperty(fc.nat(10), async () => {\n          const identity = await generateIdentity();\n\n          // Keys should have correct length\n          expect(identity.publicKey.length).toBe(32);\n          expect(identity.privateKey.length).toBe(32);\n\n          // Keys should not be all zeros\n          const pubKeySum = identity.publicKey.reduce((a, b) => a + b, 0);\n          const privKeySum = identity.privateKey.reduce((a, b) => a + b, 0);\n          expect(pubKeySum).toBeGreaterThan(0);\n          expect(privKeySum).toBeGreaterThan(0);\n        }),\n        { numRuns: 10 },\n      );\n    });\n  });\n\n  describe(\"Message signing\", () => {\n    it(\"should verify any message signed with the same key\", async () => {\n      await fc.assert(\n        fc.asyncProperty(\n          fc.uint8Array({ minLength: 1, maxLength: 1000 }),\n          async (data) => {\n            const identity = await generateIdentity();\n            const signature = await signMessage(data, identity.privateKey);\n            const isValid = await verifySignature(\n              data,\n              signature,\n              identity.publicKey,\n            );\n\n            expect(isValid).toBe(true);\n          },\n        ),\n        { numRuns: 50 },\n      );\n    });\n\n    it(\"should fail verification with wrong public key\", async () => {\n      await fc.assert(\n        fc.asyncProperty(\n          fc.uint8Array({ minLength: 1, maxLength: 1000 }),\n          async (data) => {\n            const identity1 = await generateIdentity();\n            const identity2 = await generateIdentity();\n\n            const signature = await signMessage(data, identity1.privateKey);\n            const isValid = await verifySignature(\n              data,\n              signature,\n              identity2.publicKey,\n            );\n\n            // Should fail with different public key\n            expect(isValid).toBe(false);\n          },\n        ),\n        { numRuns: 50 },\n      );\n    });\n\n    it(\"should fail verification with tampered data\", async () => {\n      await fc.assert(\n        fc.asyncProperty(\n          fc.uint8Array({ minLength: 2, maxLength: 1000 }),\n          async (data) => {\n            const identity = await generateIdentity();\n            const signature = await signMessage(data, identity.privateKey);\n\n            // Tamper with data\n            const tamperedData = new Uint8Array(data);\n            tamperedData[0] = (tamperedData[0] + 1) % 256;\n\n            const isValid = await verifySignature(\n              tamperedData,\n              signature,\n              identity.publicKey,\n            );\n\n            expect(isValid).toBe(false);\n          },\n        ),\n        { numRuns: 50 },\n      );\n    });\n  });\n\n  describe(\"Encryption/Decryption\", () => {\n    it(\"should decrypt any message encrypted with the same key\", async () => {\n      await fc.assert(\n        fc.asyncProperty(\n          fc.uint8Array({ minLength: 1, maxLength: 1000 }),\n          async (plaintext) => {\n            const sender = await generateIdentity();\n            const receiver = await generateIdentity();\n\n            // Derive shared secret\n            const senderSecret = await deriveSharedSecret(\n              sender.privateKey,\n              receiver.publicKey,\n            );\n            const receiverSecret = await deriveSharedSecret(\n              receiver.privateKey,\n              sender.publicKey,\n            );\n\n            // Secrets should match\n            expect(\n              Buffer.from(senderSecret).equals(Buffer.from(receiverSecret)),\n            ).toBe(true);\n\n            // Encrypt and decrypt\n            const nonce = randomBytes(24);\n            const encrypted = await encryptMessage(\n              plaintext,\n              senderSecret,\n              nonce,\n            );\n            const decrypted = await decryptMessage(\n              encrypted,\n              receiverSecret,\n              nonce,\n            );\n\n            expect(Buffer.from(decrypted).equals(Buffer.from(plaintext))).toBe(\n              true,\n            );\n          },\n        ),\n        { numRuns: 50 },\n      );\n    });\n\n    it(\"should fail decryption with wrong key\", async () => {\n      await fc.assert(\n        fc.asyncProperty(\n          fc.uint8Array({ minLength: 1, maxLength: 1000 }),\n          async (plaintext) => {\n            const sender = await generateIdentity();\n            const receiver = await generateIdentity();\n            const attacker = await generateIdentity();\n\n            const senderSecret = await performKeyExchange(\n              sender.privateKey,\n              receiver.publicKey,\n            );\n            const attackerSecret = await performKeyExchange(\n              attacker.privateKey,\n              sender.publicKey,\n            );\n\n            const nonce = randomBytes(24);\n            const encrypted = await encryptMessage(\n              plaintext,\n              senderSecret,\n              nonce,\n            );\n\n            // decryptMessage is synchronous and throws on auth failure.\n            // Use a try/catch to assert it throws instead of using `rejects`.\n            let threw = false;\n            try {\n              decryptMessage(encrypted, attackerSecret, nonce);\n            } catch (err) {\n              threw = true;\n            }\n\n            expect(threw).toBe(true);\n          },\n        ),\n        { numRuns: 30 },\n      );\n    });\n  });\n\n  describe(\"Key exchange properties\", () => {\n    it(\"should produce symmetric shared secrets (commutative)\", async () => {\n      await fc.assert(\n        fc.asyncProperty(fc.nat(10), async () => {\n          const alice = await generateIdentity();\n          const bob = await generateIdentity();\n\n          const aliceShared = await deriveSharedSecret(\n            alice.privateKey,\n            bob.publicKey,\n          );\n          const bobShared = await deriveSharedSecret(\n            bob.privateKey,\n            alice.publicKey,\n          );\n\n          expect(Buffer.from(aliceShared).equals(Buffer.from(bobShared))).toBe(\n            true,\n          );\n        }),\n        { numRuns: 20 },\n      );\n    });\n\n    it(\"should produce different secrets for different key pairs\", async () => {\n      await fc.assert(\n        fc.asyncProperty(fc.nat(10), async () => {\n          const alice = await generateIdentity();\n          const bob = await generateIdentity();\n          const charlie = await generateIdentity();\n\n          const aliceBobSecret = await performKeyExchange(\n            alice.privateKey,\n            bob.publicKey,\n          );\n          const aliceCharlieSecret = await performKeyExchange(\n            alice.privateKey,\n            charlie.publicKey,\n          );\n\n          expect(\n            Buffer.from(aliceBobSecret).equals(Buffer.from(aliceCharlieSecret)),\n          ).toBe(false);\n        }),\n        { numRuns: 20 },\n      );\n    });\n  });\n});\n"],"version":3}