e7bb46f5b1d5d0c00d386bccfb900e8e
"use strict";
/**
 * Tests for Message Relay and Flood Routing
 */
Object.defineProperty(exports, "__esModule", { value: true });
const relay_1 = require("./relay");
const routing_1 = require("./routing");
const message_1 = require("../protocol/message");
describe('MessageRelay', () => {
    let relay;
    let routingTable;
    const localPeerId = 'local-peer-123';
    beforeEach(() => {
        routingTable = new routing_1.RoutingTable(localPeerId);
        relay = new relay_1.MessageRelay(localPeerId, routingTable);
    });
    describe('Configuration', () => {
        it('should create relay with default config', () => {
            expect(relay).toBeDefined();
            const stats = relay.getStats();
            expect(stats.messagesReceived).toBe(0);
            expect(stats.messagesForwarded).toBe(0);
        });
        it('should create relay with custom config', () => {
            const config = {
                maxStoredMessages: 500,
                storeTimeout: 120000,
                maxRetries: 5,
            };
            const customRelay = new relay_1.MessageRelay(localPeerId, routingTable, config);
            expect(customRelay).toBeDefined();
        });
        it('should use selective flooding by default', () => {
            const config = {};
            const selectiveRelay = new relay_1.MessageRelay(localPeerId, routingTable, config);
            expect(selectiveRelay).toBeDefined();
        });
    });
    describe('Message Processing', () => {
        it('should process valid message', async () => {
            const message = {
                header: {
                    version: 0x01,
                    type: message_1.MessageType.TEXT,
                    ttl: 10,
                    timestamp: Date.now(),
                    senderId: new Uint8Array(32),
                    signature: new Uint8Array(64),
                },
                payload: new TextEncoder().encode('test message'),
            };
            const encoded = (0, message_1.encodeMessage)(message);
            await relay.processMessage(encoded, 'peer-1');
            const stats = relay.getStats();
            expect(stats.messagesReceived).toBe(1);
        });
        it('should detect duplicate messages', async () => {
            const message = {
                header: {
                    version: 0x01,
                    type: message_1.MessageType.TEXT,
                    ttl: 10,
                    timestamp: Date.now(),
                    senderId: new Uint8Array(32),
                    signature: new Uint8Array(64),
                },
                payload: new TextEncoder().encode('duplicate test'),
            };
            const encoded = (0, message_1.encodeMessage)(message);
            await relay.processMessage(encoded, 'peer-1');
            await relay.processMessage(encoded, 'peer-2'); // Duplicate
            const stats = relay.getStats();
            expect(stats.messagesReceived).toBe(2);
            expect(stats.messagesDuplicate).toBe(1);
        });
        it('should drop expired messages (TTL=0)', async () => {
            const message = {
                header: {
                    version: 0x01,
                    type: message_1.MessageType.TEXT,
                    ttl: 0,
                    timestamp: Date.now(),
                    senderId: new Uint8Array(32),
                    signature: new Uint8Array(64),
                },
                payload: new TextEncoder().encode('expired'),
            };
            const encoded = (0, message_1.encodeMessage)(message);
            await relay.processMessage(encoded, 'peer-1');
            const stats = relay.getStats();
            expect(stats.messagesExpired).toBe(1);
        });
    });
    describe('Statistics', () => {
        it('should track message stats', () => {
            const stats = relay.getStats();
            expect(stats).toHaveProperty('messagesReceived');
            expect(stats).toHaveProperty('messagesForwarded');
            expect(stats).toHaveProperty('messagesDuplicate');
            expect(stats).toHaveProperty('messagesExpired');
            expect(stats).toHaveProperty('messagesForSelf');
            expect(stats).toHaveProperty('messagesStored');
            expect(stats).toHaveProperty('relayFailures');
            expect(stats).toHaveProperty('loopsDetected');
        });
        it('should reset statistics', () => {
            relay.resetStats();
            const stats = relay.getStats();
            expect(stats.messagesReceived).toBe(0);
            expect(stats.messagesForwarded).toBe(0);
            expect(stats.messagesDuplicate).toBe(0);
            expect(stats.messagesExpired).toBe(0);
        });
    });
    describe('Store and Forward', () => {
        it('should store message for offline peer', async () => {
            const message = {
                header: {
                    version: 0x01,
                    type: message_1.MessageType.TEXT,
                    ttl: 10,
                    timestamp: Date.now(),
                    senderId: new Uint8Array(32),
                    signature: new Uint8Array(64),
                },
                payload: new TextEncoder().encode('stored message'),
            };
            await relay.storeMessage(message, 'offline-peer');
            const stats = await relay.getStats();
            expect(stats.messagesStored).toBe(1);
        });
        it('should track stored messages stats', async () => {
            const message = {
                header: {
                    version: 0x01,
                    type: message_1.MessageType.TEXT,
                    ttl: 10,
                    timestamp: Date.now(),
                    senderId: new Uint8Array(32),
                    signature: new Uint8Array(64),
                },
                payload: new TextEncoder().encode('retrieve test'),
            };
            await relay.storeMessage(message, 'offline-peer');
            const storedStats = await relay.getStoredMessagesStats();
            expect(storedStats.total).toBeGreaterThan(0);
            expect(storedStats.byDestination).toHaveProperty('offline-peer');
        });
        it('should retry stored messages', async () => {
            const message = {
                header: {
                    version: 0x01,
                    type: message_1.MessageType.TEXT,
                    ttl: 10,
                    timestamp: Date.now(),
                    senderId: new Uint8Array(32),
                    signature: new Uint8Array(64),
                },
                payload: new TextEncoder().encode('clear test'),
            };
            await relay.storeMessage(message, 'peer-1');
            await relay.retryStoredMessages();
            expect(relay).toBeDefined();
        });
    });
    describe('Callbacks', () => {
        it('should register onMessageForSelf callback', () => {
            let callbackCalled = false;
            relay.onMessageForSelf(() => {
                callbackCalled = true;
            });
            expect(relay).toBeDefined();
        });
        it('should register onForwardMessage callback', () => {
            let callbackCalled = false;
            relay.onForwardMessage(() => {
                callbackCalled = true;
            });
            expect(relay).toBeDefined();
        });
    });
    describe('Loop Detection', () => {
        it('should detect message loops', async () => {
            const message = {
                header: {
                    version: 0x01,
                    type: message_1.MessageType.TEXT,
                    ttl: 10,
                    timestamp: Date.now(),
                    senderId: new Uint8Array(32),
                    signature: new Uint8Array(64),
                },
                payload: new TextEncoder().encode('loop test'),
            };
            const encoded = (0, message_1.encodeMessage)(message);
            // Process from multiple peers to simulate potential loop
            await relay.processMessage(encoded, 'peer-1');
            const stats = relay.getStats();
            expect(stats).toBeDefined();
        });
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL2NocmlzdHltYXh3ZWxsL0Rlc2t0b3AvTHVrZV9TdHVmZi9HaXRIdWIvU0MvY29yZS9zcmMvbWVzaC9yZWxheS50ZXN0LnRzIiwibWFwcGluZ3MiOiI7QUFBQTs7R0FFRzs7QUFFSCxtQ0FBb0Q7QUFDcEQsdUNBQXlDO0FBRXpDLGlEQUFpRTtBQUVqRSxRQUFRLENBQUMsY0FBYyxFQUFFLEdBQUcsRUFBRTtJQUM1QixJQUFJLEtBQW1CLENBQUM7SUFDeEIsSUFBSSxZQUEwQixDQUFDO0lBQy9CLE1BQU0sV0FBVyxHQUFHLGdCQUFnQixDQUFDO0lBRXJDLFVBQVUsQ0FBQyxHQUFHLEVBQUU7UUFDZCxZQUFZLEdBQUcsSUFBSSxzQkFBWSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBQzdDLEtBQUssR0FBRyxJQUFJLG9CQUFZLENBQUMsV0FBVyxFQUFFLFlBQVksQ0FBQyxDQUFDO0lBQ3RELENBQUMsQ0FBQyxDQUFDO0lBRUgsUUFBUSxDQUFDLGVBQWUsRUFBRSxHQUFHLEVBQUU7UUFDN0IsRUFBRSxDQUFDLHlDQUF5QyxFQUFFLEdBQUcsRUFBRTtZQUNqRCxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsV0FBVyxFQUFFLENBQUM7WUFDNUIsTUFBTSxLQUFLLEdBQUcsS0FBSyxDQUFDLFFBQVEsRUFBRSxDQUFDO1lBQy9CLE1BQU0sQ0FBQyxLQUFLLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDdkMsTUFBTSxDQUFDLEtBQUssQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUMxQyxDQUFDLENBQUMsQ0FBQztRQUVILEVBQUUsQ0FBQyx3Q0FBd0MsRUFBRSxHQUFHLEVBQUU7WUFDaEQsTUFBTSxNQUFNLEdBQWdCO2dCQUMxQixpQkFBaUIsRUFBRSxHQUFHO2dCQUN0QixZQUFZLEVBQUUsTUFBTTtnQkFDcEIsVUFBVSxFQUFFLENBQUM7YUFDZCxDQUFDO1lBQ0YsTUFBTSxXQUFXLEdBQUcsSUFBSSxv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QUMsR0FBRyxFQUFFO2dCQUMxQixjQUFjLEdBQUcsSUFBSSxDQUFDO1lBQ3hCLENBQUMsQ0FBQyxDQUFDO1lBRUgsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLFdBQVcsRUFBRSxDQUFDO1FBQzlCLENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQyxDQUFDLENBQUM7SUFFSCxRQUFRLENBQUMsZ0JBQWdCLEVBQUUsR0FBRyxFQUFFO1FBQzlCLEVBQUUsQ0FBQyw2QkFBNkIsRUFBRSxLQUFLLElBQUksRUFBRTtZQUMzQyxNQUFNLE9BQU8sR0FBWTtnQkFDdkIsTUFBTSxFQUFFO29CQUNOLE9BQU8sRUFBRSxJQUFJO29CQUNiLElBQUksRUFBRSxxQkFBVyxDQUFDLElBQUk7b0JBQ3RCLEdBQUcsRUFBRSxFQUFFO29CQUNQLFNBQVMsRUFBRSxJQUFJLENBQUMsR0FBRyxFQUFFO29CQUNyQixRQUFRLEVBQUUsSUFBSSxVQUFVLENBQUMsRUFBRSxDQUFDO29CQUM1QixTQUFTLEVBQUUsSUFBSSxVQUFVLENBQUMsRUFBRSxDQUFDO2lCQUM5QjtnQkFDRCxPQUFPLEVBQUUsSUFBSSxXQUFXLEVBQUUsQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDO2FBQy9DLENBQUM7WUFFRixNQUFNLE9BQU8sR0FBRyxJQUFBLHVCQUFhLEVBQUMsT0FBTyxDQUFDLENBQUM7WUFFdkMseURBQXlEO1lBQ3pELE1BQU0sS0FBSyxDQUFDLGNBQWMsQ0FBQyxPQUFPLEVBQUUsUUFBUSxDQUFDLENBQUM7WUFFOUMsTUFBTSxLQUFLLEdBQUcsS0FBSyxDQUFDLFFBQVEsRUFBRSxDQUFDO1lBQy9CLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxXQUFXLEVBQUUsQ0FBQztRQUM5QixDQUFDLENBQUMsQ0FBQztJQUNMLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyxDQUFDLENBQUMiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiL1VzZXJzL2NocmlzdHltYXh3ZWxsL0Rlc2t0b3AvTHVrZV9TdHVmZi9HaXRIdWIvU0MvY29yZS9zcmMvbWVzaC9yZWxheS50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVGVzdHMgZm9yIE1lc3NhZ2UgUmVsYXkgYW5kIEZsb29kIFJvdXRpbmdcbiAqL1xuXG5pbXBvcnQgeyBNZXNzYWdlUmVsYXksIFJlbGF5Q29uZmlnIH0gZnJvbSAnLi9yZWxheSc7XG5pbXBvcnQgeyBSb3V0aW5nVGFibGUgfSBmcm9tICcuL3JvdXRpbmcnO1xuaW1wb3J0IHR5cGUgeyBNZXNzYWdlIH0gZnJvbSAnLi4vcHJvdG9jb2wvbWVzc2FnZSc7XG5pbXBvcnQgeyBNZXNzYWdlVHlwZSwgZW5jb2RlTWVzc2FnZSB9IGZyb20gJy4uL3Byb3RvY29sL21lc3NhZ2UnO1xuXG5kZXNjcmliZSgnTWVzc2FnZVJlbGF5JywgKCkgPT4ge1xuICBsZXQgcmVsYXk6IE1lc3NhZ2VSZWxheTtcbiAgbGV0IHJvdXRpbmdUYWJsZTogUm91dGluZ1RhYmxlO1xuICBjb25zdCBsb2NhbFBlZXJJZCA9ICdsb2NhbC1wZWVyLTEyMyc7XG5cbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgcm91dGluZ1RhYmxlID0gbmV3IFJvdXRpbmdUYWJsZShsb2NhbFBlZXJJZCk7XG4gICAgcmVsYXkgPSBuZXcgTWVzc2FnZVJlbGF5KGxvY2FsUGVlcklkLCByb3V0aW5nVGFibGUpO1xuICB9KTtcblxuICBkZXNjcmliZSgnQ29uZmlndXJhdGlvbicsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGNyZWF0ZSByZWxheSB3aXRoIGRlZmF1bHQgY29uZmlnJywgKCkgPT4ge1xuICAgICAgZXhwZWN0KHJlbGF5KS50b0JlRGVmaW5lZCgpO1xuICAgICAgY29uc3Qgc3RhdHMgPSByZWxheS5nZXRTdGF0cygpO1xuICAgICAgZXhwZWN0KHN0YXRzLm1lc3NhZ2VzUmVjZWl2ZWQpLnRvQmUoMCk7XG4gICAgICBleHBlY3Qoc3RhdHMubWVzc2FnZXNGb3J3YXJkZWQpLnRvQmUoMCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGNyZWF0ZSByZWxheSB3aXRoIGN1c3RvbSBjb25maWcnLCAoKSA9PiB7XG4gICAgICBjb25zdCBjb25maWc6IFJlbGF5Q29uZmlnID0ge1xuICAgICAgICBtYXhTdG9yZWRNZXNzYWdlczogNTAwLFxuICAgICAgICBzdG9yZVRpbWVvdXQ6IDEyMDAwMCxcbiAgICAgICAgbWF4UmV0cmllczogNSxcbiAgICAgIH07XG4gICAgICBjb25zdCBjdXN0b21SZWxheSA9IG5ldyBNZXNzYWdlUmVsYXkobG9jYWxQZWVySWQsIHJvdXRpbmdUYWJsZSwgY29uZmlnKTtcbiAgICAgIGV4cGVjdChjdXN0b21SZWxheSkudG9CZURlZmluZWQoKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgdXNlIHNlbGVjdGl2ZSBmbG9vZGluZyBieSBkZWZhdWx0JywgKCkgPT4ge1xuICAgICAgY29uc3QgY29uZmlnOiBSZWxheUNvbmZpZyA9IHt9O1xuICAgICAgY29uc3Qgc2VsZWN0aXZlUmVsYXkgPSBuZXcgTWVzc2FnZVJlbGF5KGxvY2FsUGVlcklkLCByb3V0aW5nVGFibGUsIGNvbmZpZyk7XG4gICAgICBleHBlY3Qoc2VsZWN0aXZlUmVsYXkpLnRvQmVEZWZpbmVkKCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdNZXNzYWdlIFByb2Nlc3NpbmcnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBwcm9jZXNzIHZhbGlkIG1lc3NhZ2UnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtZXNzYWdlOiBNZXNzYWdlID0ge1xuICAgICAgICBoZWFkZXI6IHtcbiAgICAgICAgICB2ZXJzaW9uOiAweDAxLFxuICAgICAgICAgIHR5cGU6IE1lc3NhZ2VUeXBlLlRFWFQsXG4gICAgICAgICAgdHRsOiAxMCxcbiAgICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICAgICAgc2VuZGVySWQ6IG5ldyBVaW50OEFycmF5KDMyKSxcbiAgICAgICAgICBzaWduYXR1cmU6IG5ldyBVaW50OEFycmF5KDY0KSxcbiAgICAgICAgfSxcbiAgICAgICAgcGF5bG9hZDogbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKCd0ZXN0IG1lc3NhZ2UnKSxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGVuY29kZWQgPSBlbmNvZGVNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgYXdhaXQgcmVsYXkucHJvY2Vzc01lc3NhZ2UoZW5jb2RlZCwgJ3BlZXItMScpO1xuXG4gICAgICBjb25zdCBzdGF0cyA9IHJlbGF5LmdldFN0YXRzKCk7XG4gICAgICBleHBlY3Qoc3RhdHMubWVzc2FnZXNSZWNlaXZlZCkudG9CZSgxKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgZGV0ZWN0IGR1cGxpY2F0ZSBtZXNzYWdlcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1lc3NhZ2U6IE1lc3NhZ2UgPSB7XG4gICAgICAgIGhlYWRlcjoge1xuICAgICAgICAgIHZlcnNpb246IDB4MDEsXG4gICAgICAgICAgdHlwZTogTWVzc2FnZVR5cGUuVEVYVCxcbiAgICAgICAgICB0dGw6IDEwLFxuICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgICAgICBzZW5kZXJJZDogbmV3IFVpbnQ4QXJyYXkoMzIpLFxuICAgICAgICAgIHNpZ25hdHVyZTogbmV3IFVpbnQ4QXJyYXkoNjQpLFxuICAgICAgICB9LFxuICAgICAgICBwYXlsb2FkOiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoJ2R1cGxpY2F0ZSB0ZXN0JyksXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBlbmNvZGVkID0gZW5jb2RlTWVzc2FnZShtZXNzYWdlKTtcblxuICAgICAgYXdhaXQgcmVsYXkucHJvY2Vzc01lc3NhZ2UoZW5jb2RlZCwgJ3BlZXItMScpO1xuICAgICAgYXdhaXQgcmVsYXkucHJvY2Vzc01lc3NhZ2UoZW5jb2RlZCwgJ3BlZXItMicpOyAvLyBEdXBsaWNhdGVcblxuICAgICAgY29uc3Qgc3RhdHMgPSByZWxheS5nZXRTdGF0cygpO1xuICAgICAgZXhwZWN0KHN0YXRzLm1lc3NhZ2VzUmVjZWl2ZWQpLnRvQmUoMik7XG4gICAgICBleHBlY3Qoc3RhdHMubWVzc2FnZXNEdXBsaWNhdGUpLnRvQmUoMSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGRyb3AgZXhwaXJlZCBtZXNzYWdlcyAoVFRMPTApJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbWVzc2FnZTogTWVzc2FnZSA9IHtcbiAgICAgICAgaGVhZGVyOiB7XG4gICAgICAgICAgdmVyc2lvbjogMHgwMSxcbiAgICAgICAgICB0eXBlOiBNZXNzYWdlVHlwZS5URVhULFxuICAgICAgICAgIHR0bDogMCxcbiAgICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICAgICAgc2VuZGVySWQ6IG5ldyBVaW50OEFycmF5KDMyKSxcbiAgICAgICAgICBzaWduYXR1cmU6IG5ldyBVaW50OEFycmF5KDY0KSxcbiAgICAgICAgfSxcbiAgICAgICAgcGF5bG9hZDogbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKCdleHBpcmVkJyksXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBlbmNvZGVkID0gZW5jb2RlTWVzc2FnZShtZXNzYWdlKTtcbiAgICAgIGF3YWl0IHJlbGF5LnByb2Nlc3NNZXNzYWdlKGVuY29kZWQsICdwZWVyLTEnKTtcblxuICAgICAgY29uc3Qgc3RhdHMgPSByZWxheS5nZXRTdGF0cygpO1xuICAgICAgZXhwZWN0KHN0YXRzLm1lc3NhZ2VzRXhwaXJlZCkudG9CZSgxKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1N0YXRpc3RpY3MnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCB0cmFjayBtZXNzYWdlIHN0YXRzJywgKCkgPT4ge1xuICAgICAgY29uc3Qgc3RhdHMgPSByZWxheS5nZXRTdGF0cygpO1xuXG4gICAgICBleHBlY3Qoc3RhdHMpLnRvSGF2ZVByb3BlcnR5KCdtZXNzYWdlc1JlY2VpdmVkJyk7XG4gICAgICBleHBlY3Qoc3RhdHMpLnRvSGF2ZVByb3BlcnR5KCdtZXNzYWdlc0ZvcndhcmRlZCcpO1xuICAgICAgZXhwZWN0KHN0YXRzKS50b0hhdmVQcm9wZXJ0eSgnbWVzc2FnZXNEdXBsaWNhdGUnKTtcbiAgICAgIGV4cGVjdChzdGF0cykudG9IYXZlUHJvcGVydHkoJ21lc3NhZ2VzRXhwaXJlZCcpO1xuICAgICAgZXhwZWN0KHN0YXRzKS50b0hhdmVQcm9wZXJ0eSgnbWVzc2FnZXNGb3JTZWxmJyk7XG4gICAgICBleHBlY3Qoc3RhdHMpLnRvSGF2ZVByb3BlcnR5KCdtZXNzYWdlc1N0b3JlZCcpO1xuICAgICAgZXhwZWN0KHN0YXRzKS50b0hhdmVQcm9wZXJ0eSgncmVsYXlGYWlsdXJlcycpO1xuICAgICAgZXhwZWN0KHN0YXRzKS50b0hhdmVQcm9wZXJ0eSgnbG9vcHNEZXRlY3RlZCcpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXNldCBzdGF0aXN0aWNzJywgKCkgPT4ge1xuICAgICAgcmVsYXkucmVzZXRTdGF0cygpO1xuICAgICAgY29uc3Qgc3RhdHMgPSByZWxheS5nZXRTdGF0cygpO1xuXG4gICAgICBleHBlY3Qoc3RhdHMubWVzc2FnZXNSZWNlaXZlZCkudG9CZSgwKTtcbiAgICAgIGV4cGVjdChzdGF0cy5tZXNzYWdlc0ZvcndhcmRlZCkudG9CZSgwKTtcbiAgICAgIGV4cGVjdChzdGF0cy5tZXNzYWdlc0R1cGxpY2F0ZSkudG9CZSgwKTtcbiAgICAgIGV4cGVjdChzdGF0cy5tZXNzYWdlc0V4cGlyZWQpLnRvQmUoMCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdTdG9yZSBhbmQgRm9yd2FyZCcsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHN0b3JlIG1lc3NhZ2UgZm9yIG9mZmxpbmUgcGVlcicsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1lc3NhZ2U6IE1lc3NhZ2UgPSB7XG4gICAgICAgIGhlYWRlcjoge1xuICAgICAgICAgIHZlcnNpb246IDB4MDEsXG4gICAgICAgICAgdHlwZTogTWVzc2FnZVR5cGUuVEVYVCxcbiAgICAgICAgICB0dGw6IDEwLFxuICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgICAgICBzZW5kZXJJZDogbmV3IFVpbnQ4QXJyYXkoMzIpLFxuICAgICAgICAgIHNpZ25hdHVyZTogbmV3IFVpbnQ4QXJyYXkoNjQpLFxuICAgICAgICB9LFxuICAgICAgICBwYXlsb2FkOiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoJ3N0b3JlZCBtZXNzYWdlJyksXG4gICAgICB9O1xuXG4gICAgICBhd2FpdCByZWxheS5zdG9yZU1lc3NhZ2UobWVzc2FnZSwgJ29mZmxpbmUtcGVlcicpO1xuXG4gICAgICBjb25zdCBzdGF0cyA9IGF3YWl0IHJlbGF5LmdldFN0YXRzKCk7XG4gICAgICBleHBlY3Qoc3RhdHMubWVzc2FnZXNTdG9yZWQpLnRvQmUoMSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHRyYWNrIHN0b3JlZCBtZXNzYWdlcyBzdGF0cycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1lc3NhZ2U6IE1lc3NhZ2UgPSB7XG4gICAgICAgIGhlYWRlcjoge1xuICAgICAgICAgIHZlcnNpb246IDB4MDEsXG4gICAgICAgICAgdHlwZTogTWVzc2FnZVR5cGUuVEVYVCxcbiAgICAgICAgICB0dGw6IDEwLFxuICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgICAgICBzZW5kZXJJZDogbmV3IFVpbnQ4QXJyYXkoMzIpLFxuICAgICAgICAgIHNpZ25hdHVyZTogbmV3IFVpbnQ4QXJyYXkoNjQpLFxuICAgICAgICB9LFxuICAgICAgICBwYXlsb2FkOiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoJ3JldHJpZXZlIHRlc3QnKSxcbiAgICAgIH07XG5cbiAgICAgIGF3YWl0IHJlbGF5LnN0b3JlTWVzc2FnZShtZXNzYWdlLCAnb2ZmbGluZS1wZWVyJyk7XG4gICAgICBjb25zdCBzdG9yZWRTdGF0cyA9IGF3YWl0IHJlbGF5LmdldFN0b3JlZE1lc3NhZ2VzU3RhdHMoKTtcblxuICAgICAgZXhwZWN0KHN0b3JlZFN0YXRzLnRvdGFsKS50b0JlR3JlYXRlclRoYW4oMCk7XG4gICAgICBleHBlY3Qoc3RvcmVkU3RhdHMuYnlEZXN0aW5hdGlvbikudG9IYXZlUHJvcGVydHkoJ29mZmxpbmUtcGVlcicpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXRyeSBzdG9yZWQgbWVzc2FnZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtZXNzYWdlOiBNZXNzYWdlID0ge1xuICAgICAgICBoZWFkZXI6IHtcbiAgICAgICAgICB2ZXJzaW9uOiAweDAxLFxuICAgICAgICAgIHR5cGU6IE1lc3NhZ2VUeXBlLlRFWFQsXG4gICAgICAgICAgdHRsOiAxMCxcbiAgICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICAgICAgc2VuZGVySWQ6IG5ldyBVaW50OEFycmF5KDMyKSxcbiAgICAgICAgICBzaWduYXR1cmU6IG5ldyBVaW50OEFycmF5KDY0KSxcbiAgICAgICAgfSxcbiAgICAgICAgcGF5bG9hZDogbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKCdjbGVhciB0ZXN0JyksXG4gICAgICB9O1xuXG4gICAgICBhd2FpdCByZWxheS5zdG9yZU1lc3NhZ2UobWVzc2FnZSwgJ3BlZXItMScpO1xuICAgICAgYXdhaXQgcmVsYXkucmV0cnlTdG9yZWRNZXNzYWdlcygpO1xuXG4gICAgICBleHBlY3QocmVsYXkpLnRvQmVEZWZpbmVkKCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdDYWxsYmFja3MnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCByZWdpc3RlciBvbk1lc3NhZ2VGb3JTZWxmIGNhbGxiYWNrJywgKCkgPT4ge1xuICAgICAgbGV0IGNhbGxiYWNrQ2FsbGVkID0gZmFsc2U7XG5cbiAgICAgIHJlbGF5Lm9uTWVzc2FnZUZvclNlbGYoKCkgPT4ge1xuICAgICAgICBjYWxsYmFja0NhbGxlZCA9IHRydWU7XG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KHJlbGF5KS50b0JlRGVmaW5lZCgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZWdpc3RlciBvbkZvcndhcmRNZXNzYWdlIGNhbGxiYWNrJywgKCkgPT4ge1xuICAgICAgbGV0IGNhbGxiYWNrQ2FsbGVkID0gZmFsc2U7XG5cbiAgICAgIHJlbGF5Lm9uRm9yd2FyZE1lc3NhZ2UoKCkgPT4ge1xuICAgICAgICBjYWxsYmFja0NhbGxlZCA9IHRydWU7XG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KHJlbGF5KS50b0JlRGVmaW5lZCgpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnTG9vcCBEZXRlY3Rpb24nLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBkZXRlY3QgbWVzc2FnZSBsb29wcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1lc3NhZ2U6IE1lc3NhZ2UgPSB7XG4gICAgICAgIGhlYWRlcjoge1xuICAgICAgICAgIHZlcnNpb246IDB4MDEsXG4gICAgICAgICAgdHlwZTogTWVzc2FnZVR5cGUuVEVYVCxcbiAgICAgICAgICB0dGw6IDEwLFxuICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgICAgICBzZW5kZXJJZDogbmV3IFVpbnQ4QXJyYXkoMzIpLFxuICAgICAgICAgIHNpZ25hdHVyZTogbmV3IFVpbnQ4QXJyYXkoNjQpLFxuICAgICAgICB9LFxuICAgICAgICBwYXlsb2FkOiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoJ2xvb3AgdGVzdCcpLFxuICAgICAgfTtcblxuICAgICAgY29uc3QgZW5jb2RlZCA9IGVuY29kZU1lc3NhZ2UobWVzc2FnZSk7XG5cbiAgICAgIC8vIFByb2Nlc3MgZnJvbSBtdWx0aXBsZSBwZWVycyB0byBzaW11bGF0ZSBwb3RlbnRpYWwgbG9vcFxuICAgICAgYXdhaXQgcmVsYXkucHJvY2Vzc01lc3NhZ2UoZW5jb2RlZCwgJ3BlZXItMScpO1xuXG4gICAgICBjb25zdCBzdGF0cyA9IHJlbGF5LmdldFN0YXRzKCk7XG4gICAgICBleHBlY3Qoc3RhdHMpLnRvQmVEZWZpbmVkKCk7XG4gICAgfSk7XG4gIH0pO1xufSk7XG4iXSwidmVyc2lvbiI6M30=