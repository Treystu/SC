{"file":"/Users/christymaxwell/Desktop/Luke_Stuff/GitHub/SC/core/src/crypto/storage.test.ts","mappings":"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","names":[],"sources":["/Users/christymaxwell/Desktop/Luke_Stuff/GitHub/SC/core/src/crypto/storage.test.ts"],"sourcesContent":["/**\n * Tests for Secure Key Storage\n */\n\nimport { WebKeyStorage, MemoryKeyStorage, KeyMetadata } from './storage';\n\ndescribe('WebKeyStorage', () => {\n  let storage: WebKeyStorage;\n  const testKeyId = 'test-key-123';\n  const testKey = new Uint8Array([1, 2, 3, 4, 5, 6, 7, 8]);\n\n  beforeEach(async () => {\n    storage = new WebKeyStorage();\n    // Skip init for tests (would need IndexedDB mock)\n  });\n\n  describe('Memory Storage (for testing)', () => {\n    let memStorage: MemoryKeyStorage;\n\n    beforeEach(() => {\n      memStorage = new MemoryKeyStorage();\n    });\n\n    it('should store and retrieve keys', async () => {\n      await memStorage.storeKey(testKeyId, testKey);\n      const retrieved = await memStorage.getKey(testKeyId);\n      \n      expect(retrieved).toEqual(testKey);\n    });\n\n    it('should return null for non-existent keys', async () => {\n      const retrieved = await memStorage.getKey('non-existent');\n      expect(retrieved).toBeNull();\n    });\n\n    it('should check if key exists', async () => {\n      await memStorage.storeKey(testKeyId, testKey);\n      \n      const exists = await memStorage.hasKey(testKeyId);\n      const notExists = await memStorage.hasKey('other-key');\n      \n      expect(exists).toBe(true);\n      expect(notExists).toBe(false);\n    });\n\n    it('should delete keys securely', async () => {\n      await memStorage.storeKey(testKeyId, testKey);\n      await memStorage.deleteKey(testKeyId);\n      \n      const retrieved = await memStorage.getKey(testKeyId);\n      expect(retrieved).toBeNull();\n    });\n\n    it('should list all keys', async () => {\n      await memStorage.storeKey('key1', testKey);\n      await memStorage.storeKey('key2', testKey);\n      await memStorage.storeKey('key3', testKey);\n      \n      const keys = await memStorage.listKeys();\n      expect(keys).toContain('key1');\n      expect(keys).toContain('key2');\n      expect(keys).toContain('key3');\n      expect(keys).toHaveLength(3);\n    });\n\n    it('should store and retrieve key metadata', async () => {\n      const metadata: KeyMetadata = {\n        version: 1,\n        createdAt: Date.now(),\n        tags: ['signing', 'primary'],\n      };\n      \n      await memStorage.storeKey(testKeyId, testKey, metadata);\n      const retrieved = await memStorage.getKeyMetadata(testKeyId);\n      \n      expect(retrieved).toEqual(metadata);\n    });\n\n    it('should update metadata on access', async () => {\n      const metadata: KeyMetadata = {\n        version: 1,\n        createdAt: Date.now(),\n        accessCount: 0,\n      };\n      \n      await memStorage.storeKey(testKeyId, testKey, metadata);\n      await memStorage.getKey(testKeyId);\n      await memStorage.getKey(testKeyId);\n      \n      const updated = await memStorage.getKeyMetadata(testKeyId);\n      expect(updated?.accessCount).toBeGreaterThan(0);\n    });\n\n    it('should support key versioning', async () => {\n      const metadata1: KeyMetadata = {\n        version: 1,\n        createdAt: Date.now(),\n      };\n      \n      const metadata2: KeyMetadata = {\n        version: 2,\n        createdAt: Date.now(),\n      };\n      \n      await memStorage.storeKey('key-v1', testKey, metadata1);\n      await memStorage.storeKey('key-v2', new Uint8Array([9, 10, 11]), metadata2);\n      \n      const meta1 = await memStorage.getKeyMetadata('key-v1');\n      const meta2 = await memStorage.getKeyMetadata('key-v2');\n      \n      expect(meta1?.version).toBe(1);\n      expect(meta2?.version).toBe(2);\n    });\n\n    it('should support key tagging', async () => {\n      const metadata: KeyMetadata = {\n        version: 1,\n        createdAt: Date.now(),\n        tags: ['encryption', 'session', 'temporary'],\n      };\n      \n      await memStorage.storeKey(testKeyId, testKey, metadata);\n      const retrieved = await memStorage.getKeyMetadata(testKeyId);\n      \n      expect(retrieved?.tags).toContain('encryption');\n      expect(retrieved?.tags).toContain('session');\n      expect(retrieved?.tags).toContain('temporary');\n    });\n\n    it('should handle empty key list', async () => {\n      const keys = await memStorage.listKeys();\n      expect(keys).toEqual([]);\n    });\n\n    it('should overwrite existing keys', async () => {\n      const key1 = new Uint8Array([1, 2, 3]);\n      const key2 = new Uint8Array([4, 5, 6]);\n      \n      await memStorage.storeKey(testKeyId, key1);\n      await memStorage.storeKey(testKeyId, key2);\n      \n      const retrieved = await memStorage.getKey(testKeyId);\n      expect(retrieved).toEqual(key2);\n    });\n\n    it('should handle metadata for non-existent keys', async () => {\n      const metadata = await memStorage.getKeyMetadata('non-existent');\n      expect(metadata).toBeNull();\n    });\n\n    it('should delete non-existent keys without error', async () => {\n      await expect(memStorage.deleteKey('non-existent')).resolves.not.toThrow();\n    });\n  });\n\n  describe('Security Features', () => {\n    let memStorage: MemoryKeyStorage;\n\n    beforeEach(() => {\n      memStorage = new MemoryKeyStorage();\n    });\n\n    it('should wipe keys from memory on delete', async () => {\n      const sensitiveKey = new Uint8Array([1, 2, 3, 4, 5]);\n      await memStorage.storeKey(testKeyId, sensitiveKey);\n      \n      await memStorage.deleteKey(testKeyId);\n      \n      // Key should be completely removed\n      const retrieved = await memStorage.getKey(testKeyId);\n      expect(retrieved).toBeNull();\n    });\n\n    it('should track key access count', async () => {\n      const metadata: KeyMetadata = {\n        version: 1,\n        createdAt: Date.now(),\n        accessCount: 0,\n      };\n      \n      await memStorage.storeKey(testKeyId, testKey, metadata);\n      \n      // Access the key multiple times\n      await memStorage.getKey(testKeyId);\n      await memStorage.getKey(testKeyId);\n      await memStorage.getKey(testKeyId);\n      \n      const updated = await memStorage.getKeyMetadata(testKeyId);\n      expect(updated?.accessCount).toBeGreaterThanOrEqual(3);\n    });\n\n    it('should track last accessed time', async () => {\n      const beforeTime = Date.now();\n      \n      const metadata: KeyMetadata = {\n        version: 1,\n        createdAt: beforeTime,\n      };\n      \n      await memStorage.storeKey(testKeyId, testKey, metadata);\n      \n      // Wait a bit and access\n      await new Promise(resolve => setTimeout(resolve, 10));\n      await memStorage.getKey(testKeyId);\n      \n      const updated = await memStorage.getKeyMetadata(testKeyId);\n      expect(updated?.lastAccessedAt).toBeGreaterThanOrEqual(beforeTime);\n    });\n  });\n\n  describe('Edge Cases', () => {\n    let memStorage: MemoryKeyStorage;\n\n    beforeEach(() => {\n      memStorage = new MemoryKeyStorage();\n    });\n\n    it('should handle empty key data', async () => {\n      const emptyKey = new Uint8Array(0);\n      await memStorage.storeKey(testKeyId, emptyKey);\n      \n      const retrieved = await memStorage.getKey(testKeyId);\n      expect(retrieved).toEqual(emptyKey);\n    });\n\n    it('should handle large keys', async () => {\n      const largeKey = new Uint8Array(10000);\n      largeKey.fill(42);\n      \n      await memStorage.storeKey(testKeyId, largeKey);\n      const retrieved = await memStorage.getKey(testKeyId);\n      \n      expect(retrieved).toEqual(largeKey);\n    });\n\n    it('should handle special characters in key IDs', async () => {\n      const specialId = 'key-@#$%^&*()_+{}[]|\\\\:\";\\'<>?,./';\n      await memStorage.storeKey(specialId, testKey);\n      \n      const retrieved = await memStorage.getKey(specialId);\n      expect(retrieved).toEqual(testKey);\n    });\n\n    it('should handle many keys', async () => {\n      for (let i = 0; i < 100; i++) {\n        await memStorage.storeKey(`key-${i}`, new Uint8Array([i]));\n      }\n      \n      const keys = await memStorage.listKeys();\n      expect(keys).toHaveLength(100);\n    });\n\n    it('should handle metadata without optional fields', async () => {\n      const minimalMetadata: KeyMetadata = {\n        version: 1,\n        createdAt: Date.now(),\n      };\n      \n      await memStorage.storeKey(testKeyId, testKey, minimalMetadata);\n      const retrieved = await memStorage.getKeyMetadata(testKeyId);\n      \n      expect(retrieved?.version).toBe(1);\n      expect(retrieved?.createdAt).toBeDefined();\n    });\n  });\n\n  describe('Migration Support', () => {\n    it('should support key migration', async () => {\n      const memStorage = new MemoryKeyStorage();\n      \n      if (memStorage.migrateKeys) {\n        await expect(memStorage.migrateKeys(1, 2)).resolves.not.toThrow();\n      }\n    });\n  });\n});\n"],"version":3}