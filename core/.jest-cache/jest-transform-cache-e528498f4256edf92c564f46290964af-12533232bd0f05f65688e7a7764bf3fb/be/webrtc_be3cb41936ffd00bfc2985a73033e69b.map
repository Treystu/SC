{"file":"/Users/christymaxwell/Desktop/Luke_Stuff/GitHub/SC/core/src/transport/webrtc.ts","mappings":"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","names":[],"sources":["/Users/christymaxwell/Desktop/Luke_Stuff/GitHub/SC/core/src/transport/webrtc.ts"],"sourcesContent":["/**\n * WebRTC Transport Layer for Peer-to-Peer Communication\n */\n\nexport interface PeerConnectionConfig {\n  peerId: string;\n  iceServers?: RTCIceServer[];\n}\n\nexport type ConnectionState =\n  | \"new\"\n  | \"connecting\"\n  | \"connected\"\n  | \"disconnected\"\n  | \"failed\"\n  | \"closed\";\n\nexport interface DataChannelConfig {\n  label: string;\n  ordered: boolean;\n  maxRetransmits?: number;\n}\n\n/**\n * WebRTC Peer Connection Manager\n * Handles peer-to-peer connections using WebRTC data channels\n */\nexport class WebRTCPeer {\n  private peerConnection: RTCPeerConnection | null = null;\n  private dataChannels: Map<string, RTCDataChannel> = new Map();\n  private onMessageCallback?: (data: Uint8Array) => void;\n  private onStateChangeCallback?: (state: ConnectionState) => void;\n  private onSignalCallback?: (signal: unknown) => void;\n  private onTrackCallback?: (\n    track: MediaStreamTrack,\n    stream: MediaStream,\n  ) => void;\n  private peerId: string;\n\n  constructor(config: PeerConnectionConfig) {\n    this.peerId = config.peerId;\n    this.initializePeerConnection(config.iceServers);\n  }\n\n  /**\n   * Initialize RTCPeerConnection with configuration\n   */\n  private initializePeerConnection(iceServers?: RTCIceServer[]): void {\n    const configuration: RTCConfiguration = {\n      iceServers: iceServers || [\n        // Public STUN servers for NAT traversal (Stateless, essential for decentralized connectivity)\n        { urls: \"stun:stun.l.google.com:19302\" },\n        { urls: \"stun:stun1.l.google.com:19302\" },\n        { urls: \"stun:stun2.l.google.com:19302\" },\n        { urls: \"stun:stun3.l.google.com:19302\" },\n        { urls: \"stun:stun4.l.google.com:19302\" },\n        { urls: \"stun:global.stun.twilio.com:3478\" },\n      ],\n      iceCandidatePoolSize: 10,\n    };\n\n    this.peerConnection = new RTCPeerConnection(configuration);\n\n    // Connection state monitoring\n    this.peerConnection.onconnectionstatechange = () => {\n      const state = this.peerConnection?.connectionState as ConnectionState;\n      this.onStateChangeCallback?.(state);\n\n      // Automatic reconnection on failure\n      if (state === \"failed\") {\n        this.handleConnectionFailure();\n      }\n    };\n\n    // ICE candidate handling\n    this.peerConnection.onicecandidate = (event) => {\n      if (event.candidate) {\n        // ICE candidates will be sent via mesh signaling\n        this.handleIceCandidate(event.candidate);\n      }\n    };\n\n    // Data channel receiving\n    this.peerConnection.ondatachannel = (event) => {\n      this.setupDataChannel(event.channel);\n    };\n\n    // Track receiving (Audio/Video)\n    this.peerConnection.ontrack = (event) => {\n      if (event.streams && event.streams[0]) {\n        this.onTrackCallback?.(event.track, event.streams[0]);\n      }\n    };\n  }\n\n  /**\n   * Create a data channel with specific configuration\n   */\n  createDataChannel(config: DataChannelConfig): RTCDataChannel {\n    if (!this.peerConnection) {\n      throw new Error(\"Peer connection not initialized\");\n    }\n\n    const channelConfig: RTCDataChannelInit = {\n      ordered: config.ordered,\n      maxRetransmits: config.maxRetransmits,\n    };\n\n    const channel = this.peerConnection.createDataChannel(\n      config.label,\n      channelConfig,\n    );\n    this.setupDataChannel(channel);\n\n    return channel;\n  }\n\n  /**\n   * Set up data channel event handlers\n   */\n  private setupDataChannel(channel: RTCDataChannel): void {\n    this.dataChannels.set(channel.label, channel);\n\n    channel.onopen = () => {\n      console.log(`Data channel ${channel.label} opened`);\n    };\n\n    channel.onclose = () => {\n      console.log(`Data channel ${channel.label} closed`);\n      this.dataChannels.delete(channel.label);\n    };\n\n    channel.onerror = (error) => {\n      console.error(`Data channel ${channel.label} error:`, error);\n    };\n\n    channel.onmessage = (event) => {\n      if (event.data instanceof ArrayBuffer) {\n        this.onMessageCallback?.(new Uint8Array(event.data));\n      } else if (typeof event.data === \"string\") {\n        // Convert string to Uint8Array\n        const encoder = new TextEncoder();\n        this.onMessageCallback?.(encoder.encode(event.data));\n      }\n    };\n  }\n\n  /**\n   * Create and send SDP offer\n   */\n  async createOffer(): Promise<RTCSessionDescriptionInit> {\n    if (!this.peerConnection) {\n      throw new Error(\"Peer connection not initialized\");\n    }\n\n    const offer = await this.peerConnection.createOffer();\n    await this.peerConnection.setLocalDescription(offer);\n    return offer;\n  }\n\n  /**\n   * Create and send SDP answer\n   */\n  async createAnswer(\n    offer: RTCSessionDescriptionInit,\n  ): Promise<RTCSessionDescriptionInit> {\n    if (!this.peerConnection) {\n      throw new Error(\"Peer connection not initialized\");\n    }\n\n    await this.peerConnection.setRemoteDescription(offer);\n    const answer = await this.peerConnection.createAnswer();\n    await this.peerConnection.setLocalDescription(answer);\n    return answer;\n  }\n\n  /**\n   * Set remote SDP answer\n   */\n  async setRemoteAnswer(answer: RTCSessionDescriptionInit): Promise<void> {\n    if (!this.peerConnection) {\n      throw new Error(\"Peer connection not initialized\");\n    }\n\n    await this.peerConnection.setRemoteDescription(answer);\n  }\n\n  /**\n   * Add ICE candidate received from remote peer\n   */\n  async addIceCandidate(candidate: RTCIceCandidateInit): Promise<void> {\n    if (!this.peerConnection) {\n      throw new Error(\"Peer connection not initialized\");\n    }\n\n    await this.peerConnection.addIceCandidate(candidate);\n  }\n\n  /**\n   * Handle ICE candidate (to be sent via mesh signaling)\n   */\n  private handleIceCandidate(candidate: RTCIceCandidate): void {\n    if (this.onSignalCallback) {\n      this.onSignalCallback({\n        type: \"candidate\",\n        candidate: candidate.toJSON(),\n      });\n    } else {\n      console.log(\n        \"ICE candidate generated but no signal handler:\",\n        candidate.toJSON(),\n      );\n    }\n  }\n\n  /**\n   * Handle connection failure - attempt reconnection\n   */\n  private async handleConnectionFailure(): Promise<void> {\n    console.log(\"Connection failed, attempting reconnection...\");\n\n    // Close existing connection\n    this.close();\n\n    // Reinitialize and attempt to reconnect\n    // This would trigger new offer/answer exchange via mesh\n    this.initializePeerConnection();\n  }\n\n  /**\n   * Send message through data channel\n   */\n  send(data: Uint8Array, channelLabel: string = \"reliable\"): void {\n    const channel = this.dataChannels.get(channelLabel);\n\n    if (!channel || channel.readyState !== \"open\") {\n      throw new Error(`Data channel ${channelLabel} not ready`);\n    }\n\n    // Cast to any to avoid TS error: Argument of type 'Uint8Array' is not assignable to parameter of type 'ArrayBuffer'.\n    // The underlying implementation supports Uint8Array.\n    channel.send(data as any);\n  }\n\n  /**\n   * Register callback for incoming messages\n   */\n  onMessage(callback: (data: Uint8Array) => void): void {\n    this.onMessageCallback = callback;\n  }\n\n  /**\n   * Register callback for connection state changes\n   */\n  onStateChange(callback: (state: ConnectionState) => void): void {\n    this.onStateChangeCallback = callback;\n  }\n\n  /**\n   * Register callback for signaling messages (ICE candidates, etc.)\n   */\n  onSignal(callback: (signal: unknown) => void): void {\n    this.onSignalCallback = callback;\n  }\n\n  /**\n   * Register callback for incoming tracks\n   */\n  onTrack(\n    callback: (track: MediaStreamTrack, stream: MediaStream) => void,\n  ): void {\n    this.onTrackCallback = callback;\n  }\n\n  /**\n   * Add local track to connection\n   */\n  addTrack(track: MediaStreamTrack, stream: MediaStream): void {\n    if (!this.peerConnection) {\n      throw new Error(\"Peer connection not initialized\");\n    }\n    this.peerConnection.addTrack(track, stream);\n  }\n\n  /**\n   * Get current connection state\n   */\n  getState(): ConnectionState {\n    return (this.peerConnection?.connectionState || \"new\") as ConnectionState;\n  }\n\n  /**\n   * Get peer ID\n   */\n  getPeerId(): string {\n    return this.peerId;\n  }\n\n  /**\n   * Get connection statistics\n   */\n  async getStats(): Promise<RTCStatsReport | null> {\n    if (!this.peerConnection) {\n      return null;\n    }\n    return this.peerConnection.getStats();\n  }\n\n  /**\n   * Wait for ICE gathering to complete\n   */\n  async waitForIceGathering(timeoutMs: number = 2000): Promise<void> {\n    if (!this.peerConnection) {\n      throw new Error(\"Peer connection not initialized\");\n    }\n\n    if (this.peerConnection.iceGatheringState === \"complete\") {\n      return;\n    }\n\n    return new Promise<void>((resolve) => {\n      // eslint-disable-next-line prefer-const\n      let timeoutId: ReturnType<typeof setTimeout>;\n\n      const checkState = () => {\n        if (this.peerConnection?.iceGatheringState === \"complete\") {\n          clearTimeout(timeoutId);\n          this.peerConnection?.removeEventListener(\n            \"icegatheringstatechange\",\n            checkState,\n          );\n          resolve();\n        }\n      };\n\n      this.peerConnection?.addEventListener(\n        \"icegatheringstatechange\",\n        checkState,\n      );\n\n      timeoutId = setTimeout(() => {\n        this.peerConnection?.removeEventListener(\n          \"icegatheringstatechange\",\n          checkState,\n        );\n        resolve(); // Resolve anyway on timeout\n      }, timeoutMs);\n    });\n  }\n\n  /**\n   * Get local session description\n   */\n  async getLocalDescription(): Promise<RTCSessionDescription | null> {\n    return this.peerConnection?.localDescription || null;\n  }\n\n  /**\n   * Gracefully close connection\n   */\n  close(): void {\n    // Close all data channels\n    this.dataChannels.forEach((channel) => channel.close());\n    this.dataChannels.clear();\n\n    // Close peer connection\n    if (this.peerConnection) {\n      this.peerConnection.close();\n      this.peerConnection = null;\n    }\n  }\n}\n\n/**\n * WebRTC Peer Connection Pool\n * Manages multiple peer connections\n */\nexport class PeerConnectionPool {\n  private peers: Map<string, WebRTCPeer> = new Map();\n  private onMessageCallback?: (peerId: string, data: Uint8Array) => void;\n  private onSignalCallback?: (peerId: string, signal: unknown) => void;\n  private onTrackCallback?: (\n    peerId: string,\n    track: MediaStreamTrack,\n    stream: MediaStream,\n  ) => void;\n\n  /**\n   * Create or get peer connection\n   */\n  getOrCreatePeer(peerId: string, config?: PeerConnectionConfig): WebRTCPeer {\n    let peer = this.peers.get(peerId);\n\n    if (!peer) {\n      peer = new WebRTCPeer(config || { peerId });\n\n      // Set up message handler\n      peer.onMessage((data) => {\n        this.onMessageCallback?.(peerId, data);\n      });\n\n      // Set up state change handler\n      peer.onStateChange((state) => {\n        if (state === \"closed\" || state === \"failed\") {\n          this.peers.delete(peerId);\n        }\n      });\n\n      // Set up signal handler\n      peer.onSignal((signal) => {\n        this.onSignalCallback?.(peerId, signal);\n      });\n\n      // Set up track handler\n      peer.onTrack((track, stream) => {\n        this.onTrackCallback?.(peerId, track, stream);\n      });\n\n      this.peers.set(peerId, peer);\n    }\n\n    return peer;\n  }\n\n  /**\n   * Get existing peer connection\n   */\n  getPeer(peerId: string): WebRTCPeer | undefined {\n    return this.peers.get(peerId);\n  }\n\n  /**\n   * Remove peer connection\n   */\n  removePeer(peerId: string): void {\n    const peer = this.peers.get(peerId);\n    if (peer) {\n      peer.close();\n      this.peers.delete(peerId);\n    }\n  }\n\n  /**\n   * Get all connected peers\n   */\n  getConnectedPeers(): string[] {\n    return Array.from(this.peers.entries())\n      .filter(([_, peer]) => peer.getState() === \"connected\")\n      .map(([peerId]) => peerId);\n  }\n\n  /**\n   * Broadcast message to all connected peers\n   */\n  broadcast(data: Uint8Array, excludePeerId?: string): void {\n    this.peers.forEach((peer, peerId) => {\n      if (peerId !== excludePeerId && peer.getState() === \"connected\") {\n        try {\n          peer.send(data);\n        } catch (error) {\n          console.error(`Failed to send to peer ${peerId}:`, error);\n        }\n      }\n    });\n  }\n\n  /**\n   * Register callback for incoming messages from any peer\n   */\n  onMessage(callback: (peerId: string, data: Uint8Array) => void): void {\n    this.onMessageCallback = callback;\n  }\n\n  /**\n   * Register callback for signaling messages from any peer\n   */\n  onSignal(callback: (peerId: string, signal: unknown) => void): void {\n    this.onSignalCallback = callback;\n  }\n\n  /**\n   * Close all connections\n   */\n  closeAll(): void {\n    this.peers.forEach((peer) => peer.close());\n    this.peers.clear();\n  }\n\n  /**\n   * Get connection statistics\n   */\n  async getStats() {\n    const peerStats = await Promise.all(\n      Array.from(this.peers.entries()).map(async ([peerId, peer]) => {\n        const stats = await peer.getStats();\n        return {\n          peerId,\n          state: peer.getState(),\n          stats,\n        };\n      }),\n    );\n\n    return {\n      totalPeers: this.peers.size,\n      connectedPeers: this.getConnectedPeers().length,\n      peers: peerStats,\n    };\n  }\n  /**\n   * Register callback for incoming tracks (audio/video)\n   */\n  onTrack(\n    callback: (\n      peerId: string,\n      track: MediaStreamTrack,\n      stream: MediaStream,\n    ) => void,\n  ): void {\n    this.onTrackCallback = callback;\n\n    // Register for existing peers\n    this.peers.forEach((peer, peerId) => {\n      peer.onTrack((track, stream) => {\n        callback(peerId, track, stream);\n      });\n    });\n  }\n}\n"],"version":3}