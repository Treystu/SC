dcb2143d4cf496d5ee96efa667c00a04
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const relay_1 = require("./relay");
const routing_1 = require("./routing");
const message_1 = require("../protocol/message");
describe('Advanced Message Relay Features', () => {
    let relay;
    let routingTable;
    const localPeerId = 'local-peer';
    beforeEach(() => {
        routingTable = new routing_1.RoutingTable(localPeerId);
        relay = new relay_1.MessageRelay(localPeerId, routingTable, {
            maxStoredMessages: 10,
            storeTimeout: 5000,
            maxRetries: 3,
            retryBackoff: 1000,
            floodRateLimit: 10,
            selectiveFlooding: true,
        });
    });
    describe('Loop Detection', () => {
        it('should detect routing loops', async () => {
            const message = {
                header: {
                    version: 0x01,
                    type: message_1.MessageType.TEXT,
                    ttl: 5,
                    timestamp: Date.now(),
                    senderId: new Uint8Array(32),
                    signature: new Uint8Array(64),
                },
                payload: new TextEncoder().encode('test'),
            };
            const messageData = (0, message_1.encodeMessage)(message);
            // Process message from peer1
            await relay.processMessage(messageData, 'peer1');
            // Process same message from peer1 again would be caught by deduplication
            // The loop detection tracks the path through different peers
            const stats = relay.getStats();
            // First message should be received
            expect(stats.messagesReceived).toBe(1);
        });
    });
    describe('Flood Rate Limiting', () => {
        it('should limit flood rate per peer', async () => {
            const peer = (0, routing_1.createPeer)('peer1', new Uint8Array(32), 'webrtc');
            routingTable.addPeer(peer);
            let forwardCount = 0;
            relay.onForwardMessage(() => {
                forwardCount++;
            });
            // Try to flood with many messages quickly
            for (let i = 0; i < 20; i++) {
                const message = {
                    header: {
                        version: 0x01,
                        type: message_1.MessageType.TEXT,
                        ttl: 5,
                        timestamp: Date.now(),
                        senderId: new Uint8Array(32),
                        signature: new Uint8Array(64),
                    },
                    payload: new TextEncoder().encode(`message${i}`),
                };
                const messageData = (0, message_1.encodeMessage)(message);
                await relay.processMessage(messageData, 'peer1');
            }
            // Should have rate limited some messages
            expect(forwardCount).toBeLessThan(20);
        });
    });
    describe('Store-and-Forward', () => {
        it('should store messages for offline peers', async () => {
            const message = {
                header: {
                    version: 0x01,
                    type: message_1.MessageType.TEXT,
                    ttl: 5,
                    timestamp: Date.now(),
                    senderId: new Uint8Array(32),
                    signature: new Uint8Array(64),
                },
                payload: new TextEncoder().encode('test'),
            };
            await relay.storeMessage(message, 'offline-peer');
            const stats = relay.getStats();
            expect(stats.messagesStored).toBe(1);
            const storedStats = await relay.getStoredMessagesStats();
            expect(storedStats.total).toBe(1);
            expect(storedStats.byDestination['offline-peer']).toBe(1);
        });
        it('should retry stored messages when peer comes online', async () => {
            const message = {
                header: {
                    version: 0x01,
                    type: message_1.MessageType.TEXT,
                    ttl: 5,
                    timestamp: Date.now(),
                    senderId: new Uint8Array(32),
                    signature: new Uint8Array(64),
                },
                payload: new TextEncoder().encode('test'),
            };
            await relay.storeMessage(message, 'peer1');
            // Peer comes online
            const peer = (0, routing_1.createPeer)('peer1', new Uint8Array(32), 'webrtc');
            routingTable.addPeer(peer);
            const storedStatsBefore = await relay.getStoredMessagesStats();
            expect(storedStatsBefore.total).toBe(1);
            await relay.retryStoredMessages();
            // Message should still be stored until successfully sent
            const storedStatsAfter = await relay.getStoredMessagesStats();
            expect(storedStatsAfter).toBeDefined();
        });
        it('should limit stored messages and remove oldest', async () => {
            for (let i = 0; i < 15; i++) {
                const message = {
                    header: {
                        version: 0x01,
                        type: message_1.MessageType.TEXT,
                        ttl: 5,
                        timestamp: Date.now(),
                        senderId: new Uint8Array(32),
                        signature: new Uint8Array(64),
                    },
                    payload: new TextEncoder().encode(`message${i}`),
                };
                await relay.storeMessage(message, `peer${i}`);
            }
            const storedStats = await relay.getStoredMessagesStats();
            expect(storedStats.total).toBeLessThanOrEqual(10);
        });
    });
    describe('Selective Flooding', () => {
        it('should always forward control messages', async () => {
            const controlMessage = {
                header: {
                    version: 0x01,
                    type: message_1.MessageType.CONTROL_PING,
                    ttl: 5,
                    timestamp: Date.now(),
                    senderId: new Uint8Array(32),
                    signature: new Uint8Array(64),
                },
                payload: new Uint8Array(0),
            };
            relay.onMessageForSelf(() => {
                // Control messages are delivered to self
            });
            const messageData = (0, message_1.encodeMessage)(controlMessage);
            await relay.processMessage(messageData, 'peer1');
            const stats = relay.getStats();
            expect(stats.messagesReceived).toBe(1);
        });
    });
});
describe('Message Fragmentation Advanced Features', () => {
    describe('Optimal Fragment Size', () => {
        it('should calculate fragment size based on MTU', () => {
            const size = (0, relay_1.calculateFragmentSize)(1500, 100);
            expect(size).toBe(1400);
        });
        it('should respect minimum fragment size', () => {
            const size = (0, relay_1.calculateFragmentSize)(200, 100);
            expect(size).toBeGreaterThanOrEqual(512);
        });
        it('should respect maximum fragment size', () => {
            const size = (0, relay_1.calculateFragmentSize)(20000, 100);
            expect(size).toBeLessThanOrEqual(16384);
        });
    });
    describe('Fragmentation Overhead', () => {
        it('should calculate overhead correctly', () => {
            const messageSize = 100000;
            const fragmentSize = 16384;
            const overhead = (0, relay_1.calculateFragmentationOverhead)(messageSize, fragmentSize);
            const expectedFragments = Math.ceil(messageSize / fragmentSize);
            expect(overhead).toBe(expectedFragments * 50);
        });
    });
    describe('Fragment Timestamps', () => {
        it('should include timestamp in fragments', () => {
            const message = new Uint8Array(50000);
            const fragments = (0, relay_1.fragmentMessage)(message, 'msg1', 16384);
            expect(fragments.length).toBeGreaterThan(1);
            fragments.forEach(fragment => {
                expect(fragment.timestamp).toBeDefined();
                expect(fragment.timestamp).toBeGreaterThan(0);
            });
        });
    });
});
describe('Message Reassembly Advanced Features', () => {
    let reassembler;
    beforeEach(() => {
        reassembler = new relay_1.MessageReassembler();
    });
    describe('Duplicate Fragment Detection', () => {
        it('should detect duplicate fragments', () => {
            const fragment = {
                messageId: 'msg1',
                fragmentIndex: 0,
                totalFragments: 3,
                data: new Uint8Array(100),
                timestamp: Date.now(),
            };
            const result1 = reassembler.addFragment(fragment);
            const result2 = reassembler.addFragment(fragment);
            expect(result1).toBe(false); // Not complete
            expect(result2).toBe(false); // Duplicate
        });
    });
    describe('Out-of-Order Fragment Handling', () => {
        it('should handle fragments arriving out of order', (done) => {
            const data = new Uint8Array([1, 2, 3, 4, 5, 6]);
            const fragments = [
                {
                    messageId: 'msg1',
                    fragmentIndex: 2,
                    totalFragments: 3,
                    data: data.slice(4, 6),
                    timestamp: Date.now(),
                },
                {
                    messageId: 'msg1',
                    fragmentIndex: 0,
                    totalFragments: 3,
                    data: data.slice(0, 2),
                    timestamp: Date.now(),
                },
                {
                    messageId: 'msg1',
                    fragmentIndex: 1,
                    totalFragments: 3,
                    data: data.slice(2, 4),
                    timestamp: Date.now(),
                },
            ];
            reassembler.onComplete((messageId, message) => {
                expect(messageId).toBe('msg1');
                expect(message).toEqual(data);
                done();
            });
            fragments.forEach(fragment => {
                reassembler.addFragment(fragment);
            });
        });
    });
    describe('Memory Limits and Cleanup', () => {
        it('should track buffer usage', () => {
            const fragment = {
                messageId: 'msg1',
                fragmentIndex: 0,
                totalFragments: 3,
                data: new Uint8Array(1000),
                timestamp: Date.now(),
            };
            reassembler.addFragment(fragment);
            const stats = reassembler.getStats();
            expect(stats.bufferUsage).toBeGreaterThan(0);
            expect(stats.bufferLimit).toBeDefined();
        });
        it('should cleanup expired messages', () => {
            const fragment = {
                messageId: 'msg1',
                fragmentIndex: 0,
                totalFragments: 3,
                data: new Uint8Array(1000),
                timestamp: Date.now(),
            };
            reassembler.addFragment(fragment);
            const beforeStats = reassembler.getStats();
            expect(beforeStats.incompleteMessages).toBe(1);
            // Cleanup won't remove recent messages
            const removed = reassembler.cleanup(100000); // Cleanup anything older than 100 seconds
            // Should not have removed recent message
            const afterStats = reassembler.getStats();
            expect(afterStats.incompleteMessages).toBe(1);
            expect(removed).toBe(0);
        });
        it('should include buffer limits in stats', () => {
            const stats = reassembler.getStats();
            expect(stats.bufferUsage).toBeDefined();
            expect(stats.bufferLimit).toBe(100 * 1024 * 1024);
        });
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL2NocmlzdHltYXh3ZWxsL0Rlc2t0b3AvTHVrZV9TdHVmZi9HaXRIdWIvU0MvY29yZS9zcmMvbWVzaC9yZWxheS1hZHZhbmNlZC50ZXN0LnRzIiwibWFwcGluZ3MiOiI7O0FBQUEsbUNBQW1JO0FBRW5JLHVDQUFxRDtBQUVyRCxpREFBaUU7QUFFakUsUUFBUSxDQUFDLGlDQUFpQyxFQUFFLEdBQUcsRUFBRTtJQUMvQyxJQUFJLEtBQW1CLENBQUM7SUFDeEIsSUFBSSxZQUEwQixDQUFDO0lBQy9CLE1BQU0sV0FBVyxHQUFHLFlBQVksQ0FBQztJQUVqQyxVQUFVLENBQUMsR0FBRyxFQUFFO1FBQ2QsWUFBWSxHQUFHLElBQUksc0JBQVksQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUM3QyxLQUFLLEdBQUcsSUFBSSxvQkFBWSxDQUFDLFdBQVcsRUFBRSxZQUFZLEVBQUU7WUFDbEQsaUJBQWlCLEVBQUUsRUFBRTtZQUNyQixZQUFZLEVBQUUsSUFBSTtZQUNsQixVQUFVLEVBQUUsQ0FBQztZQUNiLFlBQVksRUFBRSxJQUFJO1lBQ2xCLGNBQWMsRUFBRSxFQUFFO1lBQ2xCLGlCQUFpQixFQUFFLElBQUk7U0FDeEIsQ0FBQyxDQUFDO0lBQ0wsQ0FBQyxDQUFDLENBQUM7SUFFSCxRQUFRLENBQUMsZ0JBQWdCLEVBQUUsR0FBRyxFQUFFO1FBQzlCLEVBQUUsQ0FBQyw2QkFBNkIsRUFBRSxLQUFLLElBQUksRUFBRTtZQUMzQyxNQUFNLE9BQU8sR0FBWTtnQkFDdkIsTUFBTSxFQUFFO29CQUNOLE9BQU8sRUFBRSxJQUFJO29CQUNiLElBQUksRUFBRSxxQkFBVyxDQUFDLElBQUk7b0JBQ3RCLEdBQUcsRUFBRSxDQUFDO29CQUNOLFNBQVMsRUFBRSxJQUFJLENBQUMsR0FBRyxFQUFFO29CQUNyQixRQUFRLEVBQUUsSUFBSSxVQUFVLENBQUMsRUFBRSxDQUFDO29CQUM1QixTQUFTLEVBQUUsSUFBSSxVQUFVLENBQUMsRUFBRSxDQUFDO2lCQUM5QjtnQkFDRCxPQUFPLEVBQUUsSUFBSSxXQUFXLEVB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Q0FBQyxDQUFDO0lBQ0wsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDLENBQUMsQ0FBQyIsIm5hbWVzIjpbXSwic291cmNlcyI6WyIvVXNlcnMvY2hyaXN0eW1heHdlbGwvRGVza3RvcC9MdWtlX1N0dWZmL0dpdEh1Yi9TQy9jb3JlL3NyYy9tZXNoL3JlbGF5LWFkdmFuY2VkLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTWVzc2FnZVJlbGF5LCBmcmFnbWVudE1lc3NhZ2UsIE1lc3NhZ2VSZWFzc2VtYmxlciwgY2FsY3VsYXRlRnJhZ21lbnRTaXplLCBjYWxjdWxhdGVGcmFnbWVudGF0aW9uT3ZlcmhlYWQgfSBmcm9tICcuL3JlbGF5JztcbmltcG9ydCB0eXBlIHsgUGVlciB9IGZyb20gJy4vcm91dGluZyc7XG5pbXBvcnQgeyBSb3V0aW5nVGFibGUsIGNyZWF0ZVBlZXIgfSBmcm9tICcuL3JvdXRpbmcnO1xuaW1wb3J0IHR5cGUgeyBNZXNzYWdlIH0gZnJvbSAnLi4vcHJvdG9jb2wvbWVzc2FnZSc7XG5pbXBvcnQgeyBNZXNzYWdlVHlwZSwgZW5jb2RlTWVzc2FnZSB9IGZyb20gJy4uL3Byb3RvY29sL21lc3NhZ2UnO1xuXG5kZXNjcmliZSgnQWR2YW5jZWQgTWVzc2FnZSBSZWxheSBGZWF0dXJlcycsICgpID0+IHtcbiAgbGV0IHJlbGF5OiBNZXNzYWdlUmVsYXk7XG4gIGxldCByb3V0aW5nVGFibGU6IFJvdXRpbmdUYWJsZTtcbiAgY29uc3QgbG9jYWxQZWVySWQgPSAnbG9jYWwtcGVlcic7XG5cbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgcm91dGluZ1RhYmxlID0gbmV3IFJvdXRpbmdUYWJsZShsb2NhbFBlZXJJZCk7XG4gICAgcmVsYXkgPSBuZXcgTWVzc2FnZVJlbGF5KGxvY2FsUGVlcklkLCByb3V0aW5nVGFibGUsIHtcbiAgICAgIG1heFN0b3JlZE1lc3NhZ2VzOiAxMCxcbiAgICAgIHN0b3JlVGltZW91dDogNTAwMCxcbiAgICAgIG1heFJldHJpZXM6IDMsXG4gICAgICByZXRyeUJhY2tvZmY6IDEwMDAsXG4gICAgICBmbG9vZFJhdGVMaW1pdDogMTAsXG4gICAgICBzZWxlY3RpdmVGbG9vZGluZzogdHJ1ZSxcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0xvb3AgRGV0ZWN0aW9uJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgZGV0ZWN0IHJvdXRpbmcgbG9vcHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtZXNzYWdlOiBNZXNzYWdlID0ge1xuICAgICAgICBoZWFkZXI6IHtcbiAgICAgICAgICB2ZXJzaW9uOiAweDAxLFxuICAgICAgICAgIHR5cGU6IE1lc3NhZ2VUeXBlLlRFWFQsXG4gICAgICAgICAgdHRsOiA1LFxuICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgICAgICBzZW5kZXJJZDogbmV3IFVpbnQ4QXJyYXkoMzIpLFxuICAgICAgICAgIHNpZ25hdHVyZTogbmV3IFVpbnQ4QXJyYXkoNjQpLFxuICAgICAgICB9LFxuICAgICAgICBwYXlsb2FkOiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoJ3Rlc3QnKSxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IG1lc3NhZ2VEYXRhID0gZW5jb2RlTWVzc2FnZShtZXNzYWdlKTtcblxuICAgICAgLy8gUHJvY2VzcyBtZXNzYWdlIGZyb20gcGVlcjFcbiAgICAgIGF3YWl0IHJlbGF5LnByb2Nlc3NNZXNzYWdlKG1lc3NhZ2VEYXRhLCAncGVlcjEnKTtcblxuICAgICAgLy8gUHJvY2VzcyBzYW1lIG1lc3NhZ2UgZnJvbSBwZWVyMSBhZ2FpbiB3b3VsZCBiZSBjYXVnaHQgYnkgZGVkdXBsaWNhdGlvblxuICAgICAgLy8gVGhlIGxvb3AgZGV0ZWN0aW9uIHRyYWNrcyB0aGUgcGF0aCB0aHJvdWdoIGRpZmZlcmVudCBwZWVyc1xuICAgICAgY29uc3Qgc3RhdHMgPSByZWxheS5nZXRTdGF0cygpO1xuXG4gICAgICAvLyBGaXJzdCBtZXNzYWdlIHNob3VsZCBiZSByZWNlaXZlZFxuICAgICAgZXhwZWN0KHN0YXRzLm1lc3NhZ2VzUmVjZWl2ZWQpLnRvQmUoMSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdGbG9vZCBSYXRlIExpbWl0aW5nJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgbGltaXQgZmxvb2QgcmF0ZSBwZXIgcGVlcicsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHBlZXIgPSBjcmVhdGVQZWVyKCdwZWVyMScsIG5ldyBVaW50OEFycmF5KDMyKSwgJ3dlYnJ0YycpO1xuICAgICAgcm91dGluZ1RhYmxlLmFkZFBlZXIocGVlcik7XG5cbiAgICAgIGxldCBmb3J3YXJkQ291bnQgPSAwO1xuICAgICAgcmVsYXkub25Gb3J3YXJkTWVzc2FnZSgoKSA9PiB7XG4gICAgICAgIGZvcndhcmRDb3VudCsrO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFRyeSB0byBmbG9vZCB3aXRoIG1hbnkgbWVzc2FnZXMgcXVpY2tseVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyMDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2U6IE1lc3NhZ2UgPSB7XG4gICAgICAgICAgaGVhZGVyOiB7XG4gICAgICAgICAgICB2ZXJzaW9uOiAweDAxLFxuICAgICAgICAgICAgdHlwZTogTWVzc2FnZVR5cGUuVEVYVCxcbiAgICAgICAgICAgIHR0bDogNSxcbiAgICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgICAgICAgIHNlbmRlcklkOiBuZXcgVWludDhBcnJheSgzMiksXG4gICAgICAgICAgICBzaWduYXR1cmU6IG5ldyBVaW50OEFycmF5KDY0KSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHBheWxvYWQ6IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShgbWVzc2FnZSR7aX1gKSxcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBtZXNzYWdlRGF0YSA9IGVuY29kZU1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgIGF3YWl0IHJlbGF5LnByb2Nlc3NNZXNzYWdlKG1lc3NhZ2VEYXRhLCAncGVlcjEnKTtcbiAgICAgIH1cblxuICAgICAgLy8gU2hvdWxkIGhhdmUgcmF0ZSBsaW1pdGVkIHNvbWUgbWVzc2FnZXNcbiAgICAgIGV4cGVjdChmb3J3YXJkQ291bnQpLnRvQmVMZXNzVGhhbigyMCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdTdG9yZS1hbmQtRm9yd2FyZCcsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHN0b3JlIG1lc3NhZ2VzIGZvciBvZmZsaW5lIHBlZXJzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbWVzc2FnZTogTWVzc2FnZSA9IHtcbiAgICAgICAgaGVhZGVyOiB7XG4gICAgICAgICAgdmVyc2lvbjogMHgwMSxcbiAgICAgICAgICB0eXBlOiBNZXNzYWdlVHlwZS5URVhULFxuICAgICAgICAgIHR0bDogNSxcbiAgICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICAgICAgc2VuZGVySWQ6IG5ldyBVaW50OEFycmF5KDMyKSxcbiAgICAgICAgICBzaWduYXR1cmU6IG5ldyBVaW50OEFycmF5KDY0KSxcbiAgICAgICAgfSxcbiAgICAgICAgcGF5bG9hZDogbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKCd0ZXN0JyksXG4gICAgICB9O1xuXG4gICAgICBhd2FpdCByZWxheS5zdG9yZU1lc3NhZ2UobWVzc2FnZSwgJ29mZmxpbmUtcGVlcicpO1xuXG4gICAgICBjb25zdCBzdGF0cyA9IHJlbGF5LmdldFN0YXRzKCk7XG4gICAgICBleHBlY3Qoc3RhdHMubWVzc2FnZXNTdG9yZWQpLnRvQmUoMSk7XG5cbiAgICAgIGNvbnN0IHN0b3JlZFN0YXRzID0gYXdhaXQgcmVsYXkuZ2V0U3RvcmVkTWVzc2FnZXNTdGF0cygpO1xuICAgICAgZXhwZWN0KHN0b3JlZFN0YXRzLnRvdGFsKS50b0JlKDEpO1xuICAgICAgZXhwZWN0KHN0b3JlZFN0YXRzLmJ5RGVzdGluYXRpb25bJ29mZmxpbmUtcGVlciddKS50b0JlKDEpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXRyeSBzdG9yZWQgbWVzc2FnZXMgd2hlbiBwZWVyIGNvbWVzIG9ubGluZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1lc3NhZ2U6IE1lc3NhZ2UgPSB7XG4gICAgICAgIGhlYWRlcjoge1xuICAgICAgICAgIHZlcnNpb246IDB4MDEsXG4gICAgICAgICAgdHlwZTogTWVzc2FnZVR5cGUuVEVYVCxcbiAgICAgICAgICB0dGw6IDUsXG4gICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgICAgIHNlbmRlcklkOiBuZXcgVWludDhBcnJheSgzMiksXG4gICAgICAgICAgc2lnbmF0dXJlOiBuZXcgVWludDhBcnJheSg2NCksXG4gICAgICAgIH0sXG4gICAgICAgIHBheWxvYWQ6IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSgndGVzdCcpLFxuICAgICAgfTtcblxuICAgICAgYXdhaXQgcmVsYXkuc3RvcmVNZXNzYWdlKG1lc3NhZ2UsICdwZWVyMScpO1xuXG4gICAgICAvLyBQZWVyIGNvbWVzIG9ubGluZVxuICAgICAgY29uc3QgcGVlciA9IGNyZWF0ZVBlZXIoJ3BlZXIxJywgbmV3IFVpbnQ4QXJyYXkoMzIpLCAnd2VicnRjJyk7XG4gICAgICByb3V0aW5nVGFibGUuYWRkUGVlcihwZWVyKTtcblxuICAgICAgY29uc3Qgc3RvcmVkU3RhdHNCZWZvcmUgPSBhd2FpdCByZWxheS5nZXRTdG9yZWRNZXNzYWdlc1N0YXRzKCk7XG4gICAgICBleHBlY3Qoc3RvcmVkU3RhdHNCZWZvcmUudG90YWwpLnRvQmUoMSk7XG5cbiAgICAgIGF3YWl0IHJlbGF5LnJldHJ5U3RvcmVkTWVzc2FnZXMoKTtcblxuICAgICAgLy8gTWVzc2FnZSBzaG91bGQgc3RpbGwgYmUgc3RvcmVkIHVudGlsIHN1Y2Nlc3NmdWxseSBzZW50XG4gICAgICBjb25zdCBzdG9yZWRTdGF0c0FmdGVyID0gYXdhaXQgcmVsYXkuZ2V0U3RvcmVkTWVzc2FnZXNTdGF0cygpO1xuICAgICAgZXhwZWN0KHN0b3JlZFN0YXRzQWZ0ZXIpLnRvQmVEZWZpbmVkKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGxpbWl0IHN0b3JlZCBtZXNzYWdlcyBhbmQgcmVtb3ZlIG9sZGVzdCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTU7IGkrKykge1xuICAgICAgICBjb25zdCBtZXNzYWdlOiBNZXNzYWdlID0ge1xuICAgICAgICAgIGhlYWRlcjoge1xuICAgICAgICAgICAgdmVyc2lvbjogMHgwMSxcbiAgICAgICAgICAgIHR5cGU6IE1lc3NhZ2VUeXBlLlRFWFQsXG4gICAgICAgICAgICB0dGw6IDUsXG4gICAgICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICAgICAgICBzZW5kZXJJZDogbmV3IFVpbnQ4QXJyYXkoMzIpLFxuICAgICAgICAgICAgc2lnbmF0dXJlOiBuZXcgVWludDhBcnJheSg2NCksXG4gICAgICAgICAgfSxcbiAgICAgICAgICBwYXlsb2FkOiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoYG1lc3NhZ2Uke2l9YCksXG4gICAgICAgIH07XG5cbiAgICAgICAgYXdhaXQgcmVsYXkuc3RvcmVNZXNzYWdlKG1lc3NhZ2UsIGBwZWVyJHtpfWApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBzdG9yZWRTdGF0cyA9IGF3YWl0IHJlbGF5LmdldFN0b3JlZE1lc3NhZ2VzU3RhdHMoKTtcbiAgICAgIGV4cGVjdChzdG9yZWRTdGF0cy50b3RhbCkudG9CZUxlc3NUaGFuT3JFcXVhbCgxMCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdTZWxlY3RpdmUgRmxvb2RpbmcnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBhbHdheXMgZm9yd2FyZCBjb250cm9sIG1lc3NhZ2VzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgY29udHJvbE1lc3NhZ2U6IE1lc3NhZ2UgPSB7XG4gICAgICAgIGhlYWRlcjoge1xuICAgICAgICAgIHZlcnNpb246IDB4MDEsXG4gICAgICAgICAgdHlwZTogTWVzc2FnZVR5cGUuQ09OVFJPTF9QSU5HLFxuICAgICAgICAgIHR0bDogNSxcbiAgICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICAgICAgc2VuZGVySWQ6IG5ldyBVaW50OEFycmF5KDMyKSxcbiAgICAgICAgICBzaWduYXR1cmU6IG5ldyBVaW50OEFycmF5KDY0KSxcbiAgICAgICAgfSxcbiAgICAgICAgcGF5bG9hZDogbmV3IFVpbnQ4QXJyYXkoMCksXG4gICAgICB9O1xuXG4gICAgICByZWxheS5vbk1lc3NhZ2VGb3JTZWxmKCgpID0+IHtcbiAgICAgICAgLy8gQ29udHJvbCBtZXNzYWdlcyBhcmUgZGVsaXZlcmVkIHRvIHNlbGZcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBtZXNzYWdlRGF0YSA9IGVuY29kZU1lc3NhZ2UoY29udHJvbE1lc3NhZ2UpO1xuICAgICAgYXdhaXQgcmVsYXkucHJvY2Vzc01lc3NhZ2UobWVzc2FnZURhdGEsICdwZWVyMScpO1xuXG4gICAgICBjb25zdCBzdGF0cyA9IHJlbGF5LmdldFN0YXRzKCk7XG4gICAgICBleHBlY3Qoc3RhdHMubWVzc2FnZXNSZWNlaXZlZCkudG9CZSgxKTtcbiAgICB9KTtcbiAgfSk7XG59KTtcblxuZGVzY3JpYmUoJ01lc3NhZ2UgRnJhZ21lbnRhdGlvbiBBZHZhbmNlZCBGZWF0dXJlcycsICgpID0+IHtcbiAgZGVzY3JpYmUoJ09wdGltYWwgRnJhZ21lbnQgU2l6ZScsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGNhbGN1bGF0ZSBmcmFnbWVudCBzaXplIGJhc2VkIG9uIE1UVScsICgpID0+IHtcbiAgICAgIGNvbnN0IHNpemUgPSBjYWxjdWxhdGVGcmFnbWVudFNpemUoMTUwMCwgMTAwKTtcbiAgICAgIGV4cGVjdChzaXplKS50b0JlKDE0MDApO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXNwZWN0IG1pbmltdW0gZnJhZ21lbnQgc2l6ZScsICgpID0+IHtcbiAgICAgIGNvbnN0IHNpemUgPSBjYWxjdWxhdGVGcmFnbWVudFNpemUoMjAwLCAxMDApO1xuICAgICAgZXhwZWN0KHNpemUpLnRvQmVHcmVhdGVyVGhhbk9yRXF1YWwoNTEyKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmVzcGVjdCBtYXhpbXVtIGZyYWdtZW50IHNpemUnLCAoKSA9PiB7XG4gICAgICBjb25zdCBzaXplID0gY2FsY3VsYXRlRnJhZ21lbnRTaXplKDIwMDAwLCAxMDApO1xuICAgICAgZXhwZWN0KHNpemUpLnRvQmVMZXNzVGhhbk9yRXF1YWwoMTYzODQpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnRnJhZ21lbnRhdGlvbiBPdmVyaGVhZCcsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGNhbGN1bGF0ZSBvdmVyaGVhZCBjb3JyZWN0bHknLCAoKSA9PiB7XG4gICAgICBjb25zdCBtZXNzYWdlU2l6ZSA9IDEwMDAwMDtcbiAgICAgIGNvbnN0IGZyYWdtZW50U2l6ZSA9IDE2Mzg0O1xuXG4gICAgICBjb25zdCBvdmVyaGVhZCA9IGNhbGN1bGF0ZUZyYWdtZW50YXRpb25PdmVyaGVhZChtZXNzYWdlU2l6ZSwgZnJhZ21lbnRTaXplKTtcbiAgICAgIGNvbnN0IGV4cGVjdGVkRnJhZ21lbnRzID0gTWF0aC5jZWlsKG1lc3NhZ2VTaXplIC8gZnJhZ21lbnRTaXplKTtcblxuICAgICAgZXhwZWN0KG92ZXJoZWFkKS50b0JlKGV4cGVjdGVkRnJhZ21lbnRzICogNTApO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnRnJhZ21lbnQgVGltZXN0YW1wcycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGluY2x1ZGUgdGltZXN0YW1wIGluIGZyYWdtZW50cycsICgpID0+IHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBuZXcgVWludDhBcnJheSg1MDAwMCk7XG4gICAgICBjb25zdCBmcmFnbWVudHMgPSBmcmFnbWVudE1lc3NhZ2UobWVzc2FnZSwgJ21zZzEnLCAxNjM4NCk7XG5cbiAgICAgIGV4cGVjdChmcmFnbWVudHMubGVuZ3RoKS50b0JlR3JlYXRlclRoYW4oMSk7XG4gICAgICBmcmFnbWVudHMuZm9yRWFjaChmcmFnbWVudCA9PiB7XG4gICAgICAgIGV4cGVjdChmcmFnbWVudC50aW1lc3RhbXApLnRvQmVEZWZpbmVkKCk7XG4gICAgICAgIGV4cGVjdChmcmFnbWVudC50aW1lc3RhbXApLnRvQmVHcmVhdGVyVGhhbigwKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbn0pO1xuXG5kZXNjcmliZSgnTWVzc2FnZSBSZWFzc2VtYmx5IEFkdmFuY2VkIEZlYXR1cmVzJywgKCkgPT4ge1xuICBsZXQgcmVhc3NlbWJsZXI6IE1lc3NhZ2VSZWFzc2VtYmxlcjtcblxuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICByZWFzc2VtYmxlciA9IG5ldyBNZXNzYWdlUmVhc3NlbWJsZXIoKTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0R1cGxpY2F0ZSBGcmFnbWVudCBEZXRlY3Rpb24nLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBkZXRlY3QgZHVwbGljYXRlIGZyYWdtZW50cycsICgpID0+IHtcbiAgICAgIGNvbnN0IGZyYWdtZW50ID0ge1xuICAgICAgICBtZXNzYWdlSWQ6ICdtc2cxJyxcbiAgICAgICAgZnJhZ21lbnRJbmRleDogMCxcbiAgICAgICAgdG90YWxGcmFnbWVudHM6IDMsXG4gICAgICAgIGRhdGE6IG5ldyBVaW50OEFycmF5KDEwMCksXG4gICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHJlc3VsdDEgPSByZWFzc2VtYmxlci5hZGRGcmFnbWVudChmcmFnbWVudCk7XG4gICAgICBjb25zdCByZXN1bHQyID0gcmVhc3NlbWJsZXIuYWRkRnJhZ21lbnQoZnJhZ21lbnQpO1xuXG4gICAgICBleHBlY3QocmVzdWx0MSkudG9CZShmYWxzZSk7IC8vIE5vdCBjb21wbGV0ZVxuICAgICAgZXhwZWN0KHJlc3VsdDIpLnRvQmUoZmFsc2UpOyAvLyBEdXBsaWNhdGVcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ091dC1vZi1PcmRlciBGcmFnbWVudCBIYW5kbGluZycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBmcmFnbWVudHMgYXJyaXZpbmcgb3V0IG9mIG9yZGVyJywgKGRvbmUpID0+IHtcbiAgICAgIGNvbnN0IGRhdGEgPSBuZXcgVWludDhBcnJheShbMSwgMiwgMywgNCwgNSwgNl0pO1xuICAgICAgY29uc3QgZnJhZ21lbnRzID0gW1xuICAgICAgICB7XG4gICAgICAgICAgbWVzc2FnZUlkOiAnbXNnMScsXG4gICAgICAgICAgZnJhZ21lbnRJbmRleDogMixcbiAgICAgICAgICB0b3RhbEZyYWdtZW50czogMyxcbiAgICAgICAgICBkYXRhOiBkYXRhLnNsaWNlKDQsIDYpLFxuICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG1lc3NhZ2VJZDogJ21zZzEnLFxuICAgICAgICAgIGZyYWdtZW50SW5kZXg6IDAsXG4gICAgICAgICAgdG90YWxGcmFnbWVudHM6IDMsXG4gICAgICAgICAgZGF0YTogZGF0YS5zbGljZSgwLCAyKSxcbiAgICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBtZXNzYWdlSWQ6ICdtc2cxJyxcbiAgICAgICAgICBmcmFnbWVudEluZGV4OiAxLFxuICAgICAgICAgIHRvdGFsRnJhZ21lbnRzOiAzLFxuICAgICAgICAgIGRhdGE6IGRhdGEuc2xpY2UoMiwgNCksXG4gICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgICB9LFxuICAgICAgXTtcblxuICAgICAgcmVhc3NlbWJsZXIub25Db21wbGV0ZSgobWVzc2FnZUlkLCBtZXNzYWdlKSA9PiB7XG4gICAgICAgIGV4cGVjdChtZXNzYWdlSWQpLnRvQmUoJ21zZzEnKTtcbiAgICAgICAgZXhwZWN0KG1lc3NhZ2UpLnRvRXF1YWwoZGF0YSk7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH0pO1xuXG4gICAgICBmcmFnbWVudHMuZm9yRWFjaChmcmFnbWVudCA9PiB7XG4gICAgICAgIHJlYXNzZW1ibGVyLmFkZEZyYWdtZW50KGZyYWdtZW50KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnTWVtb3J5IExpbWl0cyBhbmQgQ2xlYW51cCcsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHRyYWNrIGJ1ZmZlciB1c2FnZScsICgpID0+IHtcbiAgICAgIGNvbnN0IGZyYWdtZW50ID0ge1xuICAgICAgICBtZXNzYWdlSWQ6ICdtc2cxJyxcbiAgICAgICAgZnJhZ21lbnRJbmRleDogMCxcbiAgICAgICAgdG90YWxGcmFnbWVudHM6IDMsXG4gICAgICAgIGRhdGE6IG5ldyBVaW50OEFycmF5KDEwMDApLFxuICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICB9O1xuXG4gICAgICByZWFzc2VtYmxlci5hZGRGcmFnbWVudChmcmFnbWVudCk7XG5cbiAgICAgIGNvbnN0IHN0YXRzID0gcmVhc3NlbWJsZXIuZ2V0U3RhdHMoKTtcbiAgICAgIGV4cGVjdChzdGF0cy5idWZmZXJVc2FnZSkudG9CZUdyZWF0ZXJUaGFuKDApO1xuICAgICAgZXhwZWN0KHN0YXRzLmJ1ZmZlckxpbWl0KS50b0JlRGVmaW5lZCgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBjbGVhbnVwIGV4cGlyZWQgbWVzc2FnZXMnLCAoKSA9PiB7XG4gICAgICBjb25zdCBmcmFnbWVudCA9IHtcbiAgICAgICAgbWVzc2FnZUlkOiAnbXNnMScsXG4gICAgICAgIGZyYWdtZW50SW5kZXg6IDAsXG4gICAgICAgIHRvdGFsRnJhZ21lbnRzOiAzLFxuICAgICAgICBkYXRhOiBuZXcgVWludDhBcnJheSgxMDAwKSxcbiAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgfTtcblxuICAgICAgcmVhc3NlbWJsZXIuYWRkRnJhZ21lbnQoZnJhZ21lbnQpO1xuXG4gICAgICBjb25zdCBiZWZvcmVTdGF0cyA9IHJlYXNzZW1ibGVyLmdldFN0YXRzKCk7XG4gICAgICBleHBlY3QoYmVmb3JlU3RhdHMuaW5jb21wbGV0ZU1lc3NhZ2VzKS50b0JlKDEpO1xuXG4gICAgICAvLyBDbGVhbnVwIHdvbid0IHJlbW92ZSByZWNlbnQgbWVzc2FnZXNcbiAgICAgIGNvbnN0IHJlbW92ZWQgPSByZWFzc2VtYmxlci5jbGVhbnVwKDEwMDAwMCk7IC8vIENsZWFudXAgYW55dGhpbmcgb2xkZXIgdGhhbiAxMDAgc2Vjb25kc1xuXG4gICAgICAvLyBTaG91bGQgbm90IGhhdmUgcmVtb3ZlZCByZWNlbnQgbWVzc2FnZVxuICAgICAgY29uc3QgYWZ0ZXJTdGF0cyA9IHJlYXNzZW1ibGVyLmdldFN0YXRzKCk7XG4gICAgICBleHBlY3QoYWZ0ZXJTdGF0cy5pbmNvbXBsZXRlTWVzc2FnZXMpLnRvQmUoMSk7XG4gICAgICBleHBlY3QocmVtb3ZlZCkudG9CZSgwKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaW5jbHVkZSBidWZmZXIgbGltaXRzIGluIHN0YXRzJywgKCkgPT4ge1xuICAgICAgY29uc3Qgc3RhdHMgPSByZWFzc2VtYmxlci5nZXRTdGF0cygpO1xuXG4gICAgICBleHBlY3Qoc3RhdHMuYnVmZmVyVXNhZ2UpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3Qoc3RhdHMuYnVmZmVyTGltaXQpLnRvQmUoMTAwICogMTAyNCAqIDEwMjQpO1xuICAgIH0pO1xuICB9KTtcbn0pO1xuIl0sInZlcnNpb24iOjN9