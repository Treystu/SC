{"file":"/Users/christymaxwell/Desktop/Luke_Stuff/GitHub/SC/core/src/performance-optimizations.ts","mappings":"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","names":[],"sources":["/Users/christymaxwell/Desktop/Luke_Stuff/GitHub/SC/core/src/performance-optimizations.ts"],"sourcesContent":["/**\n * Performance Optimizations for Large-Scale Mesh Networks\n *\n * This module provides optimizations for scaling to 1M+ users:\n * - LRU Cache with O(1) operations\n * - Object pooling for Uint8Array buffers\n * - Message batching for high throughput\n * - Connection pooling optimizations\n * - Bloom filters for message deduplication\n */\n\n// ============================================================================\n// LRU Cache with O(1) Get/Set/Delete\n// ============================================================================\n\n/**\n * LRU (Least Recently Used) Cache with O(1) time complexity for all operations\n * Uses a doubly-linked list + Map for efficient access and eviction\n */\nexport class LRUCache<K, V> {\n  private cache: Map<K, LRUNode<K, V>> = new Map();\n  private head: LRUNode<K, V> | null = null;\n  private tail: LRUNode<K, V> | null = null;\n  private readonly maxSize: number;\n  private _hits = 0;\n  private _misses = 0;\n\n  constructor(maxSize: number) {\n    this.maxSize = maxSize;\n  }\n\n  /**\n   * Get value by key - O(1)\n   */\n  get(key: K): V | undefined {\n    const node = this.cache.get(key);\n\n    if (!node) {\n      this._misses++;\n      return undefined;\n    }\n\n    this._hits++;\n\n    // Move to head (most recently used)\n    this.moveToHead(node);\n\n    return node.value;\n  }\n\n  /**\n   * Set key-value pair - O(1)\n   */\n  set(key: K, value: V): void {\n    const existingNode = this.cache.get(key);\n\n    if (existingNode) {\n      // Update existing\n      existingNode.value = value;\n      this.moveToHead(existingNode);\n      return;\n    }\n\n    // Create new node\n    const newNode: LRUNode<K, V> = {\n      key,\n      value,\n      prev: null,\n      next: null,\n    };\n\n    // Evict if at capacity\n    if (this.cache.size >= this.maxSize) {\n      this.evictTail();\n    }\n\n    // Add to head\n    this.addToHead(newNode);\n    this.cache.set(key, newNode);\n  }\n\n  /**\n   * Check if key exists - O(1)\n   */\n  has(key: K): boolean {\n    return this.cache.has(key);\n  }\n\n  /**\n   * Delete key - O(1)\n   */\n  delete(key: K): boolean {\n    const node = this.cache.get(key);\n    if (!node) return false;\n\n    this.removeNode(node);\n    this.cache.delete(key);\n    return true;\n  }\n\n  /**\n   * Clear all entries\n   */\n  clear(): void {\n    this.cache.clear();\n    this.head = null;\n    this.tail = null;\n  }\n\n  /**\n   * Get current size\n   */\n  get size(): number {\n    return this.cache.size;\n  }\n\n  /**\n   * Get hit rate\n   */\n  get hitRate(): number {\n    const total = this._hits + this._misses;\n    return total === 0 ? 0 : this._hits / total;\n  }\n\n  /**\n   * Get stats\n   */\n  get stats(): { hits: number; misses: number; size: number; hitRate: number } {\n    return {\n      hits: this._hits,\n      misses: this._misses,\n      size: this.cache.size,\n      hitRate: this.hitRate,\n    };\n  }\n\n  private addToHead(node: LRUNode<K, V>): void {\n    node.next = this.head;\n    node.prev = null;\n\n    if (this.head) {\n      this.head.prev = node;\n    }\n\n    this.head = node;\n\n    if (!this.tail) {\n      this.tail = node;\n    }\n  }\n\n  private removeNode(node: LRUNode<K, V>): void {\n    if (node.prev) {\n      node.prev.next = node.next;\n    } else {\n      this.head = node.next;\n    }\n\n    if (node.next) {\n      node.next.prev = node.prev;\n    } else {\n      this.tail = node.prev;\n    }\n  }\n\n  private moveToHead(node: LRUNode<K, V>): void {\n    if (node === this.head) return;\n    this.removeNode(node);\n    this.addToHead(node);\n  }\n\n  private evictTail(): void {\n    if (!this.tail) return;\n    this.cache.delete(this.tail.key);\n    this.removeNode(this.tail);\n  }\n}\n\ninterface LRUNode<K, V> {\n  key: K;\n  value: V;\n  prev: LRUNode<K, V> | null;\n  next: LRUNode<K, V> | null;\n}\n\n// ============================================================================\n// Object Pool for Uint8Array Buffers\n// ============================================================================\n\n/**\n * Object pool for Uint8Array buffers to reduce GC pressure\n * Especially useful for crypto operations and message encoding\n */\nexport class BufferPool {\n  private pools: Map<number, Uint8Array[]> = new Map();\n  private readonly maxPoolSize: number;\n  private _acquired = 0;\n  private _released = 0;\n  private _created = 0;\n\n  constructor(maxPoolSize = 100) {\n    this.maxPoolSize = maxPoolSize;\n  }\n\n  /**\n   * Acquire a buffer of specified size\n   */\n  acquire(size: number): Uint8Array {\n    this._acquired++;\n\n    // Round up to common sizes to improve pooling\n    const normalizedSize = this.normalizeSize(size);\n    const pool = this.pools.get(normalizedSize);\n\n    if (pool && pool.length > 0) {\n      return pool.pop()!;\n    }\n\n    // No pooled buffer available, create new one\n    this._created++;\n    return new Uint8Array(normalizedSize);\n  }\n\n  /**\n   * Release a buffer back to the pool\n   */\n  release(buffer: Uint8Array): void {\n    this._released++;\n\n    const size = buffer.length;\n    let pool = this.pools.get(size);\n\n    if (!pool) {\n      pool = [];\n      this.pools.set(size, pool);\n    }\n\n    if (pool.length < this.maxPoolSize) {\n      // Clear the buffer before pooling (security)\n      // NOTE: For cryptographic material, use crypto/primitives.ts secure deletion\n      // This basic clearing is sufficient for general-purpose buffers\n      buffer.fill(0);\n      pool.push(buffer);\n    }\n    // Otherwise, let GC handle it\n  }\n\n  /**\n   * Acquire, use, and release in one operation.\n   * \n   * SECURITY NOTE: For cryptographic material, callers must ensure that\n   * sensitive data is not exposed via thrown errors. The buffer is cleared\n   * before being returned to the pool, but error messages may contain\n   * references to data that was in the buffer.\n   */\n  withBuffer<T>(size: number, fn: (buffer: Uint8Array) => T): T {\n    const buffer = this.acquire(size);\n    try {\n      return fn(buffer);\n    } finally {\n      this.release(buffer);\n    }\n  }\n\n  /**\n   * Get pool statistics\n   */\n  get stats(): {\n    acquired: number;\n    released: number;\n    created: number;\n    pooled: number;\n  } {\n    let pooled = 0;\n    for (const pool of this.pools.values()) {\n      pooled += pool.length;\n    }\n\n    return {\n      acquired: this._acquired,\n      released: this._released,\n      created: this._created,\n      pooled,\n    };\n  }\n\n  /**\n   * Clear all pooled buffers\n   */\n  clear(): void {\n    this.pools.clear();\n  }\n\n  /**\n   * Normalize size to common powers of 2 for better pooling\n   */\n  private normalizeSize(size: number): number {\n    // Common sizes for mesh network operations\n    const commonSizes = [64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536];\n    for (const s of commonSizes) {\n      if (size <= s) return s;\n    }\n    // For larger sizes, round up to nearest power of 2\n    return Math.pow(2, Math.ceil(Math.log2(size)));\n  }\n}\n\n// Global buffer pool instance\nexport const bufferPool = new BufferPool();\n\n// ============================================================================\n// Message Batcher for High Throughput\n// ============================================================================\n\nexport interface BatchConfig {\n  maxBatchSize?: number;\n  maxWaitMs?: number;\n  onBatch: (items: BatchItem[]) => void | Promise<void>;\n}\n\nexport interface BatchItem {\n  peerId: string;\n  data: Uint8Array;\n  priority?: number;\n}\n\n/**\n * Message batcher for efficient high-throughput message delivery\n * Reduces overhead by batching multiple messages to the same peer\n */\nexport class MessageBatcher {\n  private queues: Map<string, BatchItem[]> = new Map();\n  private timers: Map<string, ReturnType<typeof setTimeout>> = new Map();\n  private readonly maxBatchSize: number;\n  private readonly maxWaitMs: number;\n  private readonly onBatch: (items: BatchItem[]) => void | Promise<void>;\n  private _batchesSent = 0;\n  private _messagesBatched = 0;\n\n  constructor(config: BatchConfig) {\n    this.maxBatchSize = config.maxBatchSize || 10;\n    this.maxWaitMs = config.maxWaitMs || 50;\n    this.onBatch = config.onBatch;\n  }\n\n  /**\n   * Add an item to the batch queue\n   */\n  add(item: BatchItem): void {\n    this._messagesBatched++;\n\n    let queue = this.queues.get(item.peerId);\n    if (!queue) {\n      queue = [];\n      this.queues.set(item.peerId, queue);\n    }\n\n    queue.push(item);\n\n    // Flush if batch size reached\n    if (queue.length >= this.maxBatchSize) {\n      this.flush(item.peerId);\n      return;\n    }\n\n    // Set timer for delayed flush if not already set\n    if (!this.timers.has(item.peerId)) {\n      const timer = setTimeout(() => {\n        this.flush(item.peerId);\n      }, this.maxWaitMs);\n      this.timers.set(item.peerId, timer);\n    }\n  }\n\n  /**\n   * Flush batch for a specific peer\n   */\n  flush(peerId: string): void {\n    const queue = this.queues.get(peerId);\n    if (!queue || queue.length === 0) return;\n\n    // Clear timer\n    const timer = this.timers.get(peerId);\n    if (timer) {\n      clearTimeout(timer);\n      this.timers.delete(peerId);\n    }\n\n    // Get and clear queue\n    const items = queue.splice(0);\n    this._batchesSent++;\n\n    // Sort by priority (higher first)\n    items.sort((a, b) => (b.priority || 0) - (a.priority || 0));\n\n    // Send batch\n    this.onBatch(items);\n  }\n\n  /**\n   * Flush all pending batches\n   */\n  flushAll(): void {\n    for (const peerId of this.queues.keys()) {\n      this.flush(peerId);\n    }\n  }\n\n  /**\n   * Get statistics\n   */\n  get stats(): {\n    batchesSent: number;\n    messagesBatched: number;\n    avgBatchSize: number;\n  } {\n    return {\n      batchesSent: this._batchesSent,\n      messagesBatched: this._messagesBatched,\n      avgBatchSize:\n        this._batchesSent === 0 ? 0 : this._messagesBatched / this._batchesSent,\n    };\n  }\n\n  /**\n   * Cleanup and stop all timers\n   */\n  destroy(): void {\n    for (const timer of this.timers.values()) {\n      clearTimeout(timer);\n    }\n    this.timers.clear();\n    this.queues.clear();\n  }\n}\n\n// ============================================================================\n// Bloom Filter for Message Deduplication\n// ============================================================================\n\n/**\n * Space-efficient probabilistic data structure for message deduplication\n * False positive rate ~1% with 10 hash functions and 10 bits per element\n */\nexport class BloomFilter {\n  private bits: Uint32Array;\n  private readonly numBits: number;\n  private readonly numHashes: number;\n  private _count = 0;\n\n  /**\n   * Create bloom filter\n   * @param expectedElements Expected number of elements\n   * @param falsePositiveRate Desired false positive rate (default 0.01 = 1%)\n   */\n  constructor(expectedElements: number, falsePositiveRate = 0.01) {\n    // Calculate optimal number of bits: m = -n*ln(p)/(ln(2)^2)\n    this.numBits = Math.ceil(\n      (-expectedElements * Math.log(falsePositiveRate)) /\n        (Math.log(2) * Math.log(2))\n    );\n\n    // Calculate optimal number of hash functions: k = (m/n) * ln(2)\n    this.numHashes = Math.ceil(\n      (this.numBits / expectedElements) * Math.log(2)\n    );\n\n    // Initialize bit array (using Uint32Array for efficiency)\n    const numWords = Math.ceil(this.numBits / 32);\n    this.bits = new Uint32Array(numWords);\n  }\n\n  /**\n   * Add an element to the filter\n   */\n  add(element: string | Uint8Array): void {\n    const hashes = this.getHashes(element);\n    for (const hash of hashes) {\n      const index = hash % this.numBits;\n      const wordIndex = Math.floor(index / 32);\n      const bitIndex = index % 32;\n      this.bits[wordIndex] |= 1 << bitIndex;\n    }\n    this._count++;\n  }\n\n  /**\n   * Check if element might be in filter\n   * Returns true if element is possibly in set, false if definitely not\n   */\n  mightContain(element: string | Uint8Array): boolean {\n    const hashes = this.getHashes(element);\n    for (const hash of hashes) {\n      const index = hash % this.numBits;\n      const wordIndex = Math.floor(index / 32);\n      const bitIndex = index % 32;\n      if ((this.bits[wordIndex] & (1 << bitIndex)) === 0) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Get approximate number of elements\n   */\n  get count(): number {\n    return this._count;\n  }\n\n  /**\n   * Get fill ratio (percentage of bits set)\n   */\n  get fillRatio(): number {\n    let setBits = 0;\n    for (let i = 0; i < this.bits.length; i++) {\n      setBits += this.popCount(this.bits[i]);\n    }\n    return setBits / this.numBits;\n  }\n\n  /**\n   * Clear the filter\n   */\n  clear(): void {\n    this.bits.fill(0);\n    this._count = 0;\n  }\n\n  /**\n   * Generate multiple hashes for an element using double hashing\n   */\n  private getHashes(element: string | Uint8Array): number[] {\n    const data =\n      typeof element === 'string' ? new TextEncoder().encode(element) : element;\n\n    // Use two base hashes and derive others via double hashing\n    const hash1 = this.fnv1a(data);\n    const hash2 = this.murmur3(data);\n\n    const hashes: number[] = [];\n    for (let i = 0; i < this.numHashes; i++) {\n      // gi(x) = h1(x) + i * h2(x) mod m\n      hashes.push(Math.abs((hash1 + i * hash2) >>> 0));\n    }\n\n    return hashes;\n  }\n\n  /**\n   * FNV-1a hash function\n   */\n  private fnv1a(data: Uint8Array): number {\n    let hash = 2166136261;\n    for (let i = 0; i < data.length; i++) {\n      hash ^= data[i];\n      hash = Math.imul(hash, 16777619);\n    }\n    return hash >>> 0;\n  }\n\n  /**\n   * Simplified MurmurHash3\n   */\n  private murmur3(data: Uint8Array): number {\n    let hash = 0;\n    for (let i = 0; i < data.length; i++) {\n      hash ^= data[i];\n      hash = Math.imul(hash, 0x5bd1e995);\n      hash ^= hash >>> 15;\n    }\n    return hash >>> 0;\n  }\n\n  /**\n   * Count set bits in a 32-bit integer using SWAR (SIMD Within A Register)\n   * Algorithm: Brian Kernighan's population count with parallel bit counting\n   * Reference: https://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetParallel\n   */\n  private popCount(n: number): number {\n    n = n - ((n >>> 1) & 0x55555555);\n    n = (n & 0x33333333) + ((n >>> 2) & 0x33333333);\n    return (((n + (n >>> 4)) & 0x0f0f0f0f) * 0x01010101) >>> 24;\n  }\n}\n\n// ============================================================================\n// Connection Pool Manager\n// ============================================================================\n\nexport interface ConnectionPoolConfig {\n  maxConnections?: number;\n  idleTimeoutMs?: number;\n  cleanupIntervalMs?: number;\n}\n\nexport interface PooledConnection {\n  peerId: string;\n  lastActivity: number;\n  isActive: boolean;\n  close: () => void;\n}\n\n/**\n * Connection pool manager for efficient peer connection management\n */\nexport class ConnectionPool {\n  private connections: Map<string, PooledConnection> = new Map();\n  private readonly maxConnections: number;\n  private readonly idleTimeoutMs: number;\n  private cleanupTimer?: ReturnType<typeof setInterval>;\n\n  /**\n   * ConnectionPool manages peer connections with idle timeout eviction.\n   * \n   * IMPORTANT: Callers MUST call destroy() when done with the pool to prevent\n   * resource leaks. The cleanup timer runs indefinitely until destroy() is called.\n   * \n   * Alternative: Use lazy initialization by calling startCleanupTimer() manually\n   * after adding the first connection, and stopCleanupTimer() when the pool is empty.\n   */\n  constructor(config: ConnectionPoolConfig = {}) {\n    this.maxConnections = config.maxConnections || 100;\n    this.idleTimeoutMs = config.idleTimeoutMs || 300000; // 5 minutes\n\n    // Start cleanup timer\n    const cleanupInterval = config.cleanupIntervalMs || 60000;\n    this.cleanupTimer = setInterval(() => this.cleanup(), cleanupInterval);\n  }\n\n  /**\n   * Get or create a connection\n   */\n  getOrCreate(\n    peerId: string,\n    createFn: () => PooledConnection\n  ): PooledConnection {\n    let conn = this.connections.get(peerId);\n\n    if (conn) {\n      conn.lastActivity = Date.now();\n      return conn;\n    }\n\n    // Check pool size limit\n    if (this.connections.size >= this.maxConnections) {\n      this.evictIdleConnections();\n\n      // If still at capacity, evict oldest\n      if (this.connections.size >= this.maxConnections) {\n        this.evictOldest();\n      }\n    }\n\n    // Create new connection\n    conn = createFn();\n    conn.lastActivity = Date.now();\n    this.connections.set(peerId, conn);\n\n    return conn;\n  }\n\n  /**\n   * Update activity timestamp\n   */\n  touch(peerId: string): void {\n    const conn = this.connections.get(peerId);\n    if (conn) {\n      conn.lastActivity = Date.now();\n    }\n  }\n\n  /**\n   * Remove a connection\n   */\n  remove(peerId: string): void {\n    const conn = this.connections.get(peerId);\n    if (conn) {\n      conn.close();\n      this.connections.delete(peerId);\n    }\n  }\n\n  /**\n   * Get number of connections\n   */\n  get size(): number {\n    return this.connections.size;\n  }\n\n  /**\n   * Get all peer IDs\n   */\n  getPeerIds(): string[] {\n    return Array.from(this.connections.keys());\n  }\n\n  /**\n   * Cleanup idle connections\n   */\n  private cleanup(): void {\n    const now = Date.now();\n\n    for (const [peerId, conn] of this.connections.entries()) {\n      if (!conn.isActive && now - conn.lastActivity > this.idleTimeoutMs) {\n        conn.close();\n        this.connections.delete(peerId);\n      }\n    }\n  }\n\n  /**\n   * Evict idle connections to make room\n   */\n  private evictIdleConnections(): void {\n    const now = Date.now();\n    const halfTimeout = this.idleTimeoutMs / 2;\n\n    for (const [peerId, conn] of this.connections.entries()) {\n      if (!conn.isActive && now - conn.lastActivity > halfTimeout) {\n        conn.close();\n        this.connections.delete(peerId);\n      }\n    }\n  }\n\n  /**\n   * Evict oldest connection\n   */\n  private evictOldest(): void {\n    let oldest: [string, PooledConnection] | null = null;\n\n    for (const entry of this.connections.entries()) {\n      if (\n        !entry[1].isActive &&\n        (!oldest || entry[1].lastActivity < oldest[1].lastActivity)\n      ) {\n        oldest = entry;\n      }\n    }\n\n    if (oldest) {\n      oldest[1].close();\n      this.connections.delete(oldest[0]);\n    }\n  }\n\n  /**\n   * Destroy the pool\n   */\n  destroy(): void {\n    if (this.cleanupTimer) {\n      clearInterval(this.cleanupTimer);\n    }\n\n    for (const conn of this.connections.values()) {\n      conn.close();\n    }\n    this.connections.clear();\n  }\n}\n\n// ============================================================================\n// Performance Metrics Collector\n// ============================================================================\n\nexport interface PerformanceMetrics {\n  messagesPerSecond: number;\n  averageLatencyMs: number;\n  peakConnections: number;\n  cacheHitRate: number;\n  memoryUsageMB: number;\n}\n\n/**\n * Collect and report performance metrics\n */\nexport class MetricsCollector {\n  private messageCount = 0;\n  private totalLatency = 0;\n  private latencyCount = 0;\n  private peakConnections = 0;\n  private lastReportTime = Date.now();\n  private lastMessageCount = 0;\n\n  recordMessage(): void {\n    this.messageCount++;\n  }\n\n  recordLatency(latencyMs: number): void {\n    this.totalLatency += latencyMs;\n    this.latencyCount++;\n  }\n\n  recordConnections(count: number): void {\n    if (count > this.peakConnections) {\n      this.peakConnections = count;\n    }\n  }\n\n  getMetrics(cacheHitRate = 0): PerformanceMetrics {\n    const now = Date.now();\n    const elapsed = (now - this.lastReportTime) / 1000;\n    const messagesSinceLastReport = this.messageCount - this.lastMessageCount;\n\n    const metrics: PerformanceMetrics = {\n      messagesPerSecond: elapsed > 0 ? messagesSinceLastReport / elapsed : 0,\n      averageLatencyMs:\n        this.latencyCount > 0 ? this.totalLatency / this.latencyCount : 0,\n      peakConnections: this.peakConnections,\n      cacheHitRate,\n      memoryUsageMB: this.getMemoryUsage(),\n    };\n\n    this.lastReportTime = now;\n    this.lastMessageCount = this.messageCount;\n\n    return metrics;\n  }\n\n  reset(): void {\n    this.messageCount = 0;\n    this.totalLatency = 0;\n    this.latencyCount = 0;\n    this.peakConnections = 0;\n    this.lastReportTime = Date.now();\n    this.lastMessageCount = 0;\n  }\n\n  /**\n   * Returns memory usage in MB.\n   * - In Node.js, returns process heap usage.\n   * - In browsers, returns 0 (no reliable standard API for JS heap usage).\n   * @returns {number} Memory usage in MB, or 0 if unavailable.\n   */\n  private getMemoryUsage(): number {\n    // Node.js environment\n    if (typeof process !== 'undefined' && process.memoryUsage) {\n      return process.memoryUsage().heapUsed / (1024 * 1024);\n    }\n    // Browser: no reliable standard API for JS heap usage\n    return 0;\n  }\n}\n"],"version":3}