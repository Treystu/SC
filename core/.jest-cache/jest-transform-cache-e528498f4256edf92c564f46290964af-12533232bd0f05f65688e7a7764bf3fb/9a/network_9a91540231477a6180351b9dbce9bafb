5026ac6a2058b74797ff996e6b6ca040
"use strict";
/**
 * Mesh Network Manager
 * Orchestrates routing, relay, and transport connections
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MeshNetwork = void 0;
const encoding_js_1 = require("../utils/encoding.js");
const message_js_1 = require("../protocol/message.js");
const routing_js_1 = require("./routing.js");
const relay_js_1 = require("./relay.js");
const Transport_js_1 = require("./transport/Transport.js");
const WebRTCTransport_js_1 = require("../transport/WebRTCTransport.js");
const primitives_js_1 = require("../crypto/primitives.js");
const connection_quality_js_1 = require("../connection-quality.js");
const dht_js_1 = require("./dht.js");
const discovery_js_1 = require("./discovery.js");
const index_js_1 = require("./dht/index.js");
const http_bootstrap_js_1 = require("../discovery/http-bootstrap.js");
const rendezvous_js_1 = require("./rendezvous.js");
const blob_store_js_1 = require("../storage/blob-store.js");
const social_recovery_js_1 = require("../recovery/social-recovery.js");
const TransferManager_js_1 = require("../transfer/TransferManager.js");
const routing_js_2 = require("./routing.js");
/**
 * Mesh Network Manager
 * High-level API for mesh networking
 */
class MeshNetwork {
    constructor(config = {}) {
        this.HEALTH_CHECK_INTERVAL = 15000; // 15 seconds
        this.CONNECTION_TIMEOUT = 45000; // 45 seconds
        this.MAX_CONNECTION_ATTEMPTS = 3;
        this.connectionAttempts = new Map();
        this.lastConnectionAttempt = new Map();
        // Callbacks
        this.messageListeners = new Set();
        this.peerConnectedListeners = new Set();
        this.peerDisconnectedListeners = new Set();
        this.peerTrackListeners = new Set();
        this.discoveryUpdateListeners = new Set();
        // State
        this.discoveredPeers = new Set();
        this.peerMonitors = new Map();
        this.healthCheckInterval = null;
        this.pendingBlobRequests = new Map();
        // Message statistics
        this.messagesStored = 0;
        this.sessionPresenceInterval = null;
        // Metrics tracking
        this.messagesSent = 0;
        this.messagesReceived = 0;
        this.bytesTransferred = 0;
        /**
         * Set up message handlers for relay and peer pool
         */
        this.heartbeatInterval = null;
        /**
         * Monitor connection health and handle degradation
         */
        this.peerFailureCounts = new Map();
        // Initialize identity
        this.identity = config.identity || (0, primitives_js_1.generateIdentity)();
        // Unified Identity: Use provided ID or the full hex-encoded public key as peer ID
        // Peer IDs across the codebase are expected to be the hex-encoded public key.
        this.localPeerId =
            config.peerId || Buffer.from(this.identity.publicKey).toString("hex");
        // Initialize session for single-session enforcement
        this.sessionId = this.generateSessionId();
        this.sessionTimestamp = Date.now();
        // Configuration with production-ready defaults for 1M+ users
        this.defaultTTL = config.defaultTTL || 10;
        this.maxPeers = config.maxPeers || 100; // Increased for better scaling
        // Performance configuration
        const messageQueueSize = config.messageQueueSize ?? 10000;
        const _connectionTimeout = config.connectionTimeout ?? 30000;
        this.heartbeatMs = config.heartbeatInterval ?? 30000;
        this.healthCheckMs = config.healthCheckInterval ?? 5000;
        this.maxMessageSize = config.maxMessageSize ?? 1024 * 1024; // 1MB
        this.rateLimitPerPeer = config.rateLimitPerPeer ?? 100;
        const enableSelectiveFlooding = config.enableSelectiveFlooding !== false;
        const _enableMessageDeduplication = config.enableMessageDeduplication !== false;
        const _enableLoopDetection = config.enableLoopDetection !== false;
        this.maxRetries = config.maxRetries ?? 3;
        this.retryBackoff = config.retryBackoff ?? 5000;
        // Initialize components
        // Derive DHT node ID from public key (not from hex peer ID which is 64 chars)
        const dhtNodeId = (0, index_js_1.publicKeyToNodeId)(this.identity.publicKey);
        const dhtRoutingTable = new index_js_1.KademliaRoutingTable(dhtNodeId);
        this.routingTable = new routing_js_1.RoutingTable(this.localPeerId, {
            mode: routing_js_2.RoutingMode.HYBRID, // Default to Hybrid (DHT + Flood)
            dhtRoutingTable,
        });
        // Configure message relay for high-scale operations
        const relayConfig = {
            maxStoredMessages: messageQueueSize,
            storeTimeout: 300000, // 5 minutes
            maxRetries: this.maxRetries,
            retryBackoff: this.retryBackoff,
            floodRateLimit: this.rateLimitPerPeer,
            selectiveFlooding: enableSelectiveFlooding,
        };
        this.messageRelay = new relay_js_1.MessageRelay(this.localPeerId, this.routingTable, relayConfig, config.persistence);
        // Initialize Transports
        this.transportManager = new Transport_js_1.TransportManager();
        // Register WebRTC Transport
        this.webrtcTransport = new WebRTCTransport_js_1.WebRTCTransport(this.localPeerId);
        this.transportManager.registerTransport(this.webrtcTransport);
        // Register custom transports
        if (config.transports) {
            config.transports.forEach((transport) => {
                this.transportManager.registerTransport(transport);
            });
        }
        // Bind Transport Events
        this.transportManager.onMessage((peerId, data) => {
            this.handleIncomingTransportMessage(peerId, data);
        });
        this.transportManager.onPeerConnected((peerId) => {
            this.handlePeerConnected(peerId);
        });
        this.transportManager.onPeerDisconnected((peerId) => {
            this.handlePeerDisconnected(peerId);
        });
        this.webrtcTransport.getPool().onSignal((peerId, signal) => {
            if (this.signalingCallback) {
                this.signalingCallback(peerId, signal).catch((err) => console.error("[MeshNetwork] Failed to send signal via callback:", err));
            }
            else if (this.outboundTransportCallback) {
                this.outboundTransportCallback(peerId, new Uint8Array()).catch((err) => console.error("[MeshNetwork] Failed to send signal via outbound transport:", err));
            }
            else {
                console.debug("[MeshNetwork] No signaling callback registered, ICE candidate dropped for:", peerId);
            }
        });
        this.webrtcTransport.getPool().onTrack((peerId, track, stream) => {
            this.peerTrackListeners.forEach((listener) => {
                try {
                    listener(peerId, track, stream);
                }
                catch (e) {
                    console.error("Error in peer track listener:", e);
                }
            });
        });
        // Initialize DHT
        this.dht = new dht_js_1.DHT(this.routingTable, async (peerId, type, payload) => {
            const message = {
                header: {
                    version: 0x01,
                    type,
                    ttl: this.defaultTTL,
                    timestamp: Date.now(),
                    senderId: this.identity.publicKey,
                    signature: new Uint8Array(64),
                },
                payload,
            };
            const messageBytes = (0, message_js_1.encodeMessage)(message);
            message.header.signature = (0, primitives_js_1.signMessage)(messageBytes, this.identity.privateKey);
            const encodedMessage = (0, message_js_1.encodeMessage)(message);
            // Route via Transport Manager
            try {
                await this.transportManager.send(peerId, encodedMessage);
            }
            catch (e) {
                // If an outbound transport callback is registered (simulation / native), use it
                if (this.outboundTransportCallback) {
                    try {
                        await this.outboundTransportCallback(peerId, encodedMessage);
                    }
                    catch (err) {
                        console.warn(`[DHT] Failed to deliver message to ${peerId} via outboundTransportCallback.`, err);
                    }
                }
                else {
                    // Fallback to flood if needed, or handle error
                    console.warn(`[DHT] Failed to send message to ${peerId} via transports.`, e);
                }
            }
        }, { storage: config.dhtStorage });
        // Initialize Discovery Manager
        this.discovery = new discovery_js_1.DiscoveryManager();
        if (config.bootstrapUrl) {
            this.discovery.registerProvider(new http_bootstrap_js_1.HttpBootstrapProvider(config.bootstrapUrl));
        }
        this.discovery.onPeerDiscovered(this.handleDiscoveredPeer.bind(this));
        // Initialize Rendezvous Manager
        this.rendezvous = new rendezvous_js_1.RendezvousManager(this.localPeerId, this.dht, async (peerId, type, payload) => {
            const message = {
                header: {
                    version: 0x01,
                    type,
                    ttl: this.defaultTTL,
                    timestamp: Date.now(),
                    senderId: this.identity.publicKey,
                    signature: new Uint8Array(64),
                },
                payload,
            };
            const messageBytes = (0, message_js_1.encodeMessage)(message);
            message.header.signature = (0, primitives_js_1.signMessage)(messageBytes, this.identity.privateKey);
            const encodedMessage = (0, message_js_1.encodeMessage)(message);
            try {
                await this.transportManager.send(peerId, encodedMessage);
            }
            catch (e) {
                if (this.outboundTransportCallback) {
                    try {
                        await this.outboundTransportCallback(peerId, encodedMessage);
                    }
                    catch (err) {
                        console.warn(`[Rendezvous] Failed to deliver to ${peerId} via outboundTransportCallback.`, err);
                    }
                }
                else {
                    console.warn(`[Rendezvous] Failed to send to ${peerId}`, e);
                }
            }
        });
        // Initialize BlobStore with persistent storage for sneakernet relay
        // In browser environments, use IndexedDB; in Node/test, use memory-only
        let blobPersistence;
        if (typeof indexedDB !== 'undefined') {
            blobPersistence = new blob_store_js_1.IndexedDBBlobAdapter();
        }
        this.blobStore = new blob_store_js_1.BlobStore(blobPersistence);
        // Initialize blob store asynchronously (non-blocking)
        this.blobStore.init().catch(err => {
            console.error('[BlobStore] Failed to initialize persistent storage:', err);
            // Continue with memory-only mode if IndexedDB fails
        });
        // Initialize Social Recovery
        this.socialRecovery = new social_recovery_js_1.SocialRecoveryManager(this);
        // Initialize Transfer Manager
        this.transferManager = new TransferManager_js_1.TransferManager(this);
        this.setupMessageHandlers();
    }
    /**
     * Set up message handlers for relay and peer pool
     */
    setupMessageHandlers() {
        // Handle messages addressed to this peer
        this.messageRelay.onMessageForSelf((message) => {
            this.messagesReceived++;
            this.bytesTransferred += message.payload.byteLength;
            // Extract sender ID - use first 16 chars (8 bytes) in uppercase to match peer ID format
            const senderId = Array.from(message.header.senderId)
                .map((b) => b.toString(16).padStart(2, "0"))
                .join("")
                .substring(0, 16)
                .toUpperCase();
            // Handle Control Messages
            if (message.header.type === message_js_1.MessageType.CONTROL_PING) {
                this.sendPong(message.header.senderId, message.header.timestamp);
                return;
            }
            // Handle File Transfer Messages
            if (message.header.type === message_js_1.MessageType.FILE_METADATA ||
                message.header.type === message_js_1.MessageType.FILE_CHUNK) {
                this.transferManager.handleMessage(message.header.type, message.payload);
                return;
            }
            // Handle DHT Messages
            if (message.header.type === message_js_1.MessageType.DHT_FIND_NODE ||
                message.header.type === message_js_1.MessageType.DHT_FOUND_NODES ||
                message.header.type === message_js_1.MessageType.DHT_FIND_VALUE ||
                message.header.type === message_js_1.MessageType.DHT_STORE) {
                this.dht.handleMessage(message);
                return;
            }
            if (message.header.type === message_js_1.MessageType.RENDEZVOUS_ANNOUNCE ||
                message.header.type === message_js_1.MessageType.RENDEZVOUS_QUERY ||
                message.header.type === message_js_1.MessageType.RENDEZVOUS_RESPONSE) {
                this.rendezvous.handleMessage(message);
                return;
            }
            // Handle Blob Messages
            if (message.header.type === message_js_1.MessageType.REQUEST_BLOB ||
                message.header.type === message_js_1.MessageType.RESPONSE_BLOB) {
                this.handleBlobMessage(message);
                return;
            }
            if (message.header.type === message_js_1.MessageType.CONTROL_PONG) {
                // Calculate RTT
                // Payload contains the original timestamp (8 bytes / 64-bit float stored as string or bytes)
                // For simplicity, let's assume payload is JSON string of timestamp
                try {
                    const payloadStr = new TextDecoder().decode(message.payload);
                    const data = JSON.parse(payloadStr);
                    if (data.pingTimestamp) {
                        const rtt = Date.now() - data.pingTimestamp;
                        const monitor = this.peerMonitors.get(senderId);
                        if (monitor) {
                            monitor.updateLatency(rtt);
                            // Update peer last seen timestamp
                            this.routingTable.updatePeerLastSeen(senderId);
                        }
                    }
                }
                catch (e) {
                    // Ignore malformed PONG
                }
                return;
            }
            // Handle Session Presence (Single-Session Enforcement)
            if (message.header.type === message_js_1.MessageType.SESSION_PRESENCE) {
                this.handleSessionPresence(senderId, message.payload);
                return;
            }
            // Notify all listeners
            this.messageListeners.forEach((listener) => {
                try {
                    listener(message);
                }
                catch (error) {
                    console.error("Error in message listener:", error);
                }
            });
        });
        // Handle message forwarding (Smart Routing)
        this.messageRelay.onForwardMessage((message, excludePeerId) => {
            const encodedMessage = (0, message_js_1.encodeMessage)(message);
            this.messagesSent++;
            this.bytesTransferred += encodedMessage.byteLength;
            // "Smart Flood" / Tiered Routing Logic
            let targetId;
            try {
                const payloadStr = new TextDecoder().decode(message.payload);
                const data = JSON.parse(payloadStr);
                targetId = data.recipient;
            }
            catch (e) {
                // Not a JSON payload or parsing failed -> Broadcast
            }
            if (targetId) {
                const candidates = this.routingTable.getRankedPeersForTarget(targetId);
                // Filter: Exclude sender and self
                const validCandidates = candidates.filter((p) => p.id !== excludePeerId &&
                    p.id !== this.localPeerId &&
                    p.state === "connected");
                // Adaptive Selection Logic
                const totalCandidates = validCandidates.length;
                const FLOOD_THRESHOLD = 5; // "Few" threshold
                let countToSelect;
                if (totalCandidates <= FLOOD_THRESHOLD) {
                    countToSelect = totalCandidates;
                }
                else {
                    countToSelect = Math.max(FLOOD_THRESHOLD, Math.ceil(totalCandidates * 0.1));
                }
                const selectedPeers = validCandidates.slice(0, countToSelect);
                if (selectedPeers.length === 0) {
                    console.warn(`[MeshNetwork] No valid peers for forwarding to ${targetId}. Dropping.`);
                }
                selectedPeers.forEach((peer) => {
                    this.transportManager.send(peer.id, encodedMessage).catch((err) => {
                        console.error(`Failed to forward to ${peer.id}`, err);
                    });
                });
            }
            else {
                // Fallback to Full Flood via TransportManager (needs broadcast capability or manual loop)
                // TransportManager send is point-to-point.
                // We must iterate manual peers.
                this.routingTable.getAllPeers().forEach((peer) => {
                    if (peer.id !== excludePeerId &&
                        peer.id !== this.localPeerId &&
                        peer.state === routing_js_1.PeerState.CONNECTED) {
                        this.transportManager
                            .send(peer.id, encodedMessage)
                            .catch(() => { });
                    }
                });
            }
        });
    }
    // Handle incoming from Transport
    handleIncomingTransportMessage(peerId, data) {
        this.messageRelay.processMessage(data, peerId);
        // Update packet loss metrics (simplified)
        const monitor = this.peerMonitors.get(peerId);
        if (monitor) {
            monitor.updateBandwidth(data.length, 1000);
        }
    }
    /**
     * Start sending heartbeat (PING) messages
     */
    startHeartbeat(intervalMs = 30000) {
        if (this.heartbeatInterval)
            clearInterval(this.heartbeatInterval);
        const hbMs = intervalMs ?? this.heartbeatMs;
        this.heartbeatInterval = setInterval(() => {
            this.broadcastPing();
        }, hbMs);
        try {
            if (this.heartbeatInterval &&
                typeof this.heartbeatInterval.unref === "function") {
                this.heartbeatInterval.unref();
            }
        }
        catch (e) {
            /* no-op */
        }
        // Also start health check loop
        if (this.healthCheckInterval)
            clearInterval(this.healthCheckInterval);
        this.healthCheckInterval = setInterval(() => {
            this.monitorConnectionHealth();
        }, this.healthCheckMs); // Configurable check interval
        try {
            if (this.healthCheckInterval &&
                typeof this.healthCheckInterval.unref === "function") {
                this.healthCheckInterval.unref();
            }
        }
        catch (e) {
            /* no-op */
        }
    }
    /**
     * Stop sending heartbeat messages
     */
    stopHeartbeat() {
        // Stop internals
        this.transportManager.stop().catch(console.error);
        if (this.heartbeatInterval) {
            clearInterval(this.heartbeatInterval);
            this.heartbeatInterval = null;
        }
        if (this.healthCheckInterval) {
            clearInterval(this.healthCheckInterval);
            this.healthCheckInterval = null;
        }
    }
    async broadcastPing() {
        try {
            // Validate identity keys before signing
            if (!this.identity?.privateKey || this.identity.privateKey.length !== 32) {
                console.warn('[MeshNetwork] broadcastPing skipped: invalid private key');
                return;
            }
            if (!this.identity?.publicKey || this.identity.publicKey.length !== 32) {
                console.warn('[MeshNetwork] broadcastPing skipped: invalid public key');
                return;
            }
            const message = {
                header: {
                    version: 0x01,
                    type: message_js_1.MessageType.CONTROL_PING,
                    ttl: 1,
                    timestamp: Date.now(),
                    senderId: this.identity.publicKey,
                    signature: new Uint8Array(64),
                },
                payload: new Uint8Array(0),
            };
            const messageBytes = (0, message_js_1.encodeMessage)(message);
            message.header.signature = (0, primitives_js_1.signMessage)(messageBytes, this.identity.privateKey);
            const encodedMessage = (0, message_js_1.encodeMessage)(message);
            this.routingTable.getAllPeers().forEach((peer) => {
                if (peer.state === routing_js_1.PeerState.CONNECTED ||
                    peer.state === routing_js_1.PeerState.DEGRADED) {
                    this.transportManager.send(peer.id, encodedMessage).catch(() => { });
                }
            });
        }
        catch (error) {
            console.error('[MeshNetwork] broadcastPing failed:', error);
        }
    }
    async sendPong(recipientPublicKey, pingTimestamp) {
        const recipientId = Array.from(recipientPublicKey)
            .map((b) => b.toString(16).padStart(2, "0"))
            .join("");
        // Echo back the ping timestamp
        const payload = new TextEncoder().encode(JSON.stringify({ pingTimestamp }));
        const message = {
            header: {
                version: 0x01,
                type: message_js_1.MessageType.CONTROL_PONG,
                ttl: 1,
                timestamp: Date.now(),
                senderId: this.identity.publicKey,
                signature: new Uint8Array(64),
            },
            payload: payload,
        };
        const messageBytes = (0, message_js_1.encodeMessage)(message);
        message.header.signature = (0, primitives_js_1.signMessage)(messageBytes, this.identity.privateKey);
        const encodedMessage = (0, message_js_1.encodeMessage)(message);
        this.transportManager.send(recipientId, encodedMessage).catch(() => { });
    }
    monitorConnectionHealth() {
        this.peerMonitors.forEach((monitor, peerId) => {
            let quality = monitor.getQuality();
            const peer = this.routingTable.getPeer(peerId);
            if (!peer) {
                this.peerMonitors.delete(peerId);
                this.peerFailureCounts.delete(peerId);
                return;
            }
            // Check lastSeen as a fallback for silence detection
            const lastSeenAge = Date.now() - peer.lastSeen;
            if (lastSeenAge > 30000) {
                // 30 seconds silence
                quality = "offline";
            }
            else if (lastSeenAge > 10000 && quality !== "offline") {
                // 10 seconds silence
                quality = "poor";
            }
            // Update peer state based on quality
            if (quality === "poor" && peer.state === routing_js_1.PeerState.CONNECTED) {
                peer.state = routing_js_1.PeerState.DEGRADED;
            }
            else if ((quality === "good" || quality === "excellent") &&
                peer.state === routing_js_1.PeerState.DEGRADED) {
                peer.state = routing_js_1.PeerState.CONNECTED;
                this.peerFailureCounts.set(peerId, 0);
            }
            else if (quality === "offline") {
                // Track consecutive offline checks
                const failures = (this.peerFailureCounts.get(peerId) || 0) + 1;
                this.peerFailureCounts.set(peerId, failures);
                if (failures >= 6) {
                    // ~30 seconds of consecutive offline checks
                    this.disconnectFromPeer(peerId).catch((err) => console.error(`Error disconnecting peer ${peerId}:`, err));
                    this.peerFailureCounts.delete(peerId);
                }
            }
            else {
                // Reset failure count if healthy
                this.peerFailureCounts.set(peerId, 0);
            }
        });
    }
    /**
     * Connect to a peer via available transports
     */
    async connectToPeer(peerId) {
        console.log(`[MeshNetwork] connectToPeer called for ${peerId}`);
        if (this.routingTable.getAllPeers().length >= this.maxPeers) {
            console.warn(`[MeshNetwork] Max peers reached (${this.maxPeers}), cannot connect to ${peerId}`);
            throw new Error("Maximum number of peers reached");
        }
        // Check if already connected
        const existingPeer = this.routingTable.getPeer(peerId);
        if (existingPeer && existingPeer.state === "connected") {
            console.log(`[MeshNetwork] Already connected to ${peerId}, skipping`);
            return;
        }
        const webrtcTransport = this.transportManager.getTransport("webrtc");
        if (webrtcTransport) {
            const state = webrtcTransport.getConnectionState(peerId);
            if (state === "connecting" || state === "connected") {
                console.log(`[MeshNetwork] Connection to ${peerId} is already in state: ${state}, skipping`);
                return;
            }
        }
        console.log(`[MeshNetwork] Initiating connection to ${peerId} via WebRTC...`);
        // Use TransportManager to connect
        // Currently defaults to WebRTC as it's the only registered transport
        // but in future will try multiple
        return this.transportManager
            .connect(peerId, "webrtc")
            .then(() => {
            console.log(`[MeshNetwork] Connection initiated to ${peerId}, waiting for signaling...`);
        })
            .catch((err) => {
            console.error(`[MeshNetwork] Failed to connect to ${peerId}:`, err);
            throw err;
        });
    }
    /**
     * Handle peer connected
     */
    handlePeerConnected(peerId) {
        // Get transport type - if it's not one of the known types, default to "webrtc"
        const transportName = this.webrtcTransport.name;
        const validTransportTypes = ["webrtc", "bluetooth", "local"];
        const transportType = validTransportTypes.includes(transportName)
            ? transportName
            : "webrtc"; // Safe default fallback
        const peer = (0, routing_js_1.createPeer)(peerId, new Uint8Array(32), // Would be obtained during handshake
        transportType);
        this.routingTable.addPeer(peer);
        this.peerMonitors.set(peerId, new connection_quality_js_1.ConnectionMonitor()); // Start monitoring
        this.peerConnectedListeners.forEach((listener) => {
            try {
                listener(peerId);
            }
            catch (e) {
                console.error("Error in peer connected listener:", e);
            }
        });
        // Send peer announcement
        this.sendPeerAnnouncement();
    }
    /**
     * Handle peer disconnected
     */
    handlePeerDisconnected(peerId) {
        this.routingTable.removePeer(peerId);
        this.peerMonitors.delete(peerId); // Stop monitoring
        this.peerDisconnectedListeners.forEach((listener) => {
            try {
                listener(peerId);
            }
            catch (e) {
                console.error("Error in peer disconnected listener:", e);
            }
        });
    }
    /**
     * Send a text message with enhanced validation and rate limiting
     */
    async sendMessage(recipientId, content, type = message_js_1.MessageType.TEXT) {
        // Normalize recipient ID to uppercase for consistent matching
        const normalizedRecipientId = recipientId.replace(/\s/g, "").toUpperCase();
        console.log(`[MeshNetwork] sendMessage to ${normalizedRecipientId}, type=${message_js_1.MessageType[type]}`);
        // Validate message size for scaling
        const contentSize = new TextEncoder().encode(content).length;
        if (contentSize > this.maxMessageSize) {
            throw new Error(`Message size ${contentSize} exceeds maximum ${this.maxMessageSize} bytes`);
        }
        const payload = new TextEncoder().encode(JSON.stringify({
            text: content,
            timestamp: Date.now(),
            recipient: normalizedRecipientId,
        }));
        const message = {
            header: {
                version: 0x01,
                type: type,
                ttl: this.defaultTTL,
                timestamp: Date.now(),
                senderId: this.identity.publicKey,
                signature: new Uint8Array(64), // Placeholder
            },
            payload,
        };
        // Sign the message
        const messageBytes = (0, message_js_1.encodeMessage)(message);
        message.header.signature = (0, primitives_js_1.signMessage)(messageBytes, this.identity.privateKey);
        // Send via mesh
        const encodedMessage = (0, message_js_1.encodeMessage)(message);
        const nextHop = this.routingTable.getNextHop(normalizedRecipientId);
        console.log(`[MeshNetwork] Route lookup for ${normalizedRecipientId}: nextHop=${nextHop || "none"}, connectedPeers=${this.routingTable.getAllPeers().filter((p) => p.state === "connected").length}`);
        if (nextHop) {
            // Direct route available
            console.log(`[MeshNetwork] Sending directly to nextHop=${nextHop}`);
            this.transportManager.send(nextHop, encodedMessage).catch((err) => {
                console.error(`[MeshNetwork] Failed to send to next hop ${nextHop}:`, err);
            });
        }
        else {
            // Check if we have any connected peers at all
            const connectedPeers = this.routingTable
                .getAllPeers()
                .filter((p) => p.state === "connected" && p.id !== this.localPeerId);
            console.log(`[MeshNetwork] No direct route. Connected peers: ${connectedPeers.length}`);
            if (connectedPeers.length === 0) {
                console.warn(`[MeshNetwork] No connected peers! Using sneakernet storage for ${recipientId}.`);
                // SNEAKERNET: Store message for later delivery via any available peer
                try {
                    await this.messageRelay.storeMessage(message, normalizedRecipientId);
                    console.log(`[MeshNetwork] ðŸ“¦ Message stored for sneakernet delivery to ${recipientId}`);
                    this.messagesStored++;
                }
                catch (error) {
                    console.error(`[MeshNetwork] Failed to store message for ${recipientId}:`, error);
                    throw new Error(`No connected peers and failed to store message: ${error}`);
                }
                return;
            }
            // Attempt DHT lookup if no candidates found
            const candidates = this.routingTable.getRankedPeersForTarget(recipientId);
            const connectedCandidates = candidates.filter((p) => p.state === "connected" && p.id !== this.localPeerId);
            if (connectedCandidates.length === 0 && this.dht) {
                console.log(`[MeshNetwork] No known path to ${recipientId}, attempting DHT lookup...`);
                try {
                    const foundPeers = await this.dht.findNode(recipientId);
                    const targetPeer = foundPeers.find((p) => p.id === recipientId);
                    if (targetPeer) {
                        console.log(`[MeshNetwork] Found ${recipientId} in DHT, attempting connection...`);
                        await this.connectToPeer(recipientId);
                    }
                }
                catch (e) {
                    console.warn(`[MeshNetwork] DHT lookup failed for ${recipientId}`, e);
                }
            }
            console.log(`[MeshNetwork] No direct route to ${recipientId}, initiating Smart Flood...`);
            // Flood Fallback via TransportManager
            this.routingTable.getAllPeers().forEach((peer) => {
                if (peer.state === routing_js_1.PeerState.CONNECTED &&
                    peer.id !== this.localPeerId) {
                    this.transportManager.send(peer.id, encodedMessage).catch(() => { });
                }
            });
        }
    }
    /**
     * Send peer announcement to mesh
     */
    sendPeerAnnouncement() {
        const payload = new TextEncoder().encode(JSON.stringify({
            publicKey: Array.from(this.identity.publicKey)
                .map((b) => b.toString(16).padStart(2, "0"))
                .join(""),
            endpoints: [{ type: "webrtc", signaling: this.localPeerId }],
            capabilities: {
                supportedTransports: ["webrtc"],
                protocolVersion: 1,
            },
            timestamp: Date.now(),
        }));
        const message = {
            header: {
                version: 0x01,
                type: message_js_1.MessageType.PEER_DISCOVERY,
                ttl: this.defaultTTL,
                timestamp: Date.now(),
                senderId: this.identity.publicKey,
                signature: new Uint8Array(64),
            },
            payload,
        };
        // Sign and broadcast
        const messageBytes = (0, message_js_1.encodeMessage)(message);
        message.header.signature = (0, primitives_js_1.signMessage)(messageBytes, this.identity.privateKey);
        const encodedMessage = (0, message_js_1.encodeMessage)(message);
        // Broadcast via routing table
        this.routingTable.getAllPeers().forEach((peer) => {
            if (peer.state === routing_js_1.PeerState.CONNECTED) {
                this.transportManager.send(peer.id, encodedMessage).catch(() => { });
            }
        });
    }
    onMessage(callback) {
        this.messageListeners.add(callback);
    }
    /**
     * Unregister callback for incoming messages
     */
    offMessage(callback) {
        this.messageListeners.delete(callback);
    }
    /**
     * Register a discovery provider
     */
    registerDiscoveryProvider(provider) {
        this.discovery.registerProvider(provider);
    }
    /**
     * Handle discovered peer
     */
    handleDiscoveredPeer(peer) {
        const peerId = peer.id;
        if (peerId === this.localPeerId)
            return;
        if (!this.discoveredPeers.has(peerId)) {
            this.discoveredPeers.add(peerId);
            console.log(`Discovered new peer ${peerId} via ${peer.source}`);
            // Attempt to connect if we have capacity
            if (this.routingTable.getAllPeers().length < this.maxPeers) {
                console.log(`Discovered new peer ${peer.id} via ${peer.source}. Attempting connection...`);
                try {
                    if (peer.transportType === "ble") {
                        console.log(`[MeshNetwork] BLE peer discovered. Native bridge required to connect to ${peer.id}`);
                        // In a real implementation: Bridge.connect(peer.id, peer.connectionDetails)
                    }
                    else {
                        // Default to WebRTC / standard connection
                        this.connectToPeer(peer.id).catch((err) => {
                            console.warn(`Failed to auto-connect to discovered peer ${peerId}:`, err);
                        });
                    }
                }
                catch (e) {
                    console.error(`Failed to connect to discovered peer ${peer.id}:`, e);
                }
            }
        }
        // Notify listeners
        this.discoveryUpdateListeners.forEach((listener) => {
            try {
                listener(Array.from(this.discoveredPeers));
            }
            catch (e) {
                console.error("Error in discovery update listener:", e);
            }
        });
    }
    /**
     * Register callback for peer connected events
     */
    onPeerConnected(callback) {
        this.peerConnectedListeners.add(callback);
    }
    /**
     * Unregister callback for peer connected events
     */
    offPeerConnected(callback) {
        this.peerConnectedListeners.delete(callback);
    }
    /**
     * Register callback for peer disconnected events
     */
    onPeerDisconnected(callback) {
        this.peerDisconnectedListeners.add(callback);
    }
    /**
     * Unregister callback for peer disconnected events
     */
    offPeerDisconnected(callback) {
        this.peerDisconnectedListeners.delete(callback);
    }
    /**
     * Register callback for incoming peer tracks
     */
    /**
     * Register callback for incoming peer tracks
     */
    onPeerTrack(callback) {
        this.peerTrackListeners.add(callback);
    }
    offPeerTrack(callback) {
        this.peerTrackListeners.delete(callback);
    }
    // --- Blob Handlers ---
    async handleBlobMessage(message) {
        // Normalize sender ID to 16-char uppercase format
        const senderId = (0, encoding_js_1.bytesToHex)(message.header.senderId).substring(0, 16).toUpperCase();
        if (message.header.type === message_js_1.MessageType.REQUEST_BLOB) {
            try {
                const data = JSON.parse(new TextDecoder().decode(message.payload));
                const { hash, requestId } = data;
                const blob = await this.blobStore.get(hash);
                if (blob) {
                    // Send Response
                    const payload = new TextEncoder().encode(JSON.stringify({
                        hash,
                        requestId,
                        blob: (0, encoding_js_1.bytesToBase64)(blob),
                        recipient: senderId, // Add recipient for relay routing
                    }));
                    const responseMsg = {
                        header: {
                            version: 0x01,
                            type: message_js_1.MessageType.RESPONSE_BLOB,
                            ttl: this.defaultTTL,
                            timestamp: Date.now(),
                            senderId: this.identity.publicKey,
                            signature: new Uint8Array(64),
                        },
                        payload,
                    };
                    const msgBytes = (0, message_js_1.encodeMessage)(responseMsg);
                    responseMsg.header.signature = (0, primitives_js_1.signMessage)(msgBytes, this.identity.privateKey);
                    const encoded = (0, message_js_1.encodeMessage)(responseMsg);
                    await this.transportManager.send(senderId, encoded);
                }
            }
            catch (e) {
                console.error("Error handling REQUEST_BLOB", e);
            }
        }
        else if (message.header.type === message_js_1.MessageType.RESPONSE_BLOB) {
            try {
                const data = JSON.parse(new TextDecoder().decode(message.payload));
                const { hash: _hash, requestId, blob } = data;
                const pending = this.pendingBlobRequests.get(requestId);
                if (pending) {
                    const blobBuffer = (0, encoding_js_1.base64ToBytes)(blob);
                    // Verify hash? Ideally yes.
                    pending.resolve(blobBuffer);
                    clearTimeout(pending.timeout);
                    this.pendingBlobRequests.delete(requestId);
                }
            }
            catch (e) {
                console.error("Error processing RESPONSE_BLOB", e);
            }
        }
    }
    /**
     * Request a blob from a specific peer
     */
    async requestBlob(peerId, hash, timeoutMs = 5000) {
        const requestId = Math.random().toString(36).substring(7);
        return new Promise((resolve, reject) => {
            const timeout = setTimeout(() => {
                this.pendingBlobRequests.delete(requestId);
                // Don't reject, just return null if not found/timed out? Or reject.
                // For a DHT/Content fetch, null might be better if just "not found here".
                // But explicit timeout is useful.
                resolve(null);
            }, timeoutMs);
            this.pendingBlobRequests.set(requestId, { resolve, reject, timeout });
            const payload = new TextEncoder().encode(JSON.stringify({
                hash,
                requestId,
            }));
            const message = {
                header: {
                    version: 0x01,
                    type: message_js_1.MessageType.REQUEST_BLOB,
                    ttl: this.defaultTTL,
                    timestamp: Date.now(),
                    senderId: this.identity.publicKey,
                    signature: new Uint8Array(64),
                },
                payload,
            };
            const msgBytes = (0, message_js_1.encodeMessage)(message);
            message.header.signature = (0, primitives_js_1.signMessage)(msgBytes, this.identity.privateKey);
            const encoded = (0, message_js_1.encodeMessage)(message);
            this.transportManager.send(peerId, encoded).catch((e) => {
                clearTimeout(timeout);
                this.pendingBlobRequests.delete(requestId);
                reject(e);
            });
        });
    }
    /**
     * Register callback for discovery updates
     */
    onDiscoveryUpdate(callback) {
        this.discoveryUpdateListeners.add(callback);
    }
    /**
     * Unregister callback for discovery updates
     */
    offDiscoveryUpdate(callback) {
        this.discoveryUpdateListeners.delete(callback);
    }
    /**
     * Add media stream to peer connection
     */
    async addStreamToPeer(peerId, stream) {
        const peer = this.webrtcTransport.getPool().getPeer(peerId);
        if (!peer) {
            throw new Error(`Peer ${peerId} not found`);
        }
        stream.getTracks().forEach((track) => {
            peer.addTrack(track, stream);
        });
        // If connection is already established, we might need to renegotiate
        // But for now, we assume this is called before or during connection setup
        // Or that the browser handles renegotiation (which requires sending a new offer)
        // Trigger renegotiation if connected
        if (peer.getState() === "connected") {
            const offer = await peer.createOffer();
            await this.sendMessage(peerId, JSON.stringify({
                type: "SIGNAL",
                signal: { type: "offer", sdp: offer },
            }));
        }
    }
    /**
     * Get connected peers
     */
    getConnectedPeers() {
        return this.routingTable.getAllPeers();
    }
    /**
     * Get a specific peer by ID
     */
    getPeer(peerId) {
        return this.routingTable.getPeer(peerId);
    }
    /**
     * Get comprehensive network statistics for monitoring and scaling
     */
    async getStats() {
        const now = Date.now();
        const uptime = now - this.sessionTimestamp;
        const dhtTable = this.routingTable.getDHTRoutingTable();
        const dhtStats = dhtTable?.getStats ? dhtTable.getStats() : undefined;
        const dhtNodeCount = dhtStats?.nodeCount ?? 0;
        return {
            localPeerId: this.localPeerId,
            uptime,
            sessionTimestamp: this.sessionTimestamp,
            messagesSent: this.messagesSent,
            messagesReceived: this.messagesReceived,
            bytesTransferred: this.bytesTransferred,
            routing: this.routingTable.getStats(),
            relay: this.messageRelay.getStats(),
            peers: await this.webrtcTransport.getPool().getStats(),
            dht: this.dht
                ? {
                    nodeId: (0, encoding_js_1.bytesToHex)((0, index_js_1.publicKeyToNodeId)(this.identity.publicKey)),
                    nodeCount: dhtNodeCount,
                }
                : null,
            performance: {
                maxPeers: this.maxPeers,
                currentPeers: this.routingTable.getAllPeers().length,
                connectedPeers: this.routingTable.getAllPeers().filter(p => p.state === 'connected').length,
                defaultTTL: this.defaultTTL,
                messageQueueSize: 10000, // Default from config
                rateLimitPerPeer: 100, // Default from config
            },
        };
    }
    async handleIceCandidate(peerId, candidate) {
        try {
            const signalingData = {
                type: "candidate",
                data: candidate,
                from: peerId,
                to: this.localPeerId,
            };
            await this.webrtcTransport.handleSignaling(signalingData);
        }
        catch (error) {
            console.warn(`[MeshNetwork] Failed to process ICE candidate for ${peerId}:`, error);
        }
    }
    // ===== SESSION MANAGEMENT (Single-Session Enforcement) =====
    /**
     * Generate a unique session ID
     */
    generateSessionId() {
        const randomBytes = new Uint8Array(16);
        crypto.getRandomValues(randomBytes);
        return Array.from(randomBytes)
            .map((b) => b.toString(16).padStart(2, "0"))
            .join("");
    }
    /**
     * Start broadcasting session presence
     */
    startSessionPresence() {
        // Clear existing interval if any
        if (this.sessionPresenceInterval)
            clearInterval(this.sessionPresenceInterval);
        // Broadcast immediately
        this.broadcastSessionPresence();
        // Then broadcast every 30 seconds
        this.sessionPresenceInterval = setInterval(() => {
            this.broadcastSessionPresence();
        }, 30000);
        // Allow Node.js to exit cleanly
        try {
            if (this.sessionPresenceInterval &&
                typeof this.sessionPresenceInterval.unref === "function") {
                this.sessionPresenceInterval.unref();
            }
        }
        catch (e) {
            /* no-op */
        }
    }
    /**
     * Stop broadcasting session presence
     */
    stopSessionPresence() {
        if (this.sessionPresenceInterval) {
            clearInterval(this.sessionPresenceInterval);
            this.sessionPresenceInterval = null;
        }
    }
    /**
     * Broadcast session presence to all connected peers
     */
    async broadcastSessionPresence() {
        try {
            const payload = JSON.stringify({
                sessionId: this.sessionId,
                timestamp: this.sessionTimestamp,
                identityFingerprint: (0, encoding_js_1.bytesToHex)(this.identity.publicKey),
            });
            const payloadBytes = new TextEncoder().encode(payload);
            const message = {
                header: {
                    version: 0x01,
                    type: message_js_1.MessageType.SESSION_PRESENCE,
                    ttl: this.defaultTTL,
                    timestamp: Date.now(),
                    senderId: this.identity.publicKey,
                    signature: new Uint8Array(64),
                },
                payload: payloadBytes,
            };
            // Sign and broadcast
            // Note: We encode twice because signature must be computed over the message
            // without the signature field populated, then we set the signature and encode again
            const messageBytes = (0, message_js_1.encodeMessage)(message);
            message.header.signature = (0, primitives_js_1.signMessage)(messageBytes, this.identity.privateKey);
            const encodedMessage = (0, message_js_1.encodeMessage)(message);
            // Broadcast to all connected peers
            this.routingTable.getAllPeers().forEach((peer) => {
                if (peer.state === routing_js_1.PeerState.CONNECTED ||
                    peer.state === routing_js_1.PeerState.DEGRADED) {
                    this.transportManager.send(peer.id, encodedMessage).catch(() => { });
                }
            });
        }
        catch (error) {
            console.error("Failed to broadcast session presence:", error);
        }
    }
    /**
     * Handle incoming session presence message
     */
    handleSessionPresence(fromPeerId, payload) {
        try {
            const data = JSON.parse(new TextDecoder().decode(payload));
            const { sessionId, timestamp, identityFingerprint } = data;
            // Get our own identity fingerprint
            const ourFingerprint = (0, encoding_js_1.bytesToHex)(this.identity.publicKey);
            // Check if this is a duplicate session of our identity
            if (identityFingerprint === ourFingerprint &&
                sessionId !== this.sessionId) {
                // Another session with our identity exists!
                // Determine which session should be invalidated
                let shouldInvalidate = false;
                if (timestamp > this.sessionTimestamp) {
                    // Their timestamp is newer - invalidate this session
                    shouldInvalidate = true;
                }
                else if (timestamp === this.sessionTimestamp) {
                    // Race condition: same timestamp (e.g., simultaneous logins)
                    // Use sessionId lexicographic comparison as deterministic tie-breaker
                    shouldInvalidate = sessionId > this.sessionId;
                }
                if (shouldInvalidate) {
                    console.warn(`Detected newer session for our identity. Invalidating this session.
            Our session: ${this.sessionId} (${new Date(this.sessionTimestamp).toISOString()})
            New session: ${sessionId} (${new Date(timestamp).toISOString()})`);
                    // Call the invalidation callback
                    if (this.onSessionInvalidatedCallback) {
                        this.onSessionInvalidatedCallback();
                    }
                    // Shutdown this instance
                    this.shutdown();
                }
                else {
                    // Our session is newer - the other session should invalidate itself
                    console.info(`Detected older session for our identity. Our session is newer - keeping it.
            Our session: ${this.sessionId} (${new Date(this.sessionTimestamp).toISOString()})
            Old session: ${sessionId} (${new Date(timestamp).toISOString()})`);
                }
            }
        }
        catch (error) {
            console.error("Failed to handle session presence:", error);
        }
    }
    /**
     * Register callback for session invalidation
     */
    onSessionInvalidated(callback) {
        this.onSessionInvalidatedCallback = callback;
    }
    /**
     * Disconnect from all peers and shut down
     */
    shutdown() {
        this.transportManager.stop().catch(console.error);
        this.routingTable.getAllPeers().forEach((peer) => {
            this.routingTable.removePeer(peer.id);
        });
        this.stopHeartbeat();
        this.stopSessionPresence();
    } /**
     * Get local identity
     */
    getIdentity() {
        return this.identity;
    }
    /**
     * Get local peer ID
     */
    getLocalPeerId() {
        return this.localPeerId;
    }
    /**
     * Get public key
     */
    getPublicKey() {
        return this.identity.publicKey;
    }
    /**
     * Get peer count
     */
    getPeerCount() {
        return this.routingTable.getAllPeers().length;
    }
    /**
     * Bootstrap the network by finding closest peers to self in DHT
     */
    async bootstrap() {
        console.log("Bootstrapping DHT...");
        const peers = await this.dht.findNode(this.localPeerId);
        console.log(`DHT Bootstrap complete. Found ${peers.length} peers.`);
        // Attempt connections to discovered peers
        // Attempt connections to discovered peers
        for (const peer of peers) {
            if (peer.id !== this.localPeerId && !this.routingTable.getPeer(peer.id)) {
                // We know about them, but aren't connected.
                // If we have connection info (metadata implies we might, currently we don't store it fully in DHT response)
                // In full impl, FIND_NODE return values include IP/signal info.
                // For now, if we found them via DHT, it means someone else knows them.
                // We rely on the fact that `dht.ts` added them to routing table.
                // We may trigger connection attempts here if we have a way to signal them.
                // If we found them, we might want to try connecting if we are below maxPeers
                if (this.routingTable.getAllPeers().length < this.maxPeers) {
                    // connection logic would go here if we had signaling info
                    // For this version, just populating the routing table (done in DHT) is the first step.
                }
            }
        }
    }
    /**
     * Get the DHT instance
     */
    getDHT() {
        return this.dht;
    }
    /**
     * Send text message
     */
    async sendTextMessage(recipientId, text) {
        return this.sendMessage(recipientId, text);
    }
    /**
     * Send binary message
     */
    async sendBinaryMessage(recipientId, data, type = message_js_1.MessageType.FILE_CHUNK) {
        const message = {
            header: {
                version: 0x01,
                type: type,
                ttl: this.defaultTTL,
                timestamp: Date.now(),
                senderId: this.identity.publicKey,
                signature: new Uint8Array(65),
            },
            payload: data,
        };
        const messageBytes = (0, message_js_1.encodeMessage)(message);
        message.header.signature = (0, primitives_js_1.signMessage)(messageBytes, this.identity.privateKey);
        const encodedMessage = (0, message_js_1.encodeMessage)(message);
        const nextHop = this.routingTable.getNextHop(recipientId);
        if (nextHop) {
            // Direct route available
            this.transportManager.send(nextHop, encodedMessage).catch((err) => {
                console.warn(`Failed to send binary message to ${nextHop}:`, err);
            });
        }
        else {
            // Broadcast to all peers (flood routing)
            this.routingTable.getAllPeers().forEach((peer) => {
                if (peer.state === "connected") {
                    this.transportManager.send(peer.id, encodedMessage).catch(() => { });
                }
            });
        }
    }
    /**
     * Broadcast message to all peers
     */
    async broadcastMessage(text) {
        const payload = new TextEncoder().encode(text);
        const message = {
            header: {
                version: 0x01,
                type: message_js_1.MessageType.TEXT,
                ttl: this.defaultTTL,
                timestamp: Date.now(),
                senderId: this.identity.publicKey,
                signature: new Uint8Array(65),
            },
            payload,
        };
        const messageBytes = (0, message_js_1.encodeMessage)(message);
        message.header.signature = (0, primitives_js_1.signMessage)(messageBytes, this.identity.privateKey);
        const encodedMessage = (0, message_js_1.encodeMessage)(message);
        this.routingTable.getAllPeers().forEach((peer) => {
            if (peer.state === "connected") {
                this.transportManager.send(peer.id, encodedMessage).catch(() => { });
            }
        });
    }
    /**
     * Disconnect from a specific peer
     */
    async disconnectFromPeer(peerId) {
        // Shim: Manually verify specific transport removal
        // Ideally this should differ to TransportManager
        this.webrtcTransport.getPool().removePeer(peerId);
        this.routingTable.removePeer(peerId);
    }
    /**
     * Disconnect from all peers
     */
    async disconnectAll() {
        this.shutdown();
    }
    /**
     * Check if connected to a peer
     */
    isConnectedToPeer(peerId) {
        const peer = this.routingTable.getPeer(peerId);
        return Boolean(peer && peer.state === "connected");
    }
    /**
     * Get network statistics
     */
    getStatistics() {
        return {
            peerCount: this.getPeerCount(),
            messagesSent: this.messagesSent,
            messagesReceived: this.messagesReceived,
            bytesTransferred: this.bytesTransferred,
        };
    }
    /**
     * Start the network
     */
    async start() {
        await this.transportManager.start();
        this.startHeartbeat();
        this.startSessionPresence();
        this.startConnectionHealthMonitoring();
        this.messageRelay.start(); // Start sneakernet message retry
    }
    /**
     * Start connection health monitoring for rock-solid connections
     */
    startConnectionHealthMonitoring() {
        if (this.connectionHealthCheckInterval) {
            clearInterval(this.connectionHealthCheckInterval);
        }
        this.connectionHealthCheckInterval = setInterval(() => {
            this.performConnectionHealthCheck();
        }, this.HEALTH_CHECK_INTERVAL);
        console.log('[MeshNetwork] ðŸ” Started connection health monitoring');
    }
    /**
     * Perform comprehensive connection health check
     */
    performConnectionHealthCheck() {
        const now = Date.now();
        const connectedPeers = this.routingTable.getAllPeers().filter(p => p.state === 'connected');
        console.log(`[MeshNetwork] ðŸ’“ Health check: ${connectedPeers.length} connected peers`);
        for (const peer of connectedPeers) {
            const lastSeen = peer.lastSeen || 0;
            const connectionAge = now - lastSeen;
            const attempts = this.connectionAttempts.get(peer.id) || 0;
            // Check for stale connections
            if (connectionAge > this.CONNECTION_TIMEOUT) {
                console.warn(`[MeshNetwork] âš ï¸ Stale connection detected for ${peer.id} (${connectionAge}ms ago)`);
                if (attempts < this.MAX_CONNECTION_ATTEMPTS) {
                    console.log(`[MeshNetwork] ðŸ”„ Attempting to recover connection to ${peer.id}`);
                    this.attemptConnectionRecovery(peer.id);
                }
                else {
                    console.error(`[MeshNetwork] ðŸ’¥ Too many failed attempts for ${peer.id}, disconnecting`);
                    this.routingTable.removePeer(peer.id);
                    this.peerDisconnectedListeners.forEach(listener => listener(peer.id));
                }
            }
            else {
                // Reset connection attempts for healthy connections
                this.connectionAttempts.delete(peer.id);
                this.lastConnectionAttempt.delete(peer.id);
            }
        }
    }
    /**
     * Attempt to recover a failing connection
     */
    async attemptConnectionRecovery(peerId) {
        const attempts = (this.connectionAttempts.get(peerId) || 0) + 1;
        this.connectionAttempts.set(peerId, attempts);
        this.lastConnectionAttempt.set(peerId, Date.now());
        try {
            console.log(`[MeshNetwork] ðŸ”„ Recovery attempt ${attempts}/${this.MAX_CONNECTION_ATTEMPTS} for ${peerId}`);
            // Remove old peer entry
            this.routingTable.removePeer(peerId);
            // Try to reconnect via transport
            await this.transportManager.connect(peerId);
            // Wait a bit for connection to establish
            await new Promise(resolve => setTimeout(resolve, 2000));
            // Check if connection was successful
            const peer = this.routingTable.getPeer(peerId);
            if (peer && peer.state === 'connected') {
                console.log(`[MeshNetwork] âœ… Successfully recovered connection to ${peerId}`);
                this.connectionAttempts.delete(peerId);
                this.lastConnectionAttempt.delete(peerId);
            }
            else {
                throw new Error('Connection not established after recovery attempt');
            }
        }
        catch (error) {
            console.error(`[MeshNetwork] âŒ Recovery attempt ${attempts} failed for ${peerId}:`, error);
            if (attempts >= this.MAX_CONNECTION_ATTEMPTS) {
                console.error(`[MeshNetwork] ðŸ’¥ Giving up on connection to ${peerId} after ${attempts} attempts`);
                this.routingTable.removePeer(peerId);
                this.peerDisconnectedListeners.forEach(listener => listener(peerId));
            }
        }
    }
    /**
     * Stop the network
     */
    async stop() {
        // Clean up connection health monitoring
        if (this.connectionHealthCheckInterval) {
            clearInterval(this.connectionHealthCheckInterval);
            this.connectionHealthCheckInterval = undefined;
        }
        // Stop message relay retry process
        this.messageRelay.stop();
        this.shutdown();
    }
    // --- Manual Connection Methods (WAN Support) ---
    /**
     * Initiate a manual connection to a peer (for WAN/Serverless).
     * Returns the SDP Offer to be shared with the remote peer.
     */
    async createManualConnection(peerId) {
        if (this.routingTable.getAllPeers().length >= this.maxPeers) {
            throw new Error("Maximum number of peers reached");
        }
        // Create or get peer connection
        // Manual connection is specifically WEBRTC feature, so we access shim.
        // IMPORTANT: if we already have a peer connection for this peer, recreate it
        // before generating a new offer. Generating multiple offers / re-creating data
        // channels on an existing RTCPeerConnection can cause SDP m-line order mismatch.
        const pool = this.webrtcTransport.getPool();
        if (typeof pool.has === "function" && pool.has(peerId)) {
            try {
                const maybePromise = pool.removePeer(peerId);
                if (maybePromise && typeof maybePromise.then === "function") {
                    await maybePromise;
                }
            }
            catch (e) {
                // no-op
            }
        }
        const peer = pool.getOrCreatePeer(peerId);
        // Manual connection flow explicitly controls offer/answer exchange.
        // Disable automatic renegotiation offers during initial setup to avoid
        // concurrent offers and SDP m-line order mismatch.
        try {
            if (peer.connection && typeof peer.connection === "object") {
                peer.connection.onnegotiationneeded = null;
            }
        }
        catch {
            // no-op
        }
        // Create data channels
        peer.createDataChannel({ label: "reliable", ordered: true });
        peer.createDataChannel({
            label: "unreliable",
            ordered: false,
            maxRetransmits: 0,
        });
        // Create offer
        await peer.createOffer();
        // Set up state change handler to ensure peer is registered when connected
        peer.onStateChange((state) => {
            if (state === "connected") {
                this.handlePeerConnected(peerId);
            }
            else if (state === "disconnected" ||
                state === "failed" ||
                state === "closed") {
                this.handlePeerDisconnected(peerId);
            }
        });
        // Wait for ICE gathering to complete (so candidates are included in SDP)
        await peer.waitForIceGathering();
        const offer = await peer.getLocalDescription();
        // Return the offer wrapped with metadata
        return JSON.stringify({
            type: "offer",
            peerId: this.localPeerId,
            sdp: offer,
        });
    }
    /**
     * Register a callback for signaling (ICE candidates, offers, answers) to be sent via external channel
     */
    registerSignalingCallback(callback) {
        this.signalingCallback = callback;
    }
    /**
     * Register a callback for outbound messages via external transport (e.g., Native BLE)
     */
    registerOutboundTransport(callback) {
        this.outboundTransportCallback = callback;
    }
    /**
     * Handle incoming raw packet from external transport (e.g., Native BLE)
     */
    async handleIncomingPacket(peerId, data) {
        // Treat as if received from peer pool
        await this.messageRelay.processMessage(data, peerId);
        // Update metrics or checking if we need to add to table?
        // processMessage handles relay logic.
        // We should ensure the peer exists in routing table?
        // If it's a new peer sending us data, we might want to ensure they are "connected"
        if (!this.routingTable.getPeer(peerId)) {
            // We received data from an unknown peer via native transport.
            // The DiscoveryManager or native bridge shoutd ideally register them first.
            // But we can implicitly register or update last seen.
            // For now, let's assume Discovery handled registration or we just let it flow.
        }
    }
    /**
     * Accept a manual connection offer.
     * Returns the SDP Answer to be sent back to the initiator.
     */
    async acceptManualConnection(offerData) {
        const payload = JSON.parse(offerData);
        const { peerId, sdp } = payload;
        if (!peerId || !sdp || sdp.type !== "offer") {
            throw new Error("Invalid manual offer data");
        }
        // Create peer connection
        const peer = this.webrtcTransport.getPool().getOrCreatePeer(peerId);
        // Set remote description (Offer)
        await peer.setRemoteDescription(sdp);
        // Create answer
        await peer.createAnswer();
        // Set up state change handler to ensure peer is registered when connected
        peer.onStateChange((state) => {
            if (state === "connected") {
                this.handlePeerConnected(peerId);
            }
            else if (state === "disconnected" ||
                state === "failed" ||
                state === "closed") {
                this.handlePeerDisconnected(peerId);
            }
        });
        // Wait for ICE gathering
        await peer.waitForIceGathering();
        const answer = await peer.getLocalDescription();
        // Return the answer wrapped with metadata
        return JSON.stringify({
            type: "answer",
            peerId: this.localPeerId,
            sdp: answer,
        });
    }
    /**
     * Finalize a manual connection with the answer.
     */
    async finalizeManualConnection(answerData) {
        const payload = JSON.parse(answerData);
        const { peerId, sdp } = payload;
        if (!peerId || !sdp || sdp.type !== "answer") {
            throw new Error("Invalid manual answer data");
        }
        const peer = this.webrtcTransport.getPool().getPeer(peerId);
        if (!peer) {
            throw new Error(`Peer ${peerId} not found (connection not initiated?)`);
        }
        await peer.setRemoteAnswer(sdp);
    }
    // --- DHT Operations ---
    /**
     * Store a value in the DHT
     */
    async dhtStore(key, value) {
        await this.dht.store(key, value);
    }
    /**
     * Find a value in the DHT
     */
    async dhtFindValue(key) {
        return this.dht.findValue(key);
    }
    /**
     * Find a node in the DHT
     */
    async dhtFindNode(nodeId) {
        const peers = await this.dht.findNode(nodeId);
        return peers.find((p) => p.id === nodeId);
    }
    /**
     * Send a file to a peer
     */
    async sendFile(peerId, file) {
        return this.transferManager.sendFile(peerId, file);
    }
}
exports.MeshNetwork = MeshNetwork;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL2NocmlzdHltYXh3ZWxsL0Rlc2t0b3AvTHVrZV9TdHVmZi9HaXRIdWIvU0MvY29yZS9zcmMvbWVzaC9uZXR3b3JrLnRzIiwibWFwcGluZ3MiOiI7QUFBQTs7O0dBR0c7OztBQUVILHNEQUFnRjtBQUNoRix1REFBNkU7QUFDN0UsNkNBQXlFO0FBQ3pFLHlDQUEwQztBQUMxQywyREFBdUU7QUFDdkUsd0VBQWtFO0FBQ2xFLDJEQUlpQztBQUVqQyxvRUFBNkQ7QUFDN0QscUNBQStCO0FBQy9CLGlEQUl3QjtBQUN4Qiw2Q0FBeUU7QUFDekUsc0VBQXVFO0FBRXZFLG1EQUFvRDtBQUNwRCw0REFBMkU7QUFDM0UsdUVBQXVFO0FBQ3ZFLHVFQUFpRTtBQUNqRSw2Q0FBMkM7QUE0QjNDOzs7R0FHRztBQUNILE1BQWEsV0FBVztJQWdGdEIsWUFBWSxTQUE0QixFQUFFO1FBM0R6QiwwQkFBcUIsR0FBRyxLQUFLLENBQUMsQ0FBQyxhQUFhO1FBQzVDLHVCQUFrQixHQUFHLEtBQUssQ0FBQyxDQUFDLGFBQWE7UUFDekMsNEJBQXVCLEdBQUcsQ0FBQyxDQUFDO1FBQ3JDLHVCQUFrQixHQUF3QixJQUFJLEdBQUcsRUFBRSxDQUFDO1FBQ3BELDBCQUFxQixHQUF3QixJQUFJLEdBQUcsRUFBRSxDQUFDO1FBRS9ELFlBQVk7UUFDSixxQkFBZ0IsR0FBb0MsSUFBSSxHQUFHLEVBQUUsQ0FBQztRQUM5RCwyQkFBc0IsR0FBa0MsSUFBSSxHQUFHLEVBQUUsQ0FBQztRQUNsRSw4QkFBeUIsR0FBa0MsSUFBSSxHQUFHLEVBQUUsQ0FBQztRQUNyRSx1QkFBa0IsR0FFdEIsSUFBSSxHQUFHLEVBQUUsQ0FBQztRQUNOLDZCQUF3QixHQUFtQyxJQUFJLEdBQUcsRUFBRSxDQUFDO1FBYTdFLFFBQVE7UUFDQSxvQkFBZSxHQUFnQixJQUFJLEdBQUcsRUFBRSxDQUFDO1FBQ3pDLGlCQUFZLEdBQW1DLElBQUksR0FBRyxFQUFFLENBQUM7UUFDekQsd0JBQW1CLEdBQTBDLElBQUksQ0FBQztRQUNsRSx3QkFBbUIs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QztJQUNqQyxDQUFDO0lBRUQ7O09BRUc7SUFDSCxLQUFLLENBQUMsV0FBVyxDQUFDLE1BQWM7UUFDOUIsTUFBTSxLQUFLLEdBQUcsTUFBTSxJQUFJLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUM5QyxPQUFPLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLEtBQUssTUFBTSxDQUFDLENBQUM7SUFDNUMsQ0FBQztJQUVEOztPQUVHO0lBQ0gsS0FBSyxDQUFDLFFBQVEsQ0FBQyxNQUFjLEVBQUUsSUFBdUI7UUFDcEQsT0FBTyxJQUFJLENBQUMsZUFBZSxDQUFDLFFBQVEsQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDckQsQ0FBQztDQUNGO0FBMzhERCxrQ0EyOERDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIi9Vc2Vycy9jaHJpc3R5bWF4d2VsbC9EZXNrdG9wL0x1a2VfU3R1ZmYvR2l0SHViL1NDL2NvcmUvc3JjL21lc2gvbmV0d29yay50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIE1lc2ggTmV0d29yayBNYW5hZ2VyXG4gKiBPcmNoZXN0cmF0ZXMgcm91dGluZywgcmVsYXksIGFuZCB0cmFuc3BvcnQgY29ubmVjdGlvbnNcbiAqL1xuXG5pbXBvcnQgeyBieXRlc1RvSGV4LCBieXRlc1RvQmFzZTY0LCBiYXNlNjRUb0J5dGVzIH0gZnJvbSBcIi4uL3V0aWxzL2VuY29kaW5nLmpzXCI7XG5pbXBvcnQgeyBNZXNzYWdlLCBNZXNzYWdlVHlwZSwgZW5jb2RlTWVzc2FnZSB9IGZyb20gXCIuLi9wcm90b2NvbC9tZXNzYWdlLmpzXCI7XG5pbXBvcnQgeyBSb3V0aW5nVGFibGUsIFBlZXIsIGNyZWF0ZVBlZXIsIFBlZXJTdGF0ZSB9IGZyb20gXCIuL3JvdXRpbmcuanNcIjtcbmltcG9ydCB7IE1lc3NhZ2VSZWxheSB9IGZyb20gXCIuL3JlbGF5LmpzXCI7XG5pbXBvcnQgeyBUcmFuc3BvcnRNYW5hZ2VyLCBUcmFuc3BvcnQgfSBmcm9tIFwiLi90cmFuc3BvcnQvVHJhbnNwb3J0LmpzXCI7XG5pbXBvcnQgeyBXZWJSVENUcmFuc3BvcnQgfSBmcm9tIFwiLi4vdHJhbnNwb3J0L1dlYlJUQ1RyYW5zcG9ydC5qc1wiO1xuaW1wb3J0IHtcbiAgZ2VuZXJhdGVJZGVudGl0eSxcbiAgSWRlbnRpdHlLZXlQYWlyLFxuICBzaWduTWVzc2FnZSxcbn0gZnJvbSBcIi4uL2NyeXB0by9wcmltaXRpdmVzLmpzXCI7XG5pbXBvcnQgeyBnZW5lcmF0ZUZpbmdlcnByaW50U3luYyBhcyBfZ2VuZXJhdGVGaW5nZXJwcmludFN5bmMgfSBmcm9tIFwiLi4vdXRpbHMvZmluZ2VycHJpbnQuanNcIjtcbmltcG9ydCB7IENvbm5lY3Rpb25Nb25pdG9yIH0gZnJvbSBcIi4uL2Nvbm5lY3Rpb24tcXVhbGl0eS5qc1wiO1xuaW1wb3J0IHsgREhUIH0gZnJvbSBcIi4vZGh0LmpzXCI7XG5pbXBvcnQge1xuICBEaXNjb3ZlcnlNYW5hZ2VyLFxuICBEaXNjb3ZlcnlQZWVyLFxuICBEaXNjb3ZlcnlQcm92aWRlcixcbn0gZnJvbSBcIi4vZGlzY292ZXJ5LmpzXCI7XG5pbXBvcnQgeyBLYWRlbWxpYVJvdXRpbmdUYWJsZSwgcHVibGljS2V5VG9Ob2RlSWQgfSBmcm9tIFwiLi9kaHQvaW5kZXguanNcIjtcbmltcG9ydCB7IEh0dHBCb290c3RyYXBQcm92aWRlciB9IGZyb20gXCIuLi9kaXNjb3ZlcnkvaHR0cC1ib290c3RyYXAuanNcIjtcbmltcG9ydCB7IFN0b3JhZ2VBZGFwdGVyIH0gZnJvbSBcIi4vZGh0L3N0b3JhZ2UvU3RvcmFnZUFkYXB0ZXIuanNcIjtcbmltcG9ydCB7IFJlbmRlenZvdXNNYW5hZ2VyIH0gZnJvbSBcIi4vcmVuZGV6dm91cy5qc1wiO1xuaW1wb3J0IHsgQmxvYlN0b3JlLCBJbmRleGVkREJCbG9iQWRhcHRlciB9IGZyb20gXCIuLi9zdG9yYWdlL2Jsb2Itc3RvcmUuanNcIjtcbmltcG9ydCB7IFNvY2lhbFJlY292ZXJ5TWFuYWdlciB9IGZyb20gXCIuLi9yZWNvdmVyeS9zb2NpYWwtcmVjb3ZlcnkuanNcIjtcbmltcG9ydCB7IFRyYW5zZmVyTWFuYWdlciB9IGZyb20gXCIuLi90cmFuc2Zlci9UcmFuc2Zlck1hbmFnZXIuanNcIjtcbmltcG9ydCB7IFJvdXRpbmdNb2RlIH0gZnJvbSBcIi4vcm91dGluZy5qc1wiO1xuXG5leHBvcnQgaW50ZXJmYWNlIE1lc2hOZXR3b3JrQ29uZmlnIHtcbiAgaWRlbnRpdHk/OiBJZGVudGl0eUtleVBhaXI7XG4gIHBlZXJJZD86IHN0cmluZzsgLy8gRXhwbGljaXQgUGVlciBJRCAoZmluZ2VycHJpbnQpXG4gIG1heFBlZXJzPzogbnVtYmVyO1xuICBkZWZhdWx0VFRMPzogbnVtYmVyO1xuICBwZXJzaXN0ZW5jZT86IFBlcnNpc3RlbmNlQWRhcHRlcjtcbiAgZGh0U3RvcmFnZT86IFN0b3JhZ2VBZGFwdGVyO1xuICB0cmFuc3BvcnRzPzogVHJhbnNwb3J0W107XG4gIGJvb3RzdHJhcFVybD86IHN0cmluZzsgLy8gVVJMIGZvciBIVFRQIGJvb3RzdHJhcFxuICBcbiAgLy8gUGVyZm9ybWFuY2UgYW5kIHNjYWxpbmcgY29uZmlndXJhdGlvbnNcbiAgbWVzc2FnZVF1ZXVlU2l6ZT86IG51bWJlcjsgLy8gTWF4IG1lc3NhZ2VzIGluIHF1ZXVlIChkZWZhdWx0OiAxMDAwMClcbiAgY29ubmVjdGlvblRpbWVvdXQ/OiBudW1iZXI7IC8vIENvbm5lY3Rpb24gdGltZW91dCBpbiBtcyAoZGVmYXVsdDogMzAwMDApXG4gIGhlYXJ0YmVhdEludGVydmFsPzogbnVtYmVyOyAvLyBIZWFydGJlYXQgaW50ZXJ2YWwgaW4gbXMgKGRlZmF1bHQ6IDMwMDAwKVxuICBoZWFsdGhDaGVja0ludGVydmFsPzogbnVtYmVyOyAvLyBIZWFsdGggY2hlY2sgaW50ZXJ2YWwgaW4gbXMgKGRlZmF1bHQ6IDUwMDApXG4gIG1heE1lc3NhZ2VTaXplPzogbnVtYmVyOyAvLyBNYXggbWVzc2FnZSBzaXplIGluIGJ5dGVzIChkZWZhdWx0OiAxTUIpXG4gIHJhdGVMaW1pdFBlclBlZXI/OiBudW1iZXI7IC8vIE1heCBtZXNzYWdlcyBwZXIgc2Vjb25kIHBlciBwZWVyIChkZWZhdWx0OiAxMDApXG4gIGVuYWJsZVNlbGVjdGl2ZUZsb29kaW5nPzogYm9vbGVhbjsgLy8gRW5hYmxlIHNtYXJ0IGZsb29kaW5nIChkZWZhdWx0OiB0cnVlKVxuICBlbmFibGVNZXNzYWdlRGVkdXBsaWNhdGlvbj86IGJvb2xlYW47IC8vIEVuYWJsZSBkZWR1cGxpY2F0aW9uIChkZWZhdWx0OiB0cnVlKVxuICBlbmFibGVMb29wRGV0ZWN0aW9uPzogYm9vbGVhbjsgLy8gRW5hYmxlIGxvb3AgZGV0ZWN0aW9uIChkZWZhdWx0OiB0cnVlKVxuICBtYXhSZXRyaWVzPzogbnVtYmVyOyAvLyBNYXggcmV0cnkgYXR0ZW1wdHMgKGRlZmF1bHQ6IDMpXG4gIHJldHJ5QmFja29mZj86IG51bWJlcjsgLy8gUmV0cnkgYmFja29mZiBpbiBtcyAoZGVmYXVsdDogNTAwMClcbn1cblxuaW1wb3J0IHsgUGVyc2lzdGVuY2VBZGFwdGVyIH0gZnJvbSBcIi4vcmVsYXkuanNcIjtcblxuLyoqXG4gKiBNZXNoIE5ldHdvcmsgTWFuYWdlclxuICogSGlnaC1sZXZlbCBBUEkgZm9yIG1lc2ggbmV0d29ya2luZ1xuICovXG5leHBvcnQgY2xhc3MgTWVzaE5ldHdvcmsge1xuICBwcml2YXRlIGlkZW50aXR5OiBJZGVudGl0eUtleVBhaXI7XG4gIHByaXZhdGUgcm91dGluZ1RhYmxlOiBSb3V0aW5nVGFibGU7XG4gIHByaXZhdGUgbWVzc2FnZVJlbGF5OiBNZXNzYWdlUmVsYXk7XG5cbiAgLy8gUmVwbGFjZWQgUGVlckNvbm5lY3Rpb25Qb29sIHdpdGggVHJhbnNwb3J0TWFuYWdlclxuICBwcml2YXRlIHRyYW5zcG9ydE1hbmFnZXI6IFRyYW5zcG9ydE1hbmFnZXI7XG4gIHByaXZhdGUgd2VicnRjVHJhbnNwb3J0OiBXZWJSVENUcmFuc3BvcnQ7IC8vIEtlZXAgcmVmIGZvciBzaWduYWxpbmcgaG9va1xuXG4gIHByaXZhdGUgbG9jYWxQZWVySWQ6IHN0cmluZztcbiAgcHJpdmF0ZSBkZWZhdWx0VFRMOiBudW1iZXI7XG4gIHByaXZhdGUgbWF4UGVlcnM6IG51bWJlcjtcbiAgcHJpdmF0ZSBkaHQ6IERIVDtcbiAgcHVibGljIHJlbmRlenZvdXM6IFJlbmRlenZvdXNNYW5hZ2VyO1xuICBwdWJsaWMgZGlzY292ZXJ5OiBEaXNjb3ZlcnlNYW5hZ2VyO1xuICBwdWJsaWMgYmxvYlN0b3JlOiBCbG9iU3RvcmU7XG4gIHB1YmxpYyBzb2NpYWxSZWNvdmVyeTogU29jaWFsUmVjb3ZlcnlNYW5hZ2VyO1xuICBwdWJsaWMgdHJhbnNmZXJNYW5hZ2VyOiBUcmFuc2Zlck1hbmFnZXI7XG5cbiAgLy8gQ29ubmVjdGlvbiBtb25pdG9yaW5nIGFuZCByZWNvdmVyeVxuICBwcml2YXRlIGNvbm5lY3Rpb25IZWFsdGhDaGVja0ludGVydmFsPzogTm9kZUpTLlRpbWVvdXQ7XG4gIHByaXZhdGUgcmVhZG9ubHkgSEVBTFRIX0NIRUNLX0lOVEVSVkFMID0gMTUwMDA7IC8vIDE1IHNlY29uZHNcbiAgcHJpdmF0ZSByZWFkb25seSBDT05ORUNUSU9OX1RJTUVPVVQgPSA0NTAwMDsgLy8gNDUgc2Vjb25kc1xuICBwcml2YXRlIHJlYWRvbmx5IE1BWF9DT05ORUNUSU9OX0FUVEVNUFRTID0gMztcbiAgcHJpdmF0ZSBjb25uZWN0aW9uQXR0ZW1wdHM6IE1hcDxzdHJpbmcsIG51bWJlcj4gPSBuZXcgTWFwKCk7XG4gIHByaXZhdGUgbGFzdENvbm5lY3Rpb25BdHRlbXB0OiBNYXA8c3RyaW5nLCBudW1iZXI+ID0gbmV3IE1hcCgpO1xuXG4gIC8vIENhbGxiYWNrc1xuICBwcml2YXRlIG1lc3NhZ2VMaXN0ZW5lcnM6IFNldDwobWVzc2FnZTogTWVzc2FnZSkgPT4gdm9pZD4gPSBuZXcgU2V0KCk7XG4gIHByaXZhdGUgcGVlckNvbm5lY3RlZExpc3RlbmVyczogU2V0PChwZWVySWQ6IHN0cmluZykgPT4gdm9pZD4gPSBuZXcgU2V0KCk7XG4gIHByaXZhdGUgcGVlckRpc2Nvbm5lY3RlZExpc3RlbmVyczogU2V0PChwZWVySWQ6IHN0cmluZykgPT4gdm9pZD4gPSBuZXcgU2V0KCk7XG4gIHByaXZhdGUgcGVlclRyYWNrTGlzdGVuZXJzOiBTZXQ8XG4gICAgKHBlZXJJZDogc3RyaW5nLCB0cmFjazogTWVkaWFTdHJlYW1UcmFjaywgc3RyZWFtOiBNZWRpYVN0cmVhbSkgPT4gdm9pZFxuICA+ID0gbmV3IFNldCgpO1xuICBwcml2YXRlIGRpc2NvdmVyeVVwZGF0ZUxpc3RlbmVyczogU2V0PChwZWVyczogc3RyaW5nW10pID0+IHZvaWQ+ID0gbmV3IFNldCgpO1xuXG4gIC8vIFJlcGxhY2VkIGJ5IFRyYW5zcG9ydCBSZWdpc3RyYXRpb24gKExlZ2FjeSBTdXBwb3J0KVxuICBwcml2YXRlIG91dGJvdW5kVHJhbnNwb3J0Q2FsbGJhY2s/OiAoXG4gICAgcGVlcklkOiBzdHJpbmcsXG4gICAgZGF0YTogVWludDhBcnJheSxcbiAgKSA9PiBQcm9taXNlPHZvaWQ+O1xuXG4gIHByaXZhdGUgc2lnbmFsaW5nQ2FsbGJhY2s/OiAoXG4gICAgcGVlcklkOiBzdHJpbmcsXG4gICAgc2lnbmFsOiB7IHR5cGU6IHN0cmluZzsgY2FuZGlkYXRlPzogUlRDSWNlQ2FuZGlkYXRlSW5pdDsgc2RwPzogUlRDU2Vzc2lvbkRlc2NyaXB0aW9uSW5pdCB9LFxuICApID0+IFByb21pc2U8dm9pZD47XG5cbiAgLy8gU3RhdGVcbiAgcHJpdmF0ZSBkaXNjb3ZlcmVkUGVlcnM6IFNldDxzdHJpbmc+ID0gbmV3IFNldCgpO1xuICBwcml2YXRlIHBlZXJNb25pdG9yczogTWFwPHN0cmluZywgQ29ubmVjdGlvbk1vbml0b3I+ID0gbmV3IE1hcCgpO1xuICBwcml2YXRlIGhlYWx0aENoZWNrSW50ZXJ2YWw6IFJldHVyblR5cGU8dHlwZW9mIHNldEludGVydmFsPiB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIHBlbmRpbmdCbG9iUmVxdWVzdHM6IE1hcDxcbiAgICBzdHJpbmcsXG4gICAge1xuICAgICAgcmVzb2x2ZTogKGJsb2I6IFVpbnQ4QXJyYXkgfCBudWxsKSA9PiB2b2lkO1xuICAgICAgcmVqZWN0OiAoZXJyOiBFcnJvcikgPT4gdm9pZDtcbiAgICAgIHRpbWVvdXQ6IFJldHVyblR5cGU8dHlwZW9mIHNldFRpbWVvdXQ+O1xuICAgIH1cbiAgPiA9IG5ldyBNYXAoKTtcblxuICAvLyBNZXNzYWdlIHN0YXRpc3RpY3NcbiAgcHJpdmF0ZSBtZXNzYWdlc1N0b3JlZDogbnVtYmVyID0gMDtcblxuICAvLyBTZXNzaW9uIGVuZm9yY2VtZW50IChzaW5nbGUtc2Vzc2lvbiBwZXIgaWRlbnRpdHkpXG4gIHByaXZhdGUgc2Vzc2lvbklkOiBzdHJpbmc7XG4gIHByaXZhdGUgc2Vzc2lvblRpbWVzdGFtcDogbnVtYmVyO1xuICBwcml2YXRlIHNlc3Npb25QcmVzZW5jZUludGVydmFsOiBSZXR1cm5UeXBlPHR5cGVvZiBzZXRJbnRlcnZhbD4gfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBvblNlc3Npb25JbnZhbGlkYXRlZENhbGxiYWNrPzogKCkgPT4gdm9pZDtcblxuICAvLyBNZXRyaWNzIHRyYWNraW5nXG4gIHByaXZhdGUgbWVzc2FnZXNTZW50ID0gMDtcbiAgcHJpdmF0ZSBtZXNzYWdlc1JlY2VpdmVkID0gMDtcbiAgcHJpdmF0ZSBieXRlc1RyYW5zZmVycmVkID0gMDtcbiAgcHJpdmF0ZSBoZWFydGJlYXRNczogbnVtYmVyO1xuICBwcml2YXRlIGhlYWx0aENoZWNrTXM6IG51bWJlcjtcbiAgcHJpdmF0ZSBtYXhNZXNzYWdlU2l6ZTogbnVtYmVyO1xuICBwcml2YXRlIHJhdGVMaW1pdFBlclBlZXI6IG51bWJlcjtcbiAgcHJpdmF0ZSBtYXhSZXRyaWVzOiBudW1iZXI7XG4gIHByaXZhdGUgcmV0cnlCYWNrb2ZmOiBudW1iZXI7XG5cbiAgY29uc3RydWN0b3IoY29uZmlnOiBNZXNoTmV0d29ya0NvbmZpZyA9IHt9KSB7XG4gICAgLy8gSW5pdGlhbGl6ZSBpZGVudGl0eVxuICAgIHRoaXMuaWRlbnRpdHkgPSBjb25maWcuaWRlbnRpdHkgfHwgZ2VuZXJhdGVJZGVudGl0eSgpO1xuXG4gICAgLy8gVW5pZmllZCBJZGVudGl0eTogVXNlIHByb3ZpZGVkIElEIG9yIHRoZSBmdWxsIGhleC1lbmNvZGVkIHB1YmxpYyBrZXkgYXMgcGVlciBJRFxuICAgIC8vIFBlZXIgSURzIGFjcm9zcyB0aGUgY29kZWJhc2UgYXJlIGV4cGVjdGVkIHRvIGJlIHRoZSBoZXgtZW5jb2RlZCBwdWJsaWMga2V5LlxuICAgIHRoaXMubG9jYWxQZWVySWQgPVxuICAgICAgY29uZmlnLnBlZXJJZCB8fCBCdWZmZXIuZnJvbSh0aGlzLmlkZW50aXR5LnB1YmxpY0tleSkudG9TdHJpbmcoXCJoZXhcIik7XG5cbiAgICAvLyBJbml0aWFsaXplIHNlc3Npb24gZm9yIHNpbmdsZS1zZXNzaW9uIGVuZm9yY2VtZW50XG4gICAgdGhpcy5zZXNzaW9uSWQgPSB0aGlzLmdlbmVyYXRlU2Vzc2lvbklkKCk7XG4gICAgdGhpcy5zZXNzaW9uVGltZXN0YW1wID0gRGF0ZS5ub3coKTtcblxuICAgIC8vIENvbmZpZ3VyYXRpb24gd2l0aCBwcm9kdWN0aW9uLXJlYWR5IGRlZmF1bHRzIGZvciAxTSsgdXNlcnNcbiAgICB0aGlzLmRlZmF1bHRUVEwgPSBjb25maWcuZGVmYXVsdFRUTCB8fCAxMDtcbiAgICB0aGlzLm1heFBlZXJzID0gY29uZmlnLm1heFBlZXJzIHx8IDEwMDsgLy8gSW5jcmVhc2VkIGZvciBiZXR0ZXIgc2NhbGluZ1xuXG4gICAgLy8gUGVyZm9ybWFuY2UgY29uZmlndXJhdGlvblxuICAgIGNvbnN0IG1lc3NhZ2VRdWV1ZVNpemUgPSBjb25maWcubWVzc2FnZVF1ZXVlU2l6ZSA/PyAxMDAwMDtcbiAgICBjb25zdCBfY29ubmVjdGlvblRpbWVvdXQgPSBjb25maWcuY29ubmVjdGlvblRpbWVvdXQgPz8gMzAwMDA7XG4gICAgdGhpcy5oZWFydGJlYXRNcyA9IGNvbmZpZy5oZWFydGJlYXRJbnRlcnZhbCA/PyAzMDAwMDtcbiAgICB0aGlzLmhlYWx0aENoZWNrTXMgPSBjb25maWcuaGVhbHRoQ2hlY2tJbnRlcnZhbCA/PyA1MDAwO1xuICAgIHRoaXMubWF4TWVzc2FnZVNpemUgPSBjb25maWcubWF4TWVzc2FnZVNpemUgPz8gMTAyNCAqIDEwMjQ7IC8vIDFNQlxuICAgIHRoaXMucmF0ZUxpbWl0UGVyUGVlciA9IGNvbmZpZy5yYXRlTGltaXRQZXJQZWVyID8/IDEwMDtcbiAgICBjb25zdCBlbmFibGVTZWxlY3RpdmVGbG9vZGluZyA9IGNvbmZpZy5lbmFibGVTZWxlY3RpdmVGbG9vZGluZyAhPT0gZmFsc2U7XG4gICAgY29uc3QgX2VuYWJsZU1lc3NhZ2VEZWR1cGxpY2F0aW9uID0gY29uZmlnLmVuYWJsZU1lc3NhZ2VEZWR1cGxpY2F0aW9uICE9PSBmYWxzZTtcbiAgICBjb25zdCBfZW5hYmxlTG9vcERldGVjdGlvbiA9IGNvbmZpZy5lbmFibGVMb29wRGV0ZWN0aW9uICE9PSBmYWxzZTtcbiAgICB0aGlzLm1heFJldHJpZXMgPSBjb25maWcubWF4UmV0cmllcyA/PyAzO1xuICAgIHRoaXMucmV0cnlCYWNrb2ZmID0gY29uZmlnLnJldHJ5QmFja29mZiA/PyA1MDAwO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSBjb21wb25lbnRzXG4gICAgLy8gRGVyaXZlIERIVCBub2RlIElEIGZyb20gcHVibGljIGtleSAobm90IGZyb20gaGV4IHBlZXIgSUQgd2hpY2ggaXMgNjQgY2hhcnMpXG4gICAgY29uc3QgZGh0Tm9kZUlkID0gcHVibGljS2V5VG9Ob2RlSWQodGhpcy5pZGVudGl0eS5wdWJsaWNLZXkpO1xuICAgIGNvbnN0IGRodFJvdXRpbmdUYWJsZSA9IG5ldyBLYWRlbWxpYVJvdXRpbmdUYWJsZShkaHROb2RlSWQpO1xuXG4gICAgdGhpcy5yb3V0aW5nVGFibGUgPSBuZXcgUm91dGluZ1RhYmxlKHRoaXMubG9jYWxQZWVySWQsIHtcbiAgICAgIG1vZGU6IFJvdXRpbmdNb2RlLkhZQlJJRCwgLy8gRGVmYXVsdCB0byBIeWJyaWQgKERIVCArIEZsb29kKVxuICAgICAgZGh0Um91dGluZ1RhYmxlLFxuICAgIH0pO1xuXG4gICAgLy8gQ29uZmlndXJlIG1lc3NhZ2UgcmVsYXkgZm9yIGhpZ2gtc2NhbGUgb3BlcmF0aW9uc1xuICAgIGNvbnN0IHJlbGF5Q29uZmlnID0ge1xuICAgICAgbWF4U3RvcmVkTWVzc2FnZXM6IG1lc3NhZ2VRdWV1ZVNpemUsXG4gICAgICBzdG9yZVRpbWVvdXQ6IDMwMDAwMCwgLy8gNSBtaW51dGVzXG4gICAgICBtYXhSZXRyaWVzOiB0aGlzLm1heFJldHJpZXMsXG4gICAgICByZXRyeUJhY2tvZmY6IHRoaXMucmV0cnlCYWNrb2ZmLFxuICAgICAgZmxvb2RSYXRlTGltaXQ6IHRoaXMucmF0ZUxpbWl0UGVyUGVlcixcbiAgICAgIHNlbGVjdGl2ZUZsb29kaW5nOiBlbmFibGVTZWxlY3RpdmVGbG9vZGluZyxcbiAgICB9O1xuXG4gICAgdGhpcy5tZXNzYWdlUmVsYXkgPSBuZXcgTWVzc2FnZVJlbGF5KFxuICAgICAgdGhpcy5sb2NhbFBlZXJJZCxcbiAgICAgIHRoaXMucm91dGluZ1RhYmxlLFxuICAgICAgcmVsYXlDb25maWcsXG4gICAgICBjb25maWcucGVyc2lzdGVuY2UgYXMgUGVyc2lzdGVuY2VBZGFwdGVyLFxuICAgICk7XG5cbiAgICAvLyBJbml0aWFsaXplIFRyYW5zcG9ydHNcbiAgICB0aGlzLnRyYW5zcG9ydE1hbmFnZXIgPSBuZXcgVHJhbnNwb3J0TWFuYWdlcigpO1xuXG4gICAgLy8gUmVnaXN0ZXIgV2ViUlRDIFRyYW5zcG9ydFxuICAgIHRoaXMud2VicnRjVHJhbnNwb3J0ID0gbmV3IFdlYlJUQ1RyYW5zcG9ydCh0aGlzLmxvY2FsUGVlcklkKTtcbiAgICB0aGlzLnRyYW5zcG9ydE1hbmFnZXIucmVnaXN0ZXJUcmFuc3BvcnQodGhpcy53ZWJydGNUcmFuc3BvcnQpO1xuXG4gICAgLy8gUmVnaXN0ZXIgY3VzdG9tIHRyYW5zcG9ydHNcbiAgICBpZiAoY29uZmlnLnRyYW5zcG9ydHMpIHtcbiAgICAgIGNvbmZpZy50cmFuc3BvcnRzLmZvckVhY2goKHRyYW5zcG9ydCkgPT4ge1xuICAgICAgICB0aGlzLnRyYW5zcG9ydE1hbmFnZXIucmVnaXN0ZXJUcmFuc3BvcnQodHJhbnNwb3J0KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEJpbmQgVHJhbnNwb3J0IEV2ZW50c1xuICAgIHRoaXMudHJhbnNwb3J0TWFuYWdlci5vbk1lc3NhZ2UoKHBlZXJJZCwgZGF0YSkgPT4ge1xuICAgICAgdGhpcy5oYW5kbGVJbmNvbWluZ1RyYW5zcG9ydE1lc3NhZ2UocGVlcklkLCBkYXRhKTtcbiAgICB9KTtcblxuICAgIHRoaXMudHJhbnNwb3J0TWFuYWdlci5vblBlZXJDb25uZWN0ZWQoKHBlZXJJZCkgPT4ge1xuICAgICAgdGhpcy5oYW5kbGVQZWVyQ29ubmVjdGVkKHBlZXJJZCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLnRyYW5zcG9ydE1hbmFnZXIub25QZWVyRGlzY29ubmVjdGVkKChwZWVySWQpID0+IHtcbiAgICAgIHRoaXMuaGFuZGxlUGVlckRpc2Nvbm5lY3RlZChwZWVySWQpO1xuICAgIH0pO1xuXG4gICAgdGhpcy53ZWJydGNUcmFuc3BvcnQuZ2V0UG9vbCgpLm9uU2lnbmFsKChwZWVySWQsIHNpZ25hbCkgPT4ge1xuICAgICAgaWYgKHRoaXMuc2lnbmFsaW5nQ2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5zaWduYWxpbmdDYWxsYmFjayhwZWVySWQsIHNpZ25hbCkuY2F0Y2goKGVycikgPT5cbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiW01lc2hOZXR3b3JrXSBGYWlsZWQgdG8gc2VuZCBzaWduYWwgdmlhIGNhbGxiYWNrOlwiLCBlcnIpLFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLm91dGJvdW5kVHJhbnNwb3J0Q2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5vdXRib3VuZFRyYW5zcG9ydENhbGxiYWNrKHBlZXJJZCwgbmV3IFVpbnQ4QXJyYXkoKSkuY2F0Y2goKGVycikgPT5cbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiW01lc2hOZXR3b3JrXSBGYWlsZWQgdG8gc2VuZCBzaWduYWwgdmlhIG91dGJvdW5kIHRyYW5zcG9ydDpcIiwgZXJyKSxcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZGVidWcoXCJbTWVzaE5ldHdvcmtdIE5vIHNpZ25hbGluZyBjYWxsYmFjayByZWdpc3RlcmVkLCBJQ0UgY2FuZGlkYXRlIGRyb3BwZWQgZm9yOlwiLCBwZWVySWQpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy53ZWJydGNUcmFuc3BvcnQuZ2V0UG9vbCgpLm9uVHJhY2soKHBlZXJJZCwgdHJhY2ssIHN0cmVhbSkgPT4ge1xuICAgICAgdGhpcy5wZWVyVHJhY2tMaXN0ZW5lcnMuZm9yRWFjaCgobGlzdGVuZXIpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBsaXN0ZW5lcihwZWVySWQsIHRyYWNrLCBzdHJlYW0pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGluIHBlZXIgdHJhY2sgbGlzdGVuZXI6XCIsIGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8vIEluaXRpYWxpemUgREhUXG4gICAgdGhpcy5kaHQgPSBuZXcgREhUKFxuICAgICAgdGhpcy5yb3V0aW5nVGFibGUsXG4gICAgICBhc3luYyAocGVlcklkLCB0eXBlLCBwYXlsb2FkKSA9PiB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2U6IE1lc3NhZ2UgPSB7XG4gICAgICAgICAgaGVhZGVyOiB7XG4gICAgICAgICAgICB2ZXJzaW9uOiAweDAxLFxuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIHR0bDogdGhpcy5kZWZhdWx0VFRMLFxuICAgICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgc2VuZGVySWQ6IHRoaXMuaWRlbnRpdHkucHVibGljS2V5LFxuICAgICAgICAgICAgc2lnbmF0dXJlOiBuZXcgVWludDhBcnJheSg2NCksXG4gICAgICAgICAgfSxcbiAgICAgICAgICBwYXlsb2FkLFxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IG1lc3NhZ2VCeXRlcyA9IGVuY29kZU1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgIG1lc3NhZ2UuaGVhZGVyLnNpZ25hdHVyZSA9IHNpZ25NZXNzYWdlKFxuICAgICAgICAgIG1lc3NhZ2VCeXRlcyxcbiAgICAgICAgICB0aGlzLmlkZW50aXR5LnByaXZhdGVLZXksXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IGVuY29kZWRNZXNzYWdlID0gZW5jb2RlTWVzc2FnZShtZXNzYWdlKTtcblxuICAgICAgICAvLyBSb3V0ZSB2aWEgVHJhbnNwb3J0IE1hbmFnZXJcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCB0aGlzLnRyYW5zcG9ydE1hbmFnZXIuc2VuZChwZWVySWQsIGVuY29kZWRNZXNzYWdlKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8vIElmIGFuIG91dGJvdW5kIHRyYW5zcG9ydCBjYWxsYmFjayBpcyByZWdpc3RlcmVkIChzaW11bGF0aW9uIC8gbmF0aXZlKSwgdXNlIGl0XG4gICAgICAgICAgaWYgKHRoaXMub3V0Ym91bmRUcmFuc3BvcnRDYWxsYmFjaykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgYXdhaXQgdGhpcy5vdXRib3VuZFRyYW5zcG9ydENhbGxiYWNrKHBlZXJJZCwgZW5jb2RlZE1lc3NhZ2UpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgICBgW0RIVF0gRmFpbGVkIHRvIGRlbGl2ZXIgbWVzc2FnZSB0byAke3BlZXJJZH0gdmlhIG91dGJvdW5kVHJhbnNwb3J0Q2FsbGJhY2suYCxcbiAgICAgICAgICAgICAgICBlcnIsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEZhbGxiYWNrIHRvIGZsb29kIGlmIG5lZWRlZCwgb3IgaGFuZGxlIGVycm9yXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgIGBbREhUXSBGYWlsZWQgdG8gc2VuZCBtZXNzYWdlIHRvICR7cGVlcklkfSB2aWEgdHJhbnNwb3J0cy5gLFxuICAgICAgICAgICAgICBlLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7IHN0b3JhZ2U6IGNvbmZpZy5kaHRTdG9yYWdlIH0sXG4gICAgKTtcblxuICAgIC8vIEluaXRpYWxpemUgRGlzY292ZXJ5IE1hbmFnZXJcbiAgICB0aGlzLmRpc2NvdmVyeSA9IG5ldyBEaXNjb3ZlcnlNYW5hZ2VyKCk7XG4gICAgaWYgKGNvbmZpZy5ib290c3RyYXBVcmwpIHtcbiAgICAgIHRoaXMuZGlzY292ZXJ5LnJlZ2lzdGVyUHJvdmlkZXIoXG4gICAgICAgIG5ldyBIdHRwQm9vdHN0cmFwUHJvdmlkZXIoY29uZmlnLmJvb3RzdHJhcFVybCksXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLmRpc2NvdmVyeS5vblBlZXJEaXNjb3ZlcmVkKHRoaXMuaGFuZGxlRGlzY292ZXJlZFBlZXIuYmluZCh0aGlzKSk7XG5cbiAgICAvLyBJbml0aWFsaXplIFJlbmRlenZvdXMgTWFuYWdlclxuICAgIHRoaXMucmVuZGV6dm91cyA9IG5ldyBSZW5kZXp2b3VzTWFuYWdlcihcbiAgICAgIHRoaXMubG9jYWxQZWVySWQsXG4gICAgICB0aGlzLmRodCxcbiAgICAgIGFzeW5jIChwZWVySWQsIHR5cGUsIHBheWxvYWQpID0+IHtcbiAgICAgICAgY29uc3QgbWVzc2FnZTogTWVzc2FnZSA9IHtcbiAgICAgICAgICBoZWFkZXI6IHtcbiAgICAgICAgICAgIHZlcnNpb246IDB4MDEsXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgdHRsOiB0aGlzLmRlZmF1bHRUVEwsXG4gICAgICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICAgICAgICBzZW5kZXJJZDogdGhpcy5pZGVudGl0eS5wdWJsaWNLZXksXG4gICAgICAgICAgICBzaWduYXR1cmU6IG5ldyBVaW50OEFycmF5KDY0KSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHBheWxvYWQsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VCeXRlcyA9IGVuY29kZU1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgIG1lc3NhZ2UuaGVhZGVyLnNpZ25hdHVyZSA9IHNpZ25NZXNzYWdlKFxuICAgICAgICAgIG1lc3NhZ2VCeXRlcyxcbiAgICAgICAgICB0aGlzLmlkZW50aXR5LnByaXZhdGVLZXksXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IGVuY29kZWRNZXNzYWdlID0gZW5jb2RlTWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCB0aGlzLnRyYW5zcG9ydE1hbmFnZXIuc2VuZChwZWVySWQsIGVuY29kZWRNZXNzYWdlKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGlmICh0aGlzLm91dGJvdW5kVHJhbnNwb3J0Q2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGF3YWl0IHRoaXMub3V0Ym91bmRUcmFuc3BvcnRDYWxsYmFjayhwZWVySWQsIGVuY29kZWRNZXNzYWdlKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgYFtSZW5kZXp2b3VzXSBGYWlsZWQgdG8gZGVsaXZlciB0byAke3BlZXJJZH0gdmlhIG91dGJvdW5kVHJhbnNwb3J0Q2FsbGJhY2suYCxcbiAgICAgICAgICAgICAgICBlcnIsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgW1JlbmRlenZvdXNdIEZhaWxlZCB0byBzZW5kIHRvICR7cGVlcklkfWAsIGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICApO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSBCbG9iU3RvcmUgd2l0aCBwZXJzaXN0ZW50IHN0b3JhZ2UgZm9yIHNuZWFrZXJuZXQgcmVsYXlcbiAgICAvLyBJbiBicm93c2VyIGVudmlyb25tZW50cywgdXNlIEluZGV4ZWREQjsgaW4gTm9kZS90ZXN0LCB1c2UgbWVtb3J5LW9ubHlcbiAgICBsZXQgYmxvYlBlcnNpc3RlbmNlO1xuICAgIGlmICh0eXBlb2YgaW5kZXhlZERCICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgYmxvYlBlcnNpc3RlbmNlID0gbmV3IEluZGV4ZWREQkJsb2JBZGFwdGVyKCk7XG4gICAgfVxuICAgIHRoaXMuYmxvYlN0b3JlID0gbmV3IEJsb2JTdG9yZShibG9iUGVyc2lzdGVuY2UpO1xuICAgIFxuICAgIC8vIEluaXRpYWxpemUgYmxvYiBzdG9yZSBhc3luY2hyb25vdXNseSAobm9uLWJsb2NraW5nKVxuICAgIHRoaXMuYmxvYlN0b3JlLmluaXQoKS5jYXRjaChlcnIgPT4ge1xuICAgICAgY29uc29sZS5lcnJvcignW0Jsb2JTdG9yZV0gRmFpbGVkIHRvIGluaXRpYWxpemUgcGVyc2lzdGVudCBzdG9yYWdlOicsIGVycik7XG4gICAgICAvLyBDb250aW51ZSB3aXRoIG1lbW9yeS1vbmx5IG1vZGUgaWYgSW5kZXhlZERCIGZhaWxzXG4gICAgfSk7XG5cbiAgICAvLyBJbml0aWFsaXplIFNvY2lhbCBSZWNvdmVyeVxuICAgIHRoaXMuc29jaWFsUmVjb3ZlcnkgPSBuZXcgU29jaWFsUmVjb3ZlcnlNYW5hZ2VyKHRoaXMpO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSBUcmFuc2ZlciBNYW5hZ2VyXG4gICAgdGhpcy50cmFuc2Zlck1hbmFnZXIgPSBuZXcgVHJhbnNmZXJNYW5hZ2VyKHRoaXMpO1xuXG4gICAgdGhpcy5zZXR1cE1lc3NhZ2VIYW5kbGVycygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB1cCBtZXNzYWdlIGhhbmRsZXJzIGZvciByZWxheSBhbmQgcGVlciBwb29sXG4gICAqL1xuICBwcml2YXRlIGhlYXJ0YmVhdEludGVydmFsOiBSZXR1cm5UeXBlPHR5cGVvZiBzZXRJbnRlcnZhbD4gfCBudWxsID0gbnVsbDtcblxuICAvKipcbiAgICogU2V0IHVwIG1lc3NhZ2UgaGFuZGxlcnMgZm9yIHJlbGF5IGFuZCBwZWVyIHBvb2xcbiAgICovXG4gIHByaXZhdGUgc2V0dXBNZXNzYWdlSGFuZGxlcnMoKTogdm9pZCB7XG4gICAgLy8gSGFuZGxlIG1lc3NhZ2VzIGFkZHJlc3NlZCB0byB0aGlzIHBlZXJcbiAgICB0aGlzLm1lc3NhZ2VSZWxheS5vbk1lc3NhZ2VGb3JTZWxmKChtZXNzYWdlOiBNZXNzYWdlKSA9PiB7XG4gICAgICB0aGlzLm1lc3NhZ2VzUmVjZWl2ZWQrKztcbiAgICAgIHRoaXMuYnl0ZXNUcmFuc2ZlcnJlZCArPSBtZXNzYWdlLnBheWxvYWQuYnl0ZUxlbmd0aDtcblxuICAgICAgLy8gRXh0cmFjdCBzZW5kZXIgSUQgLSB1c2UgZmlyc3QgMTYgY2hhcnMgKDggYnl0ZXMpIGluIHVwcGVyY2FzZSB0byBtYXRjaCBwZWVyIElEIGZvcm1hdFxuICAgICAgY29uc3Qgc2VuZGVySWQgPSBBcnJheS5mcm9tKG1lc3NhZ2UuaGVhZGVyLnNlbmRlcklkKVxuICAgICAgICAubWFwKChiKSA9PiBiLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCBcIjBcIikpXG4gICAgICAgIC5qb2luKFwiXCIpXG4gICAgICAgIC5zdWJzdHJpbmcoMCwgMTYpXG4gICAgICAgIC50b1VwcGVyQ2FzZSgpO1xuXG4gICAgICAvLyBIYW5kbGUgQ29udHJvbCBNZXNzYWdlc1xuICAgICAgaWYgKG1lc3NhZ2UuaGVhZGVyLnR5cGUgPT09IE1lc3NhZ2VUeXBlLkNPTlRST0xfUElORykge1xuICAgICAgICB0aGlzLnNlbmRQb25nKG1lc3NhZ2UuaGVhZGVyLnNlbmRlcklkLCBtZXNzYWdlLmhlYWRlci50aW1lc3RhbXApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIEhhbmRsZSBGaWxlIFRyYW5zZmVyIE1lc3NhZ2VzXG4gICAgICBpZiAoXG4gICAgICAgIG1lc3NhZ2UuaGVhZGVyLnR5cGUgPT09IE1lc3NhZ2VUeXBlLkZJTEVfTUVUQURBVEEgfHxcbiAgICAgICAgbWVzc2FnZS5oZWFkZXIudHlwZSA9PT0gTWVzc2FnZVR5cGUuRklMRV9DSFVOS1xuICAgICAgKSB7XG4gICAgICAgIHRoaXMudHJhbnNmZXJNYW5hZ2VyLmhhbmRsZU1lc3NhZ2UoXG4gICAgICAgICAgbWVzc2FnZS5oZWFkZXIudHlwZSxcbiAgICAgICAgICBtZXNzYWdlLnBheWxvYWQsXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gSGFuZGxlIERIVCBNZXNzYWdlc1xuICAgICAgaWYgKFxuICAgICAgICBtZXNzYWdlLmhlYWRlci50eXBlID09PSBNZXNzYWdlVHlwZS5ESFRfRklORF9OT0RFIHx8XG4gICAgICAgIG1lc3NhZ2UuaGVhZGVyLnR5cGUgPT09IE1lc3NhZ2VUeXBlLkRIVF9GT1VORF9OT0RFUyB8fFxuICAgICAgICBtZXNzYWdlLmhlYWRlci50eXBlID09PSBNZXNzYWdlVHlwZS5ESFRfRklORF9WQUxVRSB8fFxuICAgICAgICBtZXNzYWdlLmhlYWRlci50eXBlID09PSBNZXNzYWdlVHlwZS5ESFRfU1RPUkVcbiAgICAgICkge1xuICAgICAgICB0aGlzLmRodC5oYW5kbGVNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChcbiAgICAgICAgbWVzc2FnZS5oZWFkZXIudHlwZSA9PT0gTWVzc2FnZVR5cGUuUkVOREVaVk9VU19BTk5PVU5DRSB8fFxuICAgICAgICBtZXNzYWdlLmhlYWRlci50eXBlID09PSBNZXNzYWdlVHlwZS5SRU5ERVpWT1VTX1FVRVJZIHx8XG4gICAgICAgIG1lc3NhZ2UuaGVhZGVyLnR5cGUgPT09IE1lc3NhZ2VUeXBlLlJFTkRFWlZPVVNfUkVTUE9OU0VcbiAgICAgICkge1xuICAgICAgICB0aGlzLnJlbmRlenZvdXMuaGFuZGxlTWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBIYW5kbGUgQmxvYiBNZXNzYWdlc1xuICAgICAgaWYgKFxuICAgICAgICBtZXNzYWdlLmhlYWRlci50eXBlID09PSBNZXNzYWdlVHlwZS5SRVFVRVNUX0JMT0IgfHxcbiAgICAgICAgbWVzc2FnZS5oZWFkZXIudHlwZSA9PT0gTWVzc2FnZVR5cGUuUkVTUE9OU0VfQkxPQlxuICAgICAgKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlQmxvYk1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKG1lc3NhZ2UuaGVhZGVyLnR5cGUgPT09IE1lc3NhZ2VUeXBlLkNPTlRST0xfUE9ORykge1xuICAgICAgICAvLyBDYWxjdWxhdGUgUlRUXG4gICAgICAgIC8vIFBheWxvYWQgY29udGFpbnMgdGhlIG9yaWdpbmFsIHRpbWVzdGFtcCAoOCBieXRlcyAvIDY0LWJpdCBmbG9hdCBzdG9yZWQgYXMgc3RyaW5nIG9yIGJ5dGVzKVxuICAgICAgICAvLyBGb3Igc2ltcGxpY2l0eSwgbGV0J3MgYXNzdW1lIHBheWxvYWQgaXMgSlNPTiBzdHJpbmcgb2YgdGltZXN0YW1wXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgcGF5bG9hZFN0ciA9IG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShtZXNzYWdlLnBheWxvYWQpO1xuICAgICAgICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKHBheWxvYWRTdHIpO1xuICAgICAgICAgIGlmIChkYXRhLnBpbmdUaW1lc3RhbXApIHtcbiAgICAgICAgICAgIGNvbnN0IHJ0dCA9IERhdGUubm93KCkgLSBkYXRhLnBpbmdUaW1lc3RhbXA7XG4gICAgICAgICAgICBjb25zdCBtb25pdG9yID0gdGhpcy5wZWVyTW9uaXRvcnMuZ2V0KHNlbmRlcklkKTtcbiAgICAgICAgICAgIGlmIChtb25pdG9yKSB7XG4gICAgICAgICAgICAgIG1vbml0b3IudXBkYXRlTGF0ZW5jeShydHQpO1xuICAgICAgICAgICAgICAvLyBVcGRhdGUgcGVlciBsYXN0IHNlZW4gdGltZXN0YW1wXG4gICAgICAgICAgICAgIHRoaXMucm91dGluZ1RhYmxlLnVwZGF0ZVBlZXJMYXN0U2VlbihzZW5kZXJJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gSWdub3JlIG1hbGZvcm1lZCBQT05HXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBIYW5kbGUgU2Vzc2lvbiBQcmVzZW5jZSAoU2luZ2xlLVNlc3Npb24gRW5mb3JjZW1lbnQpXG4gICAgICBpZiAobWVzc2FnZS5oZWFkZXIudHlwZSA9PT0gTWVzc2FnZVR5cGUuU0VTU0lPTl9QUkVTRU5DRSkge1xuICAgICAgICB0aGlzLmhhbmRsZVNlc3Npb25QcmVzZW5jZShzZW5kZXJJZCwgbWVzc2FnZS5wYXlsb2FkKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBOb3RpZnkgYWxsIGxpc3RlbmVyc1xuICAgICAgdGhpcy5tZXNzYWdlTGlzdGVuZXJzLmZvckVhY2goKGxpc3RlbmVyKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbGlzdGVuZXIobWVzc2FnZSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGluIG1lc3NhZ2UgbGlzdGVuZXI6XCIsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvLyBIYW5kbGUgbWVzc2FnZSBmb3J3YXJkaW5nIChTbWFydCBSb3V0aW5nKVxuICAgIHRoaXMubWVzc2FnZVJlbGF5Lm9uRm9yd2FyZE1lc3NhZ2UoXG4gICAgICAobWVzc2FnZTogTWVzc2FnZSwgZXhjbHVkZVBlZXJJZDogc3RyaW5nKSA9PiB7XG4gICAgICAgIGNvbnN0IGVuY29kZWRNZXNzYWdlID0gZW5jb2RlTWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5tZXNzYWdlc1NlbnQrKztcbiAgICAgICAgdGhpcy5ieXRlc1RyYW5zZmVycmVkICs9IGVuY29kZWRNZXNzYWdlLmJ5dGVMZW5ndGg7XG5cbiAgICAgICAgLy8gXCJTbWFydCBGbG9vZFwiIC8gVGllcmVkIFJvdXRpbmcgTG9naWNcbiAgICAgICAgbGV0IHRhcmdldElkOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgcGF5bG9hZFN0ciA9IG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShtZXNzYWdlLnBheWxvYWQpO1xuICAgICAgICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKHBheWxvYWRTdHIpO1xuICAgICAgICAgIHRhcmdldElkID0gZGF0YS5yZWNpcGllbnQ7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAvLyBOb3QgYSBKU09OIHBheWxvYWQgb3IgcGFyc2luZyBmYWlsZWQgLT4gQnJvYWRjYXN0XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGFyZ2V0SWQpIHtcbiAgICAgICAgICBjb25zdCBjYW5kaWRhdGVzID1cbiAgICAgICAgICAgIHRoaXMucm91dGluZ1RhYmxlLmdldFJhbmtlZFBlZXJzRm9yVGFyZ2V0KHRhcmdldElkKTtcblxuICAgICAgICAgIC8vIEZpbHRlcjogRXhjbHVkZSBzZW5kZXIgYW5kIHNlbGZcbiAgICAgICAgICBjb25zdCB2YWxpZENhbmRpZGF0ZXMgPSBjYW5kaWRhdGVzLmZpbHRlcihcbiAgICAgICAgICAgIChwKSA9PlxuICAgICAgICAgICAgICBwLmlkICE9PSBleGNsdWRlUGVlcklkICYmXG4gICAgICAgICAgICAgIHAuaWQgIT09IHRoaXMubG9jYWxQZWVySWQgJiZcbiAgICAgICAgICAgICAgcC5zdGF0ZSA9PT0gXCJjb25uZWN0ZWRcIixcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgLy8gQWRhcHRpdmUgU2VsZWN0aW9uIExvZ2ljXG4gICAgICAgICAgY29uc3QgdG90YWxDYW5kaWRhdGVzID0gdmFsaWRDYW5kaWRhdGVzLmxlbmd0aDtcbiAgICAgICAgICBjb25zdCBGTE9PRF9USFJFU0hPTEQgPSA1OyAvLyBcIkZld1wiIHRocmVzaG9sZFxuXG4gICAgICAgICAgbGV0IGNvdW50VG9TZWxlY3Q7XG4gICAgICAgICAgaWYgKHRvdGFsQ2FuZGlkYXRlcyA8PSBGTE9PRF9USFJFU0hPTEQpIHtcbiAgICAgICAgICAgIGNvdW50VG9TZWxlY3QgPSB0b3RhbENhbmRpZGF0ZXM7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvdW50VG9TZWxlY3QgPSBNYXRoLm1heChcbiAgICAgICAgICAgICAgRkxPT0RfVEhSRVNIT0xELFxuICAgICAgICAgICAgICBNYXRoLmNlaWwodG90YWxDYW5kaWRhdGVzICogMC4xKSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3Qgc2VsZWN0ZWRQZWVycyA9IHZhbGlkQ2FuZGlkYXRlcy5zbGljZSgwLCBjb3VudFRvU2VsZWN0KTtcblxuICAgICAgICAgIGlmIChzZWxlY3RlZFBlZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICBgW01lc2hOZXR3b3JrXSBObyB2YWxpZCBwZWVycyBmb3IgZm9yd2FyZGluZyB0byAke3RhcmdldElkfS4gRHJvcHBpbmcuYCxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2VsZWN0ZWRQZWVycy5mb3JFYWNoKChwZWVyKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnRyYW5zcG9ydE1hbmFnZXIuc2VuZChwZWVyLmlkLCBlbmNvZGVkTWVzc2FnZSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gZm9yd2FyZCB0byAke3BlZXIuaWR9YCwgZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEZhbGxiYWNrIHRvIEZ1bGwgRmxvb2QgdmlhIFRyYW5zcG9ydE1hbmFnZXIgKG5lZWRzIGJyb2FkY2FzdCBjYXBhYmlsaXR5IG9yIG1hbnVhbCBsb29wKVxuICAgICAgICAgIC8vIFRyYW5zcG9ydE1hbmFnZXIgc2VuZCBpcyBwb2ludC10by1wb2ludC5cbiAgICAgICAgICAvLyBXZSBtdXN0IGl0ZXJhdGUgbWFudWFsIHBlZXJzLlxuICAgICAgICAgIHRoaXMucm91dGluZ1RhYmxlLmdldEFsbFBlZXJzKCkuZm9yRWFjaCgocGVlcikgPT4ge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBwZWVyLmlkICE9PSBleGNsdWRlUGVlcklkICYmXG4gICAgICAgICAgICAgIHBlZXIuaWQgIT09IHRoaXMubG9jYWxQZWVySWQgJiZcbiAgICAgICAgICAgICAgcGVlci5zdGF0ZSA9PT0gUGVlclN0YXRlLkNPTk5FQ1RFRFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0TWFuYWdlclxuICAgICAgICAgICAgICAgIC5zZW5kKHBlZXIuaWQsIGVuY29kZWRNZXNzYWdlKVxuICAgICAgICAgICAgICAgIC5jYXRjaCgoKSA9PiB7fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgKTtcbiAgfVxuXG4gIC8vIEhhbmRsZSBpbmNvbWluZyBmcm9tIFRyYW5zcG9ydFxuICBwcml2YXRlIGhhbmRsZUluY29taW5nVHJhbnNwb3J0TWVzc2FnZShwZWVySWQ6IHN0cmluZywgZGF0YTogVWludDhBcnJheSkge1xuICAgIHRoaXMubWVzc2FnZVJlbGF5LnByb2Nlc3NNZXNzYWdlKGRhdGEsIHBlZXJJZCk7XG5cbiAgICAvLyBVcGRhdGUgcGFja2V0IGxvc3MgbWV0cmljcyAoc2ltcGxpZmllZClcbiAgICBjb25zdCBtb25pdG9yID0gdGhpcy5wZWVyTW9uaXRvcnMuZ2V0KHBlZXJJZCk7XG4gICAgaWYgKG1vbml0b3IpIHtcbiAgICAgIG1vbml0b3IudXBkYXRlQmFuZHdpZHRoKGRhdGEubGVuZ3RoLCAxMDAwKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3RhcnQgc2VuZGluZyBoZWFydGJlYXQgKFBJTkcpIG1lc3NhZ2VzXG4gICAqL1xuICBzdGFydEhlYXJ0YmVhdChpbnRlcnZhbE1zOiBudW1iZXIgPSAzMDAwMCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmhlYXJ0YmVhdEludGVydmFsKSBjbGVhckludGVydmFsKHRoaXMuaGVhcnRiZWF0SW50ZXJ2YWwpO1xuICAgIGNvbnN0IGhiTXMgPSBpbnRlcnZhbE1zID8/IHRoaXMuaGVhcnRiZWF0TXM7XG4gICAgdGhpcy5oZWFydGJlYXRJbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIHRoaXMuYnJvYWRjYXN0UGluZygpO1xuICAgIH0sIGhiTXMpO1xuICAgIHRyeSB7XG4gICAgICBpZiAoXG4gICAgICAgIHRoaXMuaGVhcnRiZWF0SW50ZXJ2YWwgJiZcbiAgICAgICAgdHlwZW9mICh0aGlzLmhlYXJ0YmVhdEludGVydmFsIGFzIGFueSkudW5yZWYgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgKSB7XG4gICAgICAgICh0aGlzLmhlYXJ0YmVhdEludGVydmFsIGFzIGFueSkudW5yZWYoKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvKiBuby1vcCAqL1xuICAgIH1cblxuICAgIC8vIEFsc28gc3RhcnQgaGVhbHRoIGNoZWNrIGxvb3BcbiAgICBpZiAodGhpcy5oZWFsdGhDaGVja0ludGVydmFsKSBjbGVhckludGVydmFsKHRoaXMuaGVhbHRoQ2hlY2tJbnRlcnZhbCk7XG4gICAgdGhpcy5oZWFsdGhDaGVja0ludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgdGhpcy5tb25pdG9yQ29ubmVjdGlvbkhlYWx0aCgpO1xuICAgIH0sIHRoaXMuaGVhbHRoQ2hlY2tNcyk7IC8vIENvbmZpZ3VyYWJsZSBjaGVjayBpbnRlcnZhbFxuICAgIHRyeSB7XG4gICAgICBpZiAoXG4gICAgICAgIHRoaXMuaGVhbHRoQ2hlY2tJbnRlcnZhbCAmJlxuICAgICAgICB0eXBlb2YgKHRoaXMuaGVhbHRoQ2hlY2tJbnRlcnZhbCBhcyBhbnkpLnVucmVmID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICkge1xuICAgICAgICAodGhpcy5oZWFsdGhDaGVja0ludGVydmFsIGFzIGFueSkudW5yZWYoKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvKiBuby1vcCAqL1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9wIHNlbmRpbmcgaGVhcnRiZWF0IG1lc3NhZ2VzXG4gICAqL1xuICBzdG9wSGVhcnRiZWF0KCk6IHZvaWQge1xuICAgIC8vIFN0b3AgaW50ZXJuYWxzXG4gICAgdGhpcy50cmFuc3BvcnRNYW5hZ2VyLnN0b3AoKS5jYXRjaChjb25zb2xlLmVycm9yKTtcblxuICAgIGlmICh0aGlzLmhlYXJ0YmVhdEludGVydmFsKSB7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMuaGVhcnRiZWF0SW50ZXJ2YWwpO1xuICAgICAgdGhpcy5oZWFydGJlYXRJbnRlcnZhbCA9IG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLmhlYWx0aENoZWNrSW50ZXJ2YWwpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5oZWFsdGhDaGVja0ludGVydmFsKTtcbiAgICAgIHRoaXMuaGVhbHRoQ2hlY2tJbnRlcnZhbCA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBicm9hZGNhc3RQaW5nKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBWYWxpZGF0ZSBpZGVudGl0eSBrZXlzIGJlZm9yZSBzaWduaW5nXG4gICAgICBpZiAoIXRoaXMuaWRlbnRpdHk/LnByaXZhdGVLZXkgfHwgdGhpcy5pZGVudGl0eS5wcml2YXRlS2V5Lmxlbmd0aCAhPT0gMzIpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdbTWVzaE5ldHdvcmtdIGJyb2FkY2FzdFBpbmcgc2tpcHBlZDogaW52YWxpZCBwcml2YXRlIGtleScpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuaWRlbnRpdHk/LnB1YmxpY0tleSB8fCB0aGlzLmlkZW50aXR5LnB1YmxpY0tleS5sZW5ndGggIT09IDMyKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignW01lc2hOZXR3b3JrXSBicm9hZGNhc3RQaW5nIHNraXBwZWQ6IGludmFsaWQgcHVibGljIGtleScpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG1lc3NhZ2U6IE1lc3NhZ2UgPSB7XG4gICAgICAgIGhlYWRlcjoge1xuICAgICAgICAgIHZlcnNpb246IDB4MDEsXG4gICAgICAgICAgdHlwZTogTWVzc2FnZVR5cGUuQ09OVFJPTF9QSU5HLFxuICAgICAgICAgIHR0bDogMSxcbiAgICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICAgICAgc2VuZGVySWQ6IHRoaXMuaWRlbnRpdHkucHVibGljS2V5LFxuICAgICAgICAgIHNpZ25hdHVyZTogbmV3IFVpbnQ4QXJyYXkoNjQpLFxuICAgICAgICB9LFxuICAgICAgICBwYXlsb2FkOiBuZXcgVWludDhBcnJheSgwKSxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IG1lc3NhZ2VCeXRlcyA9IGVuY29kZU1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICBtZXNzYWdlLmhlYWRlci5zaWduYXR1cmUgPSBzaWduTWVzc2FnZShcbiAgICAgICAgbWVzc2FnZUJ5dGVzLFxuICAgICAgICB0aGlzLmlkZW50aXR5LnByaXZhdGVLZXksXG4gICAgICApO1xuICAgICAgY29uc3QgZW5jb2RlZE1lc3NhZ2UgPSBlbmNvZGVNZXNzYWdlKG1lc3NhZ2UpO1xuXG4gICAgICB0aGlzLnJvdXRpbmdUYWJsZS5nZXRBbGxQZWVycygpLmZvckVhY2goKHBlZXIpID0+IHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHBlZXIuc3RhdGUgPT09IFBlZXJTdGF0ZS5DT05ORUNURUQgfHxcbiAgICAgICAgICBwZWVyLnN0YXRlID09PSBQZWVyU3RhdGUuREVHUkFERURcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGhpcy50cmFuc3BvcnRNYW5hZ2VyLnNlbmQocGVlci5pZCwgZW5jb2RlZE1lc3NhZ2UpLmNhdGNoKCgpID0+IHt9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1tNZXNoTmV0d29ya10gYnJvYWRjYXN0UGluZyBmYWlsZWQ6JywgZXJyb3IpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgc2VuZFBvbmcoXG4gICAgcmVjaXBpZW50UHVibGljS2V5OiBVaW50OEFycmF5LFxuICAgIHBpbmdUaW1lc3RhbXA6IG51bWJlcixcbiAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgcmVjaXBpZW50SWQgPSBBcnJheS5mcm9tKHJlY2lwaWVudFB1YmxpY0tleSlcbiAgICAgIC5tYXAoKGIpID0+IGIudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsIFwiMFwiKSlcbiAgICAgIC5qb2luKFwiXCIpO1xuXG4gICAgLy8gRWNobyBiYWNrIHRoZSBwaW5nIHRpbWVzdGFtcFxuICAgIGNvbnN0IHBheWxvYWQgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoSlNPTi5zdHJpbmdpZnkoeyBwaW5nVGltZXN0YW1wIH0pKTtcblxuICAgIGNvbnN0IG1lc3NhZ2U6IE1lc3NhZ2UgPSB7XG4gICAgICBoZWFkZXI6IHtcbiAgICAgICAgdmVyc2lvbjogMHgwMSxcbiAgICAgICAgdHlwZTogTWVzc2FnZVR5cGUuQ09OVFJPTF9QT05HLFxuICAgICAgICB0dGw6IDEsXG4gICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgICAgc2VuZGVySWQ6IHRoaXMuaWRlbnRpdHkucHVibGljS2V5LFxuICAgICAgICBzaWduYXR1cmU6IG5ldyBVaW50OEFycmF5KDY0KSxcbiAgICAgIH0sXG4gICAgICBwYXlsb2FkOiBwYXlsb2FkLFxuICAgIH07XG5cbiAgICBjb25zdCBtZXNzYWdlQnl0ZXMgPSBlbmNvZGVNZXNzYWdlKG1lc3NhZ2UpO1xuICAgIG1lc3NhZ2UuaGVhZGVyLnNpZ25hdHVyZSA9IHNpZ25NZXNzYWdlKFxuICAgICAgbWVzc2FnZUJ5dGVzLFxuICAgICAgdGhpcy5pZGVudGl0eS5wcml2YXRlS2V5LFxuICAgICk7XG4gICAgY29uc3QgZW5jb2RlZE1lc3NhZ2UgPSBlbmNvZGVNZXNzYWdlKG1lc3NhZ2UpO1xuXG4gICAgdGhpcy50cmFuc3BvcnRNYW5hZ2VyLnNlbmQocmVjaXBpZW50SWQsIGVuY29kZWRNZXNzYWdlKS5jYXRjaCgoKSA9PiB7fSk7XG4gIH1cblxuICAvKipcbiAgICogTW9uaXRvciBjb25uZWN0aW9uIGhlYWx0aCBhbmQgaGFuZGxlIGRlZ3JhZGF0aW9uXG4gICAqL1xuICBwcml2YXRlIHBlZXJGYWlsdXJlQ291bnRzOiBNYXA8c3RyaW5nLCBudW1iZXI+ID0gbmV3IE1hcCgpO1xuXG4gIHByaXZhdGUgbW9uaXRvckNvbm5lY3Rpb25IZWFsdGgoKTogdm9pZCB7XG4gICAgdGhpcy5wZWVyTW9uaXRvcnMuZm9yRWFjaCgobW9uaXRvciwgcGVlcklkKSA9PiB7XG4gICAgICBsZXQgcXVhbGl0eSA9IG1vbml0b3IuZ2V0UXVhbGl0eSgpO1xuICAgICAgY29uc3QgcGVlciA9IHRoaXMucm91dGluZ1RhYmxlLmdldFBlZXIocGVlcklkKTtcblxuICAgICAgaWYgKCFwZWVyKSB7XG4gICAgICAgIHRoaXMucGVlck1vbml0b3JzLmRlbGV0ZShwZWVySWQpO1xuICAgICAgICB0aGlzLnBlZXJGYWlsdXJlQ291bnRzLmRlbGV0ZShwZWVySWQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGxhc3RTZWVuIGFzIGEgZmFsbGJhY2sgZm9yIHNpbGVuY2UgZGV0ZWN0aW9uXG4gICAgICBjb25zdCBsYXN0U2VlbkFnZSA9IERhdGUubm93KCkgLSBwZWVyLmxhc3RTZWVuO1xuICAgICAgaWYgKGxhc3RTZWVuQWdlID4gMzAwMDApIHtcbiAgICAgICAgLy8gMzAgc2Vjb25kcyBzaWxlbmNlXG4gICAgICAgIHF1YWxpdHkgPSBcIm9mZmxpbmVcIjtcbiAgICAgIH0gZWxzZSBpZiAobGFzdFNlZW5BZ2UgPiAxMDAwMCAmJiBxdWFsaXR5ICE9PSBcIm9mZmxpbmVcIikge1xuICAgICAgICAvLyAxMCBzZWNvbmRzIHNpbGVuY2VcbiAgICAgICAgcXVhbGl0eSA9IFwicG9vclwiO1xuICAgICAgfVxuXG4gICAgICAvLyBVcGRhdGUgcGVlciBzdGF0ZSBiYXNlZCBvbiBxdWFsaXR5XG4gICAgICBpZiAocXVhbGl0eSA9PT0gXCJwb29yXCIgJiYgcGVlci5zdGF0ZSA9PT0gUGVlclN0YXRlLkNPTk5FQ1RFRCkge1xuICAgICAgICBwZWVyLnN0YXRlID0gUGVlclN0YXRlLkRFR1JBREVEO1xuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgKHF1YWxpdHkgPT09IFwiZ29vZFwiIHx8IHF1YWxpdHkgPT09IFwiZXhjZWxsZW50XCIpICYmXG4gICAgICAgIHBlZXIuc3RhdGUgPT09IFBlZXJTdGF0ZS5ERUdSQURFRFxuICAgICAgKSB7XG4gICAgICAgIHBlZXIuc3RhdGUgPSBQZWVyU3RhdGUuQ09OTkVDVEVEO1xuICAgICAgICB0aGlzLnBlZXJGYWlsdXJlQ291bnRzLnNldChwZWVySWQsIDApO1xuICAgICAgfSBlbHNlIGlmIChxdWFsaXR5ID09PSBcIm9mZmxpbmVcIikge1xuICAgICAgICAvLyBUcmFjayBjb25zZWN1dGl2ZSBvZmZsaW5lIGNoZWNrc1xuICAgICAgICBjb25zdCBmYWlsdXJlcyA9ICh0aGlzLnBlZXJGYWlsdXJlQ291bnRzLmdldChwZWVySWQpIHx8IDApICsgMTtcbiAgICAgICAgdGhpcy5wZWVyRmFpbHVyZUNvdW50cy5zZXQocGVlcklkLCBmYWlsdXJlcyk7XG5cbiAgICAgICAgaWYgKGZhaWx1cmVzID49IDYpIHtcbiAgICAgICAgICAvLyB+MzAgc2Vjb25kcyBvZiBjb25zZWN1dGl2ZSBvZmZsaW5lIGNoZWNrc1xuICAgICAgICAgIHRoaXMuZGlzY29ubmVjdEZyb21QZWVyKHBlZXJJZCkuY2F0Y2goKGVycikgPT5cbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGRpc2Nvbm5lY3RpbmcgcGVlciAke3BlZXJJZH06YCwgZXJyKSxcbiAgICAgICAgICApO1xuICAgICAgICAgIHRoaXMucGVlckZhaWx1cmVDb3VudHMuZGVsZXRlKHBlZXJJZCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFJlc2V0IGZhaWx1cmUgY291bnQgaWYgaGVhbHRoeVxuICAgICAgICB0aGlzLnBlZXJGYWlsdXJlQ291bnRzLnNldChwZWVySWQsIDApO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbm5lY3QgdG8gYSBwZWVyIHZpYSBhdmFpbGFibGUgdHJhbnNwb3J0c1xuICAgKi9cbiAgYXN5bmMgY29ubmVjdFRvUGVlcihwZWVySWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnNvbGUubG9nKGBbTWVzaE5ldHdvcmtdIGNvbm5lY3RUb1BlZXIgY2FsbGVkIGZvciAke3BlZXJJZH1gKTtcblxuICAgIGlmICh0aGlzLnJvdXRpbmdUYWJsZS5nZXRBbGxQZWVycygpLmxlbmd0aCA+PSB0aGlzLm1heFBlZXJzKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIGBbTWVzaE5ldHdvcmtdIE1heCBwZWVycyByZWFjaGVkICgke3RoaXMubWF4UGVlcnN9KSwgY2Fubm90IGNvbm5lY3QgdG8gJHtwZWVySWR9YCxcbiAgICAgICk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNYXhpbXVtIG51bWJlciBvZiBwZWVycyByZWFjaGVkXCIpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIGFscmVhZHkgY29ubmVjdGVkXG4gICAgY29uc3QgZXhpc3RpbmdQZWVyID0gdGhpcy5yb3V0aW5nVGFibGUuZ2V0UGVlcihwZWVySWQpO1xuICAgIGlmIChleGlzdGluZ1BlZXIgJiYgZXhpc3RpbmdQZWVyLnN0YXRlID09PSBcImNvbm5lY3RlZFwiKSB7XG4gICAgICBjb25zb2xlLmxvZyhgW01lc2hOZXR3b3JrXSBBbHJlYWR5IGNvbm5lY3RlZCB0byAke3BlZXJJZH0sIHNraXBwaW5nYCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgd2VicnRjVHJhbnNwb3J0ID0gdGhpcy50cmFuc3BvcnRNYW5hZ2VyLmdldFRyYW5zcG9ydChcIndlYnJ0Y1wiKTtcbiAgICBpZiAod2VicnRjVHJhbnNwb3J0KSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IHdlYnJ0Y1RyYW5zcG9ydC5nZXRDb25uZWN0aW9uU3RhdGUocGVlcklkKTtcbiAgICAgIGlmIChzdGF0ZSA9PT0gXCJjb25uZWN0aW5nXCIgfHwgc3RhdGUgPT09IFwiY29ubmVjdGVkXCIpIHtcbiAgICAgICAgY29uc29sZS5sb2coYFtNZXNoTmV0d29ya10gQ29ubmVjdGlvbiB0byAke3BlZXJJZH0gaXMgYWxyZWFkeSBpbiBzdGF0ZTogJHtzdGF0ZX0sIHNraXBwaW5nYCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZyhcbiAgICAgIGBbTWVzaE5ldHdvcmtdIEluaXRpYXRpbmcgY29ubmVjdGlvbiB0byAke3BlZXJJZH0gdmlhIFdlYlJUQy4uLmAsXG4gICAgKTtcblxuICAgIC8vIFVzZSBUcmFuc3BvcnRNYW5hZ2VyIHRvIGNvbm5lY3RcbiAgICAvLyBDdXJyZW50bHkgZGVmYXVsdHMgdG8gV2ViUlRDIGFzIGl0J3MgdGhlIG9ubHkgcmVnaXN0ZXJlZCB0cmFuc3BvcnRcbiAgICAvLyBidXQgaW4gZnV0dXJlIHdpbGwgdHJ5IG11bHRpcGxlXG4gICAgcmV0dXJuIHRoaXMudHJhbnNwb3J0TWFuYWdlclxuICAgICAgLmNvbm5lY3QocGVlcklkLCBcIndlYnJ0Y1wiKVxuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICBgW01lc2hOZXR3b3JrXSBDb25uZWN0aW9uIGluaXRpYXRlZCB0byAke3BlZXJJZH0sIHdhaXRpbmcgZm9yIHNpZ25hbGluZy4uLmAsXG4gICAgICAgICk7XG4gICAgICB9KVxuICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgW01lc2hOZXR3b3JrXSBGYWlsZWQgdG8gY29ubmVjdCB0byAke3BlZXJJZH06YCwgZXJyKTtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIHBlZXIgY29ubmVjdGVkXG4gICAqL1xuICBwcml2YXRlIGhhbmRsZVBlZXJDb25uZWN0ZWQocGVlcklkOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAvLyBHZXQgdHJhbnNwb3J0IHR5cGUgLSBpZiBpdCdzIG5vdCBvbmUgb2YgdGhlIGtub3duIHR5cGVzLCBkZWZhdWx0IHRvIFwid2VicnRjXCJcbiAgICBjb25zdCB0cmFuc3BvcnROYW1lID0gdGhpcy53ZWJydGNUcmFuc3BvcnQubmFtZTtcbiAgICBjb25zdCB2YWxpZFRyYW5zcG9ydFR5cGVzID0gW1wid2VicnRjXCIsIFwiYmx1ZXRvb3RoXCIsIFwibG9jYWxcIl0gYXMgY29uc3Q7XG4gICAgY29uc3QgdHJhbnNwb3J0VHlwZSA9IHZhbGlkVHJhbnNwb3J0VHlwZXMuaW5jbHVkZXModHJhbnNwb3J0TmFtZSBhcyBhbnkpXG4gICAgICA/ICh0cmFuc3BvcnROYW1lIGFzIFwid2VicnRjXCIgfCBcImJsdWV0b290aFwiIHwgXCJsb2NhbFwiKVxuICAgICAgOiBcIndlYnJ0Y1wiOyAvLyBTYWZlIGRlZmF1bHQgZmFsbGJhY2tcblxuICAgIGNvbnN0IHBlZXIgPSBjcmVhdGVQZWVyKFxuICAgICAgcGVlcklkLFxuICAgICAgbmV3IFVpbnQ4QXJyYXkoMzIpLCAvLyBXb3VsZCBiZSBvYnRhaW5lZCBkdXJpbmcgaGFuZHNoYWtlXG4gICAgICB0cmFuc3BvcnRUeXBlLFxuICAgICk7XG5cbiAgICB0aGlzLnJvdXRpbmdUYWJsZS5hZGRQZWVyKHBlZXIpO1xuICAgIHRoaXMucGVlck1vbml0b3JzLnNldChwZWVySWQsIG5ldyBDb25uZWN0aW9uTW9uaXRvcigpKTsgLy8gU3RhcnQgbW9uaXRvcmluZ1xuICAgIHRoaXMucGVlckNvbm5lY3RlZExpc3RlbmVycy5mb3JFYWNoKChsaXN0ZW5lcikgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGlzdGVuZXIocGVlcklkKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGluIHBlZXIgY29ubmVjdGVkIGxpc3RlbmVyOlwiLCBlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFNlbmQgcGVlciBhbm5vdW5jZW1lbnRcbiAgICB0aGlzLnNlbmRQZWVyQW5ub3VuY2VtZW50KCk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIHBlZXIgZGlzY29ubmVjdGVkXG4gICAqL1xuICBwcml2YXRlIGhhbmRsZVBlZXJEaXNjb25uZWN0ZWQocGVlcklkOiBzdHJpbmcpOiB2b2lkIHtcbiAgICB0aGlzLnJvdXRpbmdUYWJsZS5yZW1vdmVQZWVyKHBlZXJJZCk7XG4gICAgdGhpcy5wZWVyTW9uaXRvcnMuZGVsZXRlKHBlZXJJZCk7IC8vIFN0b3AgbW9uaXRvcmluZ1xuICAgIHRoaXMucGVlckRpc2Nvbm5lY3RlZExpc3RlbmVycy5mb3JFYWNoKChsaXN0ZW5lcikgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGlzdGVuZXIocGVlcklkKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGluIHBlZXIgZGlzY29ubmVjdGVkIGxpc3RlbmVyOlwiLCBlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kIGEgdGV4dCBtZXNzYWdlIHdpdGggZW5oYW5jZWQgdmFsaWRhdGlvbiBhbmQgcmF0ZSBsaW1pdGluZ1xuICAgKi9cbiAgYXN5bmMgc2VuZE1lc3NhZ2UoXG4gICAgcmVjaXBpZW50SWQ6IHN0cmluZyxcbiAgICBjb250ZW50OiBzdHJpbmcsXG4gICAgdHlwZTogTWVzc2FnZVR5cGUgPSBNZXNzYWdlVHlwZS5URVhULFxuICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAvLyBOb3JtYWxpemUgcmVjaXBpZW50IElEIHRvIHVwcGVyY2FzZSBmb3IgY29uc2lzdGVudCBtYXRjaGluZ1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRSZWNpcGllbnRJZCA9IHJlY2lwaWVudElkLnJlcGxhY2UoL1xccy9nLCBcIlwiKS50b1VwcGVyQ2FzZSgpO1xuICAgIFxuICAgIGNvbnNvbGUubG9nKFxuICAgICAgYFtNZXNoTmV0d29ya10gc2VuZE1lc3NhZ2UgdG8gJHtub3JtYWxpemVkUmVjaXBpZW50SWR9LCB0eXBlPSR7TWVzc2FnZVR5cGVbdHlwZV19YCxcbiAgICApO1xuXG4gICAgLy8gVmFsaWRhdGUgbWVzc2FnZSBzaXplIGZvciBzY2FsaW5nXG4gICAgY29uc3QgY29udGVudFNpemUgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoY29udGVudCkubGVuZ3RoO1xuICAgIGlmIChjb250ZW50U2l6ZSA+IHRoaXMubWF4TWVzc2FnZVNpemUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTWVzc2FnZSBzaXplICR7Y29udGVudFNpemV9IGV4Y2VlZHMgbWF4aW11bSAke3RoaXMubWF4TWVzc2FnZVNpemV9IGJ5dGVzYCk7XG4gICAgfVxuXG4gICAgY29uc3QgcGF5bG9hZCA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShcbiAgICAgIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgdGV4dDogY29udGVudCxcbiAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgICByZWNpcGllbnQ6IG5vcm1hbGl6ZWRSZWNpcGllbnRJZCxcbiAgICAgIH0pLFxuICAgICk7XG5cbiAgICBjb25zdCBtZXNzYWdlOiBNZXNzYWdlID0ge1xuICAgICAgaGVhZGVyOiB7XG4gICAgICAgIHZlcnNpb246IDB4MDEsXG4gICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgIHR0bDogdGhpcy5kZWZhdWx0VFRMLFxuICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICAgIHNlbmRlcklkOiB0aGlzLmlkZW50aXR5LnB1YmxpY0tleSxcbiAgICAgICAgc2lnbmF0dXJlOiBuZXcgVWludDhBcnJheSg2NCksIC8vIFBsYWNlaG9sZGVyXG4gICAgICB9LFxuICAgICAgcGF5bG9hZCxcbiAgICB9O1xuXG4gICAgLy8gU2lnbiB0aGUgbWVzc2FnZVxuICAgIGNvbnN0IG1lc3NhZ2VCeXRlcyA9IGVuY29kZU1lc3NhZ2UobWVzc2FnZSk7XG4gICAgbWVzc2FnZS5oZWFkZXIuc2lnbmF0dXJlID0gc2lnbk1lc3NhZ2UoXG4gICAgICBtZXNzYWdlQnl0ZXMsXG4gICAgICB0aGlzLmlkZW50aXR5LnByaXZhdGVLZXksXG4gICAgKTtcblxuICAgIC8vIFNlbmQgdmlhIG1lc2hcbiAgICBjb25zdCBlbmNvZGVkTWVzc2FnZSA9IGVuY29kZU1lc3NhZ2UobWVzc2FnZSk7XG4gICAgY29uc3QgbmV4dEhvcCA9IHRoaXMucm91dGluZ1RhYmxlLmdldE5leHRIb3Aobm9ybWFsaXplZFJlY2lwaWVudElkKTtcblxuICAgIGNvbnNvbGUubG9nKFxuICAgICAgYFtNZXNoTmV0d29ya10gUm91dGUgbG9va3VwIGZvciAke25vcm1hbGl6ZWRSZWNpcGllbnRJZH06IG5leHRIb3A9JHtuZXh0SG9wIHx8IFwibm9uZVwifSwgY29ubmVjdGVkUGVlcnM9JHt0aGlzLnJvdXRpbmdUYWJsZS5nZXRBbGxQZWVycygpLmZpbHRlcigocCkgPT4gcC5zdGF0ZSA9PT0gXCJjb25uZWN0ZWRcIikubGVuZ3RofWAsXG4gICAgKTtcblxuICAgIGlmIChuZXh0SG9wKSB7XG4gICAgICAvLyBEaXJlY3Qgcm91dGUgYXZhaWxhYmxlXG4gICAgICBjb25zb2xlLmxvZyhgW01lc2hOZXR3b3JrXSBTZW5kaW5nIGRpcmVjdGx5IHRvIG5leHRIb3A9JHtuZXh0SG9wfWApO1xuICAgICAgdGhpcy50cmFuc3BvcnRNYW5hZ2VyLnNlbmQobmV4dEhvcCwgZW5jb2RlZE1lc3NhZ2UpLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBgW01lc2hOZXR3b3JrXSBGYWlsZWQgdG8gc2VuZCB0byBuZXh0IGhvcCAke25leHRIb3B9OmAsXG4gICAgICAgICAgZXJyLFxuICAgICAgICApO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENoZWNrIGlmIHdlIGhhdmUgYW55IGNvbm5lY3RlZCBwZWVycyBhdCBhbGxcbiAgICAgIGNvbnN0IGNvbm5lY3RlZFBlZXJzID0gdGhpcy5yb3V0aW5nVGFibGVcbiAgICAgICAgLmdldEFsbFBlZXJzKClcbiAgICAgICAgLmZpbHRlcigocCkgPT4gcC5zdGF0ZSA9PT0gXCJjb25uZWN0ZWRcIiAmJiBwLmlkICE9PSB0aGlzLmxvY2FsUGVlcklkKTtcblxuICAgICAgY29uc29sZS5sb2coXG4gICAgICAgIGBbTWVzaE5ldHdvcmtdIE5vIGRpcmVjdCByb3V0ZS4gQ29ubmVjdGVkIHBlZXJzOiAke2Nvbm5lY3RlZFBlZXJzLmxlbmd0aH1gLFxuICAgICAgKTtcblxuICAgICAgaWYgKGNvbm5lY3RlZFBlZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgYFtNZXNoTmV0d29ya10gTm8gY29ubmVjdGVkIHBlZXJzISBVc2luZyBzbmVha2VybmV0IHN0b3JhZ2UgZm9yICR7cmVjaXBpZW50SWR9LmAsXG4gICAgICAgICk7XG4gICAgICAgIFxuICAgICAgICAvLyBTTkVBS0VSTkVUOiBTdG9yZSBtZXNzYWdlIGZvciBsYXRlciBkZWxpdmVyeSB2aWEgYW55IGF2YWlsYWJsZSBwZWVyXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgdGhpcy5tZXNzYWdlUmVsYXkuc3RvcmVNZXNzYWdlKG1lc3NhZ2UsIG5vcm1hbGl6ZWRSZWNpcGllbnRJZCk7XG4gICAgICAgICAgY29uc29sZS5sb2coYFtNZXNoTmV0d29ya10g8J+TpiBNZXNzYWdlIHN0b3JlZCBmb3Igc25lYWtlcm5ldCBkZWxpdmVyeSB0byAke3JlY2lwaWVudElkfWApO1xuICAgICAgICAgIHRoaXMubWVzc2FnZXNTdG9yZWQrKztcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGBbTWVzaE5ldHdvcmtdIEZhaWxlZCB0byBzdG9yZSBtZXNzYWdlIGZvciAke3JlY2lwaWVudElkfTpgLCBlcnJvcik7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBjb25uZWN0ZWQgcGVlcnMgYW5kIGZhaWxlZCB0byBzdG9yZSBtZXNzYWdlOiAke2Vycm9yfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gQXR0ZW1wdCBESFQgbG9va3VwIGlmIG5vIGNhbmRpZGF0ZXMgZm91bmRcbiAgICAgIGNvbnN0IGNhbmRpZGF0ZXMgPSB0aGlzLnJvdXRpbmdUYWJsZS5nZXRSYW5rZWRQZWVyc0ZvclRhcmdldChyZWNpcGllbnRJZCk7XG5cbiAgICAgIGNvbnN0IGNvbm5lY3RlZENhbmRpZGF0ZXMgPSBjYW5kaWRhdGVzLmZpbHRlcihcbiAgICAgICAgKHApID0+IHAuc3RhdGUgPT09IFwiY29ubmVjdGVkXCIgJiYgcC5pZCAhPT0gdGhpcy5sb2NhbFBlZXJJZCxcbiAgICAgICk7XG5cbiAgICAgIGlmIChjb25uZWN0ZWRDYW5kaWRhdGVzLmxlbmd0aCA9PT0gMCAmJiB0aGlzLmRodCkge1xuICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICBgW01lc2hOZXR3b3JrXSBObyBrbm93biBwYXRoIHRvICR7cmVjaXBpZW50SWR9LCBhdHRlbXB0aW5nIERIVCBsb29rdXAuLi5gLFxuICAgICAgICApO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGZvdW5kUGVlcnMgPSBhd2FpdCB0aGlzLmRodC5maW5kTm9kZShyZWNpcGllbnRJZCk7XG4gICAgICAgICAgY29uc3QgdGFyZ2V0UGVlciA9IGZvdW5kUGVlcnMuZmluZCgocCkgPT4gcC5pZCA9PT0gcmVjaXBpZW50SWQpO1xuICAgICAgICAgIGlmICh0YXJnZXRQZWVyKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICAgYFtNZXNoTmV0d29ya10gRm91bmQgJHtyZWNpcGllbnRJZH0gaW4gREhULCBhdHRlbXB0aW5nIGNvbm5lY3Rpb24uLi5gLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuY29ubmVjdFRvUGVlcihyZWNpcGllbnRJZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKGBbTWVzaE5ldHdvcmtdIERIVCBsb29rdXAgZmFpbGVkIGZvciAke3JlY2lwaWVudElkfWAsIGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICBgW01lc2hOZXR3b3JrXSBObyBkaXJlY3Qgcm91dGUgdG8gJHtyZWNpcGllbnRJZH0sIGluaXRpYXRpbmcgU21hcnQgRmxvb2QuLi5gLFxuICAgICAgKTtcblxuICAgICAgLy8gRmxvb2QgRmFsbGJhY2sgdmlhIFRyYW5zcG9ydE1hbmFnZXJcbiAgICAgIHRoaXMucm91dGluZ1RhYmxlLmdldEFsbFBlZXJzKCkuZm9yRWFjaCgocGVlcikgPT4ge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgcGVlci5zdGF0ZSA9PT0gUGVlclN0YXRlLkNPTk5FQ1RFRCAmJlxuICAgICAgICAgIHBlZXIuaWQgIT09IHRoaXMubG9jYWxQZWVySWRcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGhpcy50cmFuc3BvcnRNYW5hZ2VyLnNlbmQocGVlci5pZCwgZW5jb2RlZE1lc3NhZ2UpLmNhdGNoKCgpID0+IHt9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgcGVlciBhbm5vdW5jZW1lbnQgdG8gbWVzaFxuICAgKi9cbiAgcHJpdmF0ZSBzZW5kUGVlckFubm91bmNlbWVudCgpOiB2b2lkIHtcbiAgICBjb25zdCBwYXlsb2FkID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKFxuICAgICAgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICBwdWJsaWNLZXk6IEFycmF5LmZyb20odGhpcy5pZGVudGl0eS5wdWJsaWNLZXkpXG4gICAgICAgICAgLm1hcCgoYjogbnVtYmVyKSA9PiBiLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCBcIjBcIikpXG4gICAgICAgICAgLmpvaW4oXCJcIiksXG4gICAgICAgIGVuZHBvaW50czogW3sgdHlwZTogXCJ3ZWJydGNcIiwgc2lnbmFsaW5nOiB0aGlzLmxvY2FsUGVlcklkIH1dLFxuICAgICAgICBjYXBhYmlsaXRpZXM6IHtcbiAgICAgICAgICBzdXBwb3J0ZWRUcmFuc3BvcnRzOiBbXCJ3ZWJydGNcIl0sXG4gICAgICAgICAgcHJvdG9jb2xWZXJzaW9uOiAxLFxuICAgICAgICB9LFxuICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICB9KSxcbiAgICApO1xuXG4gICAgY29uc3QgbWVzc2FnZTogTWVzc2FnZSA9IHtcbiAgICAgIGhlYWRlcjoge1xuICAgICAgICB2ZXJzaW9uOiAweDAxLFxuICAgICAgICB0eXBlOiBNZXNzYWdlVHlwZS5QRUVSX0RJU0NPVkVSWSxcbiAgICAgICAgdHRsOiB0aGlzLmRlZmF1bHRUVEwsXG4gICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgICAgc2VuZGVySWQ6IHRoaXMuaWRlbnRpdHkucHVibGljS2V5LFxuICAgICAgICBzaWduYXR1cmU6IG5ldyBVaW50OEFycmF5KDY0KSxcbiAgICAgIH0sXG4gICAgICBwYXlsb2FkLFxuICAgIH07XG5cbiAgICAvLyBTaWduIGFuZCBicm9hZGNhc3RcbiAgICBjb25zdCBtZXNzYWdlQnl0ZXMgPSBlbmNvZGVNZXNzYWdlKG1lc3NhZ2UpO1xuICAgIG1lc3NhZ2UuaGVhZGVyLnNpZ25hdHVyZSA9IHNpZ25NZXNzYWdlKFxuICAgICAgbWVzc2FnZUJ5dGVzLFxuICAgICAgdGhpcy5pZGVudGl0eS5wcml2YXRlS2V5LFxuICAgICk7XG4gICAgY29uc3QgZW5jb2RlZE1lc3NhZ2UgPSBlbmNvZGVNZXNzYWdlKG1lc3NhZ2UpO1xuXG4gICAgLy8gQnJvYWRjYXN0IHZpYSByb3V0aW5nIHRhYmxlXG4gICAgdGhpcy5yb3V0aW5nVGFibGUuZ2V0QWxsUGVlcnMoKS5mb3JFYWNoKChwZWVyKSA9PiB7XG4gICAgICBpZiAocGVlci5zdGF0ZSA9PT0gUGVlclN0YXRlLkNPTk5FQ1RFRCkge1xuICAgICAgICB0aGlzLnRyYW5zcG9ydE1hbmFnZXIuc2VuZChwZWVyLmlkLCBlbmNvZGVkTWVzc2FnZSkuY2F0Y2goKCkgPT4ge30pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cblxuXG4gIG9uTWVzc2FnZShjYWxsYmFjazogKG1lc3NhZ2U6IE1lc3NhZ2UpID0+IHZvaWQpOiB2b2lkIHtcbiAgICB0aGlzLm1lc3NhZ2VMaXN0ZW5lcnMuYWRkKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnJlZ2lzdGVyIGNhbGxiYWNrIGZvciBpbmNvbWluZyBtZXNzYWdlc1xuICAgKi9cbiAgb2ZmTWVzc2FnZShjYWxsYmFjazogKG1lc3NhZ2U6IE1lc3NhZ2UpID0+IHZvaWQpOiB2b2lkIHtcbiAgICB0aGlzLm1lc3NhZ2VMaXN0ZW5lcnMuZGVsZXRlKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIGRpc2NvdmVyeSBwcm92aWRlclxuICAgKi9cbiAgcmVnaXN0ZXJEaXNjb3ZlcnlQcm92aWRlcihwcm92aWRlcjogRGlzY292ZXJ5UHJvdmlkZXIpOiB2b2lkIHtcbiAgICB0aGlzLmRpc2NvdmVyeS5yZWdpc3RlclByb3ZpZGVyKHByb3ZpZGVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgZGlzY292ZXJlZCBwZWVyXG4gICAqL1xuICBwcml2YXRlIGhhbmRsZURpc2NvdmVyZWRQZWVyKHBlZXI6IERpc2NvdmVyeVBlZXIpOiB2b2lkIHtcbiAgICBjb25zdCBwZWVySWQgPSBwZWVyLmlkO1xuICAgIGlmIChwZWVySWQgPT09IHRoaXMubG9jYWxQZWVySWQpIHJldHVybjtcblxuICAgIGlmICghdGhpcy5kaXNjb3ZlcmVkUGVlcnMuaGFzKHBlZXJJZCkpIHtcbiAgICAgIHRoaXMuZGlzY292ZXJlZFBlZXJzLmFkZChwZWVySWQpO1xuICAgICAgY29uc29sZS5sb2coYERpc2NvdmVyZWQgbmV3IHBlZXIgJHtwZWVySWR9IHZpYSAke3BlZXIuc291cmNlfWApO1xuXG4gICAgICAvLyBBdHRlbXB0IHRvIGNvbm5lY3QgaWYgd2UgaGF2ZSBjYXBhY2l0eVxuICAgICAgaWYgKHRoaXMucm91dGluZ1RhYmxlLmdldEFsbFBlZXJzKCkubGVuZ3RoIDwgdGhpcy5tYXhQZWVycykge1xuICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICBgRGlzY292ZXJlZCBuZXcgcGVlciAke3BlZXIuaWR9IHZpYSAke3BlZXIuc291cmNlfS4gQXR0ZW1wdGluZyBjb25uZWN0aW9uLi4uYCxcbiAgICAgICAgKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChwZWVyLnRyYW5zcG9ydFR5cGUgPT09IFwiYmxlXCIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgICBgW01lc2hOZXR3b3JrXSBCTEUgcGVlciBkaXNjb3ZlcmVkLiBOYXRpdmUgYnJpZGdlIHJlcXVpcmVkIHRvIGNvbm5lY3QgdG8gJHtwZWVyLmlkfWAsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgLy8gSW4gYSByZWFsIGltcGxlbWVudGF0aW9uOiBCcmlkZ2UuY29ubmVjdChwZWVyLmlkLCBwZWVyLmNvbm5lY3Rpb25EZXRhaWxzKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBEZWZhdWx0IHRvIFdlYlJUQyAvIHN0YW5kYXJkIGNvbm5lY3Rpb25cbiAgICAgICAgICAgIHRoaXMuY29ubmVjdFRvUGVlcihwZWVyLmlkKS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgICBgRmFpbGVkIHRvIGF1dG8tY29ubmVjdCB0byBkaXNjb3ZlcmVkIHBlZXIgJHtwZWVySWR9OmAsXG4gICAgICAgICAgICAgICAgZXJyLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIGNvbm5lY3QgdG8gZGlzY292ZXJlZCBwZWVyICR7cGVlci5pZH06YCwgZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBOb3RpZnkgbGlzdGVuZXJzXG4gICAgdGhpcy5kaXNjb3ZlcnlVcGRhdGVMaXN0ZW5lcnMuZm9yRWFjaCgobGlzdGVuZXIpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxpc3RlbmVyKEFycmF5LmZyb20odGhpcy5kaXNjb3ZlcmVkUGVlcnMpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGluIGRpc2NvdmVyeSB1cGRhdGUgbGlzdGVuZXI6XCIsIGUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGNhbGxiYWNrIGZvciBwZWVyIGNvbm5lY3RlZCBldmVudHNcbiAgICovXG4gIG9uUGVlckNvbm5lY3RlZChjYWxsYmFjazogKHBlZXJJZDogc3RyaW5nKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdGhpcy5wZWVyQ29ubmVjdGVkTGlzdGVuZXJzLmFkZChjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogVW5yZWdpc3RlciBjYWxsYmFjayBmb3IgcGVlciBjb25uZWN0ZWQgZXZlbnRzXG4gICAqL1xuICBvZmZQZWVyQ29ubmVjdGVkKGNhbGxiYWNrOiAocGVlcklkOiBzdHJpbmcpID0+IHZvaWQpOiB2b2lkIHtcbiAgICB0aGlzLnBlZXJDb25uZWN0ZWRMaXN0ZW5lcnMuZGVsZXRlKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBjYWxsYmFjayBmb3IgcGVlciBkaXNjb25uZWN0ZWQgZXZlbnRzXG4gICAqL1xuICBvblBlZXJEaXNjb25uZWN0ZWQoY2FsbGJhY2s6IChwZWVySWQ6IHN0cmluZykgPT4gdm9pZCk6IHZvaWQge1xuICAgIHRoaXMucGVlckRpc2Nvbm5lY3RlZExpc3RlbmVycy5hZGQoY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIFVucmVnaXN0ZXIgY2FsbGJhY2sgZm9yIHBlZXIgZGlzY29ubmVjdGVkIGV2ZW50c1xuICAgKi9cbiAgb2ZmUGVlckRpc2Nvbm5lY3RlZChjYWxsYmFjazogKHBlZXJJZDogc3RyaW5nKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdGhpcy5wZWVyRGlzY29ubmVjdGVkTGlzdGVuZXJzLmRlbGV0ZShjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXIgY2FsbGJhY2sgZm9yIGluY29taW5nIHBlZXIgdHJhY2tzXG4gICAqL1xuICAvKipcbiAgICogUmVnaXN0ZXIgY2FsbGJhY2sgZm9yIGluY29taW5nIHBlZXIgdHJhY2tzXG4gICAqL1xuICBvblBlZXJUcmFjayhcbiAgICBjYWxsYmFjazogKFxuICAgICAgcGVlcklkOiBzdHJpbmcsXG4gICAgICB0cmFjazogTWVkaWFTdHJlYW1UcmFjayxcbiAgICAgIHN0cmVhbTogTWVkaWFTdHJlYW0sXG4gICAgKSA9PiB2b2lkLFxuICApOiB2b2lkIHtcbiAgICB0aGlzLnBlZXJUcmFja0xpc3RlbmVycy5hZGQoY2FsbGJhY2spO1xuICB9XG5cbiAgb2ZmUGVlclRyYWNrKFxuICAgIGNhbGxiYWNrOiAoXG4gICAgICBwZWVySWQ6IHN0cmluZyxcbiAgICAgIHRyYWNrOiBNZWRpYVN0cmVhbVRyYWNrLFxuICAgICAgc3RyZWFtOiBNZWRpYVN0cmVhbSxcbiAgICApID0+IHZvaWQsXG4gICk6IHZvaWQge1xuICAgIHRoaXMucGVlclRyYWNrTGlzdGVuZXJzLmRlbGV0ZShjYWxsYmFjayk7XG4gIH1cblxuICAvLyAtLS0gQmxvYiBIYW5kbGVycyAtLS1cblxuICBwcml2YXRlIGFzeW5jIGhhbmRsZUJsb2JNZXNzYWdlKG1lc3NhZ2U6IE1lc3NhZ2UpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAvLyBOb3JtYWxpemUgc2VuZGVyIElEIHRvIDE2LWNoYXIgdXBwZXJjYXNlIGZvcm1hdFxuICAgIGNvbnN0IHNlbmRlcklkID0gYnl0ZXNUb0hleChtZXNzYWdlLmhlYWRlci5zZW5kZXJJZCkuc3Vic3RyaW5nKDAsIDE2KS50b1VwcGVyQ2FzZSgpO1xuXG4gICAgaWYgKG1lc3NhZ2UuaGVhZGVyLnR5cGUgPT09IE1lc3NhZ2VUeXBlLlJFUVVFU1RfQkxPQikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2UobmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKG1lc3NhZ2UucGF5bG9hZCkpO1xuICAgICAgICBjb25zdCB7IGhhc2gsIHJlcXVlc3RJZCB9ID0gZGF0YTtcblxuICAgICAgICBjb25zdCBibG9iID0gYXdhaXQgdGhpcy5ibG9iU3RvcmUuZ2V0KGhhc2gpO1xuICAgICAgICBpZiAoYmxvYikge1xuICAgICAgICAgIC8vIFNlbmQgUmVzcG9uc2VcbiAgICAgICAgICBjb25zdCBwYXlsb2FkID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKFxuICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICBoYXNoLFxuICAgICAgICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgICAgICAgIGJsb2I6IGJ5dGVzVG9CYXNlNjQoYmxvYiksXG4gICAgICAgICAgICAgIHJlY2lwaWVudDogc2VuZGVySWQsIC8vIEFkZCByZWNpcGllbnQgZm9yIHJlbGF5IHJvdXRpbmdcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICk7XG5cbiAgICAgICAgICBjb25zdCByZXNwb25zZU1zZzogTWVzc2FnZSA9IHtcbiAgICAgICAgICAgIGhlYWRlcjoge1xuICAgICAgICAgICAgICB2ZXJzaW9uOiAweDAxLFxuICAgICAgICAgICAgICB0eXBlOiBNZXNzYWdlVHlwZS5SRVNQT05TRV9CTE9CLFxuICAgICAgICAgICAgICB0dGw6IHRoaXMuZGVmYXVsdFRUTCxcbiAgICAgICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgICBzZW5kZXJJZDogdGhpcy5pZGVudGl0eS5wdWJsaWNLZXksXG4gICAgICAgICAgICAgIHNpZ25hdHVyZTogbmV3IFVpbnQ4QXJyYXkoNjQpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBheWxvYWQsXG4gICAgICAgICAgfTtcbiAgICAgICAgICBjb25zdCBtc2dCeXRlcyA9IGVuY29kZU1lc3NhZ2UocmVzcG9uc2VNc2cpO1xuICAgICAgICAgIHJlc3BvbnNlTXNnLmhlYWRlci5zaWduYXR1cmUgPSBzaWduTWVzc2FnZShcbiAgICAgICAgICAgIG1zZ0J5dGVzLFxuICAgICAgICAgICAgdGhpcy5pZGVudGl0eS5wcml2YXRlS2V5LFxuICAgICAgICAgICk7XG4gICAgICAgICAgY29uc3QgZW5jb2RlZCA9IGVuY29kZU1lc3NhZ2UocmVzcG9uc2VNc2cpO1xuXG4gICAgICAgICAgYXdhaXQgdGhpcy50cmFuc3BvcnRNYW5hZ2VyLnNlbmQoc2VuZGVySWQsIGVuY29kZWQpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBoYW5kbGluZyBSRVFVRVNUX0JMT0JcIiwgZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtZXNzYWdlLmhlYWRlci50eXBlID09PSBNZXNzYWdlVHlwZS5SRVNQT05TRV9CTE9CKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUobWVzc2FnZS5wYXlsb2FkKSk7XG4gICAgICAgIGNvbnN0IHsgaGFzaDogX2hhc2gsIHJlcXVlc3RJZCwgYmxvYiB9ID0gZGF0YTtcblxuICAgICAgICBjb25zdCBwZW5kaW5nID0gdGhpcy5wZW5kaW5nQmxvYlJlcXVlc3RzLmdldChyZXF1ZXN0SWQpO1xuICAgICAgICBpZiAocGVuZGluZykge1xuICAgICAgICAgIGNvbnN0IGJsb2JCdWZmZXIgPSBiYXNlNjRUb0J5dGVzKGJsb2IpO1xuICAgICAgICAgIC8vIFZlcmlmeSBoYXNoPyBJZGVhbGx5IHllcy5cbiAgICAgICAgICBwZW5kaW5nLnJlc29sdmUoYmxvYkJ1ZmZlcik7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHBlbmRpbmcudGltZW91dCk7XG4gICAgICAgICAgdGhpcy5wZW5kaW5nQmxvYlJlcXVlc3RzLmRlbGV0ZShyZXF1ZXN0SWQpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBwcm9jZXNzaW5nIFJFU1BPTlNFX0JMT0JcIiwgZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlcXVlc3QgYSBibG9iIGZyb20gYSBzcGVjaWZpYyBwZWVyXG4gICAqL1xuICBhc3luYyByZXF1ZXN0QmxvYihcbiAgICBwZWVySWQ6IHN0cmluZyxcbiAgICBoYXNoOiBzdHJpbmcsXG4gICAgdGltZW91dE1zOiBudW1iZXIgPSA1MDAwLFxuICApOiBQcm9taXNlPFVpbnQ4QXJyYXkgfCBudWxsPiB7XG4gICAgY29uc3QgcmVxdWVzdElkID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDcpO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlPFVpbnQ4QXJyYXkgfCBudWxsPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMucGVuZGluZ0Jsb2JSZXF1ZXN0cy5kZWxldGUocmVxdWVzdElkKTtcbiAgICAgICAgLy8gRG9uJ3QgcmVqZWN0LCBqdXN0IHJldHVybiBudWxsIGlmIG5vdCBmb3VuZC90aW1lZCBvdXQ/IE9yIHJlamVjdC5cbiAgICAgICAgLy8gRm9yIGEgREhUL0NvbnRlbnQgZmV0Y2gsIG51bGwgbWlnaHQgYmUgYmV0dGVyIGlmIGp1c3QgXCJub3QgZm91bmQgaGVyZVwiLlxuICAgICAgICAvLyBCdXQgZXhwbGljaXQgdGltZW91dCBpcyB1c2VmdWwuXG4gICAgICAgIHJlc29sdmUobnVsbCk7XG4gICAgICB9LCB0aW1lb3V0TXMpO1xuXG4gICAgICB0aGlzLnBlbmRpbmdCbG9iUmVxdWVzdHMuc2V0KHJlcXVlc3RJZCwgeyByZXNvbHZlLCByZWplY3QsIHRpbWVvdXQgfSk7XG5cbiAgICAgIGNvbnN0IHBheWxvYWQgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoXG4gICAgICAgIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBoYXNoLFxuICAgICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgfSksXG4gICAgICApO1xuXG4gICAgICBjb25zdCBtZXNzYWdlOiBNZXNzYWdlID0ge1xuICAgICAgICBoZWFkZXI6IHtcbiAgICAgICAgICB2ZXJzaW9uOiAweDAxLFxuICAgICAgICAgIHR5cGU6IE1lc3NhZ2VUeXBlLlJFUVVFU1RfQkxPQixcbiAgICAgICAgICB0dGw6IHRoaXMuZGVmYXVsdFRUTCxcbiAgICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICAgICAgc2VuZGVySWQ6IHRoaXMuaWRlbnRpdHkucHVibGljS2V5LFxuICAgICAgICAgIHNpZ25hdHVyZTogbmV3IFVpbnQ4QXJyYXkoNjQpLFxuICAgICAgICB9LFxuICAgICAgICBwYXlsb2FkLFxuICAgICAgfTtcblxuICAgICAgY29uc3QgbXNnQnl0ZXMgPSBlbmNvZGVNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgbWVzc2FnZS5oZWFkZXIuc2lnbmF0dXJlID0gc2lnbk1lc3NhZ2UoXG4gICAgICAgIG1zZ0J5dGVzLFxuICAgICAgICB0aGlzLmlkZW50aXR5LnByaXZhdGVLZXksXG4gICAgICApO1xuICAgICAgY29uc3QgZW5jb2RlZCA9IGVuY29kZU1lc3NhZ2UobWVzc2FnZSk7XG5cbiAgICAgIHRoaXMudHJhbnNwb3J0TWFuYWdlci5zZW5kKHBlZXJJZCwgZW5jb2RlZCkuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICB0aGlzLnBlbmRpbmdCbG9iUmVxdWVzdHMuZGVsZXRlKHJlcXVlc3RJZCk7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGNhbGxiYWNrIGZvciBkaXNjb3ZlcnkgdXBkYXRlc1xuICAgKi9cbiAgb25EaXNjb3ZlcnlVcGRhdGUoY2FsbGJhY2s6IChwZWVyczogc3RyaW5nW10pID0+IHZvaWQpOiB2b2lkIHtcbiAgICB0aGlzLmRpc2NvdmVyeVVwZGF0ZUxpc3RlbmVycy5hZGQoY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIFVucmVnaXN0ZXIgY2FsbGJhY2sgZm9yIGRpc2NvdmVyeSB1cGRhdGVzXG4gICAqL1xuICBvZmZEaXNjb3ZlcnlVcGRhdGUoY2FsbGJhY2s6IChwZWVyczogc3RyaW5nW10pID0+IHZvaWQpOiB2b2lkIHtcbiAgICB0aGlzLmRpc2NvdmVyeVVwZGF0ZUxpc3RlbmVycy5kZWxldGUoY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBtZWRpYSBzdHJlYW0gdG8gcGVlciBjb25uZWN0aW9uXG4gICAqL1xuICBhc3luYyBhZGRTdHJlYW1Ub1BlZXIocGVlcklkOiBzdHJpbmcsIHN0cmVhbTogTWVkaWFTdHJlYW0pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBwZWVyID0gdGhpcy53ZWJydGNUcmFuc3BvcnQuZ2V0UG9vbCgpLmdldFBlZXIocGVlcklkKTtcbiAgICBpZiAoIXBlZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgUGVlciAke3BlZXJJZH0gbm90IGZvdW5kYCk7XG4gICAgfVxuXG4gICAgc3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2goKHRyYWNrKSA9PiB7XG4gICAgICBwZWVyLmFkZFRyYWNrKHRyYWNrLCBzdHJlYW0pO1xuICAgIH0pO1xuXG4gICAgLy8gSWYgY29ubmVjdGlvbiBpcyBhbHJlYWR5IGVzdGFibGlzaGVkLCB3ZSBtaWdodCBuZWVkIHRvIHJlbmVnb3RpYXRlXG4gICAgLy8gQnV0IGZvciBub3csIHdlIGFzc3VtZSB0aGlzIGlzIGNhbGxlZCBiZWZvcmUgb3IgZHVyaW5nIGNvbm5lY3Rpb24gc2V0dXBcbiAgICAvLyBPciB0aGF0IHRoZSBicm93c2VyIGhhbmRsZXMgcmVuZWdvdGlhdGlvbiAod2hpY2ggcmVxdWlyZXMgc2VuZGluZyBhIG5ldyBvZmZlcilcblxuICAgIC8vIFRyaWdnZXIgcmVuZWdvdGlhdGlvbiBpZiBjb25uZWN0ZWRcbiAgICBpZiAocGVlci5nZXRTdGF0ZSgpID09PSBcImNvbm5lY3RlZFwiKSB7XG4gICAgICBjb25zdCBvZmZlciA9IGF3YWl0IHBlZXIuY3JlYXRlT2ZmZXIoKTtcbiAgICAgIGF3YWl0IHRoaXMuc2VuZE1lc3NhZ2UoXG4gICAgICAgIHBlZXJJZCxcbiAgICAgICAgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIHR5cGU6IFwiU0lHTkFMXCIsXG4gICAgICAgICAgc2lnbmFsOiB7IHR5cGU6IFwib2ZmZXJcIiwgc2RwOiBvZmZlciB9LFxuICAgICAgICB9KSxcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBjb25uZWN0ZWQgcGVlcnNcbiAgICovXG4gIGdldENvbm5lY3RlZFBlZXJzKCk6IFBlZXJbXSB7XG4gICAgcmV0dXJuIHRoaXMucm91dGluZ1RhYmxlLmdldEFsbFBlZXJzKCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgc3BlY2lmaWMgcGVlciBieSBJRFxuICAgKi9cbiAgZ2V0UGVlcihwZWVySWQ6IHN0cmluZyk6IFBlZXIgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLnJvdXRpbmdUYWJsZS5nZXRQZWVyKHBlZXJJZCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGNvbXByZWhlbnNpdmUgbmV0d29yayBzdGF0aXN0aWNzIGZvciBtb25pdG9yaW5nIGFuZCBzY2FsaW5nXG4gICAqL1xuICBhc3luYyBnZXRTdGF0cygpIHtcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IHVwdGltZSA9IG5vdyAtIHRoaXMuc2Vzc2lvblRpbWVzdGFtcDtcbiAgICBjb25zdCBkaHRUYWJsZSA9IHRoaXMucm91dGluZ1RhYmxlLmdldERIVFJvdXRpbmdUYWJsZSgpO1xuICAgIGNvbnN0IGRodFN0YXRzID0gZGh0VGFibGU/LmdldFN0YXRzID8gZGh0VGFibGUuZ2V0U3RhdHMoKSA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBkaHROb2RlQ291bnQgPSBkaHRTdGF0cz8ubm9kZUNvdW50ID8/IDA7XG5cbiAgICByZXR1cm4ge1xuICAgICAgbG9jYWxQZWVySWQ6IHRoaXMubG9jYWxQZWVySWQsXG4gICAgICB1cHRpbWUsXG4gICAgICBzZXNzaW9uVGltZXN0YW1wOiB0aGlzLnNlc3Npb25UaW1lc3RhbXAsXG4gICAgICBtZXNzYWdlc1NlbnQ6IHRoaXMubWVzc2FnZXNTZW50LFxuICAgICAgbWVzc2FnZXNSZWNlaXZlZDogdGhpcy5tZXNzYWdlc1JlY2VpdmVkLFxuICAgICAgYnl0ZXNUcmFuc2ZlcnJlZDogdGhpcy5ieXRlc1RyYW5zZmVycmVkLFxuICAgICAgcm91dGluZzogdGhpcy5yb3V0aW5nVGFibGUuZ2V0U3RhdHMoKSxcbiAgICAgIHJlbGF5OiB0aGlzLm1lc3NhZ2VSZWxheS5nZXRTdGF0cygpLFxuICAgICAgcGVlcnM6IGF3YWl0IHRoaXMud2VicnRjVHJhbnNwb3J0LmdldFBvb2woKS5nZXRTdGF0cygpLFxuICAgICAgZGh0OiB0aGlzLmRodFxuICAgICAgICA/IHtcbiAgICAgICAgICAgIG5vZGVJZDogYnl0ZXNUb0hleChwdWJsaWNLZXlUb05vZGVJZCh0aGlzLmlkZW50aXR5LnB1YmxpY0tleSkpLFxuICAgICAgICAgICAgbm9kZUNvdW50OiBkaHROb2RlQ291bnQsXG4gICAgICAgICAgfVxuICAgICAgICA6IG51bGwsXG4gICAgICBwZXJmb3JtYW5jZToge1xuICAgICAgICBtYXhQZWVyczogdGhpcy5tYXhQZWVycyxcbiAgICAgICAgY3VycmVudFBlZXJzOiB0aGlzLnJvdXRpbmdUYWJsZS5nZXRBbGxQZWVycygpLmxlbmd0aCxcbiAgICAgICAgY29ubmVjdGVkUGVlcnM6IHRoaXMucm91dGluZ1RhYmxlLmdldEFsbFBlZXJzKCkuZmlsdGVyKHAgPT4gcC5zdGF0ZSA9PT0gJ2Nvbm5lY3RlZCcpLmxlbmd0aCxcbiAgICAgICAgZGVmYXVsdFRUTDogdGhpcy5kZWZhdWx0VFRMLFxuICAgICAgICBtZXNzYWdlUXVldWVTaXplOiAxMDAwMCwgLy8gRGVmYXVsdCBmcm9tIGNvbmZpZ1xuICAgICAgICByYXRlTGltaXRQZXJQZWVyOiAxMDAsIC8vIERlZmF1bHQgZnJvbSBjb25maWdcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuXG4gIGFzeW5jIGhhbmRsZUljZUNhbmRpZGF0ZShwZWVySWQ6IHN0cmluZywgY2FuZGlkYXRlOiBSVENJY2VDYW5kaWRhdGVJbml0KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHNpZ25hbGluZ0RhdGEgPSB7XG4gICAgICAgIHR5cGU6IFwiY2FuZGlkYXRlXCIgYXMgY29uc3QsXG4gICAgICAgIGRhdGE6IGNhbmRpZGF0ZSxcbiAgICAgICAgZnJvbTogcGVlcklkLFxuICAgICAgICB0bzogdGhpcy5sb2NhbFBlZXJJZCxcbiAgICAgIH07XG4gICAgICBcbiAgICAgIGF3YWl0IHRoaXMud2VicnRjVHJhbnNwb3J0LmhhbmRsZVNpZ25hbGluZyhzaWduYWxpbmdEYXRhKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS53YXJuKGBbTWVzaE5ldHdvcmtdIEZhaWxlZCB0byBwcm9jZXNzIElDRSBjYW5kaWRhdGUgZm9yICR7cGVlcklkfTpgLCBlcnJvcik7XG4gICAgfVxuICB9XG5cbiAgLy8gPT09PT0gU0VTU0lPTiBNQU5BR0VNRU5UIChTaW5nbGUtU2Vzc2lvbiBFbmZvcmNlbWVudCkgPT09PT1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSB1bmlxdWUgc2Vzc2lvbiBJRFxuICAgKi9cbiAgcHJpdmF0ZSBnZW5lcmF0ZVNlc3Npb25JZCgpOiBzdHJpbmcge1xuICAgIGNvbnN0IHJhbmRvbUJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuICAgIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMocmFuZG9tQnl0ZXMpO1xuICAgIHJldHVybiBBcnJheS5mcm9tKHJhbmRvbUJ5dGVzKVxuICAgICAgLm1hcCgoYikgPT4gYi50b1N0cmluZygxNikucGFkU3RhcnQoMiwgXCIwXCIpKVxuICAgICAgLmpvaW4oXCJcIik7XG4gIH1cblxuICAvKipcbiAgICogU3RhcnQgYnJvYWRjYXN0aW5nIHNlc3Npb24gcHJlc2VuY2VcbiAgICovXG4gIHByaXZhdGUgc3RhcnRTZXNzaW9uUHJlc2VuY2UoKTogdm9pZCB7XG4gICAgLy8gQ2xlYXIgZXhpc3RpbmcgaW50ZXJ2YWwgaWYgYW55XG4gICAgaWYgKHRoaXMuc2Vzc2lvblByZXNlbmNlSW50ZXJ2YWwpXG4gICAgICBjbGVhckludGVydmFsKHRoaXMuc2Vzc2lvblByZXNlbmNlSW50ZXJ2YWwpO1xuXG4gICAgLy8gQnJvYWRjYXN0IGltbWVkaWF0ZWx5XG4gICAgdGhpcy5icm9hZGNhc3RTZXNzaW9uUHJlc2VuY2UoKTtcblxuICAgIC8vIFRoZW4gYnJvYWRjYXN0IGV2ZXJ5IDMwIHNlY29uZHNcbiAgICB0aGlzLnNlc3Npb25QcmVzZW5jZUludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgdGhpcy5icm9hZGNhc3RTZXNzaW9uUHJlc2VuY2UoKTtcbiAgICB9LCAzMDAwMCk7XG5cbiAgICAvLyBBbGxvdyBOb2RlLmpzIHRvIGV4aXQgY2xlYW5seVxuICAgIHRyeSB7XG4gICAgICBpZiAoXG4gICAgICAgIHRoaXMuc2Vzc2lvblByZXNlbmNlSW50ZXJ2YWwgJiZcbiAgICAgICAgdHlwZW9mICh0aGlzLnNlc3Npb25QcmVzZW5jZUludGVydmFsIGFzIGFueSkudW5yZWYgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgKSB7XG4gICAgICAgICh0aGlzLnNlc3Npb25QcmVzZW5jZUludGVydmFsIGFzIGFueSkudW5yZWYoKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvKiBuby1vcCAqL1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9wIGJyb2FkY2FzdGluZyBzZXNzaW9uIHByZXNlbmNlXG4gICAqL1xuICBwcml2YXRlIHN0b3BTZXNzaW9uUHJlc2VuY2UoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuc2Vzc2lvblByZXNlbmNlSW50ZXJ2YWwpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5zZXNzaW9uUHJlc2VuY2VJbnRlcnZhbCk7XG4gICAgICB0aGlzLnNlc3Npb25QcmVzZW5jZUludGVydmFsID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQnJvYWRjYXN0IHNlc3Npb24gcHJlc2VuY2UgdG8gYWxsIGNvbm5lY3RlZCBwZWVyc1xuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBicm9hZGNhc3RTZXNzaW9uUHJlc2VuY2UoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHBheWxvYWQgPSBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIHNlc3Npb25JZDogdGhpcy5zZXNzaW9uSWQsXG4gICAgICAgIHRpbWVzdGFtcDogdGhpcy5zZXNzaW9uVGltZXN0YW1wLFxuICAgICAgICBpZGVudGl0eUZpbmdlcnByaW50OiBieXRlc1RvSGV4KHRoaXMuaWRlbnRpdHkucHVibGljS2V5KSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBwYXlsb2FkQnl0ZXMgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUocGF5bG9hZCk7XG4gICAgICBjb25zdCBtZXNzYWdlOiBNZXNzYWdlID0ge1xuICAgICAgICBoZWFkZXI6IHtcbiAgICAgICAgICB2ZXJzaW9uOiAweDAxLFxuICAgICAgICAgIHR5cGU6IE1lc3NhZ2VUeXBlLlNFU1NJT05fUFJFU0VOQ0UsXG4gICAgICAgICAgdHRsOiB0aGlzLmRlZmF1bHRUVEwsXG4gICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgICAgIHNlbmRlcklkOiB0aGlzLmlkZW50aXR5LnB1YmxpY0tleSxcbiAgICAgICAgICBzaWduYXR1cmU6IG5ldyBVaW50OEFycmF5KDY0KSxcbiAgICAgICAgfSxcbiAgICAgICAgcGF5bG9hZDogcGF5bG9hZEJ5dGVzLFxuICAgICAgfTtcblxuICAgICAgLy8gU2lnbiBhbmQgYnJvYWRjYXN0XG4gICAgICAvLyBOb3RlOiBXZSBlbmNvZGUgdHdpY2UgYmVjYXVzZSBzaWduYXR1cmUgbXVzdCBiZSBjb21wdXRlZCBvdmVyIHRoZSBtZXNzYWdlXG4gICAgICAvLyB3aXRob3V0IHRoZSBzaWduYXR1cmUgZmllbGQgcG9wdWxhdGVkLCB0aGVuIHdlIHNldCB0aGUgc2lnbmF0dXJlIGFuZCBlbmNvZGUgYWdhaW5cbiAgICAgIGNvbnN0IG1lc3NhZ2VCeXRlcyA9IGVuY29kZU1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICBtZXNzYWdlLmhlYWRlci5zaWduYXR1cmUgPSBzaWduTWVzc2FnZShcbiAgICAgICAgbWVzc2FnZUJ5dGVzLFxuICAgICAgICB0aGlzLmlkZW50aXR5LnByaXZhdGVLZXksXG4gICAgICApO1xuICAgICAgY29uc3QgZW5jb2RlZE1lc3NhZ2UgPSBlbmNvZGVNZXNzYWdlKG1lc3NhZ2UpO1xuXG4gICAgICAvLyBCcm9hZGNhc3QgdG8gYWxsIGNvbm5lY3RlZCBwZWVyc1xuICAgICAgdGhpcy5yb3V0aW5nVGFibGUuZ2V0QWxsUGVlcnMoKS5mb3JFYWNoKChwZWVyKSA9PiB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBwZWVyLnN0YXRlID09PSBQZWVyU3RhdGUuQ09OTkVDVEVEIHx8XG4gICAgICAgICAgcGVlci5zdGF0ZSA9PT0gUGVlclN0YXRlLkRFR1JBREVEXG4gICAgICAgICkge1xuICAgICAgICAgIHRoaXMudHJhbnNwb3J0TWFuYWdlci5zZW5kKHBlZXIuaWQsIGVuY29kZWRNZXNzYWdlKS5jYXRjaCgoKSA9PiB7fSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIGJyb2FkY2FzdCBzZXNzaW9uIHByZXNlbmNlOlwiLCBlcnJvcik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBpbmNvbWluZyBzZXNzaW9uIHByZXNlbmNlIG1lc3NhZ2VcbiAgICovXG4gIHByaXZhdGUgaGFuZGxlU2Vzc2lvblByZXNlbmNlKGZyb21QZWVySWQ6IHN0cmluZywgcGF5bG9hZDogYW55KTogdm9pZCB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShwYXlsb2FkKSk7XG4gICAgICBjb25zdCB7IHNlc3Npb25JZCwgdGltZXN0YW1wLCBpZGVudGl0eUZpbmdlcnByaW50IH0gPSBkYXRhO1xuXG4gICAgICAvLyBHZXQgb3VyIG93biBpZGVudGl0eSBmaW5nZXJwcmludFxuICAgICAgY29uc3Qgb3VyRmluZ2VycHJpbnQgPSBieXRlc1RvSGV4KHRoaXMuaWRlbnRpdHkucHVibGljS2V5KTtcblxuICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBhIGR1cGxpY2F0ZSBzZXNzaW9uIG9mIG91ciBpZGVudGl0eVxuICAgICAgaWYgKFxuICAgICAgICBpZGVudGl0eUZpbmdlcnByaW50ID09PSBvdXJGaW5nZXJwcmludCAmJlxuICAgICAgICBzZXNzaW9uSWQgIT09IHRoaXMuc2Vzc2lvbklkXG4gICAgICApIHtcbiAgICAgICAgLy8gQW5vdGhlciBzZXNzaW9uIHdpdGggb3VyIGlkZW50aXR5IGV4aXN0cyFcbiAgICAgICAgLy8gRGV0ZXJtaW5lIHdoaWNoIHNlc3Npb24gc2hvdWxkIGJlIGludmFsaWRhdGVkXG4gICAgICAgIGxldCBzaG91bGRJbnZhbGlkYXRlID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHRpbWVzdGFtcCA+IHRoaXMuc2Vzc2lvblRpbWVzdGFtcCkge1xuICAgICAgICAgIC8vIFRoZWlyIHRpbWVzdGFtcCBpcyBuZXdlciAtIGludmFsaWRhdGUgdGhpcyBzZXNzaW9uXG4gICAgICAgICAgc2hvdWxkSW52YWxpZGF0ZSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAodGltZXN0YW1wID09PSB0aGlzLnNlc3Npb25UaW1lc3RhbXApIHtcbiAgICAgICAgICAvLyBSYWNlIGNvbmRpdGlvbjogc2FtZSB0aW1lc3RhbXAgKGUuZy4sIHNpbXVsdGFuZW91cyBsb2dpbnMpXG4gICAgICAgICAgLy8gVXNlIHNlc3Npb25JZCBsZXhpY29ncmFwaGljIGNvbXBhcmlzb24gYXMgZGV0ZXJtaW5pc3RpYyB0aWUtYnJlYWtlclxuICAgICAgICAgIHNob3VsZEludmFsaWRhdGUgPSBzZXNzaW9uSWQgPiB0aGlzLnNlc3Npb25JZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzaG91bGRJbnZhbGlkYXRlKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgYERldGVjdGVkIG5ld2VyIHNlc3Npb24gZm9yIG91ciBpZGVudGl0eS4gSW52YWxpZGF0aW5nIHRoaXMgc2Vzc2lvbi5cbiAgICAgICAgICAgIE91ciBzZXNzaW9uOiAke3RoaXMuc2Vzc2lvbklkfSAoJHtuZXcgRGF0ZSh0aGlzLnNlc3Npb25UaW1lc3RhbXApLnRvSVNPU3RyaW5nKCl9KVxuICAgICAgICAgICAgTmV3IHNlc3Npb246ICR7c2Vzc2lvbklkfSAoJHtuZXcgRGF0ZSh0aW1lc3RhbXApLnRvSVNPU3RyaW5nKCl9KWAsXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIC8vIENhbGwgdGhlIGludmFsaWRhdGlvbiBjYWxsYmFja1xuICAgICAgICAgIGlmICh0aGlzLm9uU2Vzc2lvbkludmFsaWRhdGVkQ2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMub25TZXNzaW9uSW52YWxpZGF0ZWRDYWxsYmFjaygpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFNodXRkb3duIHRoaXMgaW5zdGFuY2VcbiAgICAgICAgICB0aGlzLnNodXRkb3duKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gT3VyIHNlc3Npb24gaXMgbmV3ZXIgLSB0aGUgb3RoZXIgc2Vzc2lvbiBzaG91bGQgaW52YWxpZGF0ZSBpdHNlbGZcbiAgICAgICAgICBjb25zb2xlLmluZm8oXG4gICAgICAgICAgICBgRGV0ZWN0ZWQgb2xkZXIgc2Vzc2lvbiBmb3Igb3VyIGlkZW50aXR5LiBPdXIgc2Vzc2lvbiBpcyBuZXdlciAtIGtlZXBpbmcgaXQuXG4gICAgICAgICAgICBPdXIgc2Vzc2lvbjogJHt0aGlzLnNlc3Npb25JZH0gKCR7bmV3IERhdGUodGhpcy5zZXNzaW9uVGltZXN0YW1wKS50b0lTT1N0cmluZygpfSlcbiAgICAgICAgICAgIE9sZCBzZXNzaW9uOiAke3Nlc3Npb25JZH0gKCR7bmV3IERhdGUodGltZXN0YW1wKS50b0lTT1N0cmluZygpfSlgLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBoYW5kbGUgc2Vzc2lvbiBwcmVzZW5jZTpcIiwgZXJyb3IpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBjYWxsYmFjayBmb3Igc2Vzc2lvbiBpbnZhbGlkYXRpb25cbiAgICovXG4gIG9uU2Vzc2lvbkludmFsaWRhdGVkKGNhbGxiYWNrOiAoKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdGhpcy5vblNlc3Npb25JbnZhbGlkYXRlZENhbGxiYWNrID0gY2FsbGJhY2s7XG4gIH1cblxuICAvKipcbiAgICogRGlzY29ubmVjdCBmcm9tIGFsbCBwZWVycyBhbmQgc2h1dCBkb3duXG4gICAqL1xuICBzaHV0ZG93bigpOiB2b2lkIHtcbiAgICB0aGlzLnRyYW5zcG9ydE1hbmFnZXIuc3RvcCgpLmNhdGNoKGNvbnNvbGUuZXJyb3IpO1xuICAgIHRoaXMucm91dGluZ1RhYmxlLmdldEFsbFBlZXJzKCkuZm9yRWFjaCgocGVlcjogUGVlcikgPT4ge1xuICAgICAgdGhpcy5yb3V0aW5nVGFibGUucmVtb3ZlUGVlcihwZWVyLmlkKTtcbiAgICB9KTtcbiAgICB0aGlzLnN0b3BIZWFydGJlYXQoKTtcbiAgICB0aGlzLnN0b3BTZXNzaW9uUHJlc2VuY2UoKTtcbiAgfSAvKipcbiAgICogR2V0IGxvY2FsIGlkZW50aXR5XG4gICAqL1xuICBnZXRJZGVudGl0eSgpOiBJZGVudGl0eUtleVBhaXIge1xuICAgIHJldHVybiB0aGlzLmlkZW50aXR5O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBsb2NhbCBwZWVyIElEXG4gICAqL1xuICBnZXRMb2NhbFBlZXJJZCgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLmxvY2FsUGVlcklkO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBwdWJsaWMga2V5XG4gICAqL1xuICBnZXRQdWJsaWNLZXkoKTogVWludDhBcnJheSB7XG4gICAgcmV0dXJuIHRoaXMuaWRlbnRpdHkucHVibGljS2V5O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBwZWVyIGNvdW50XG4gICAqL1xuICBnZXRQZWVyQ291bnQoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5yb3V0aW5nVGFibGUuZ2V0QWxsUGVlcnMoKS5sZW5ndGg7XG4gIH1cblxuICAvKipcbiAgICogQm9vdHN0cmFwIHRoZSBuZXR3b3JrIGJ5IGZpbmRpbmcgY2xvc2VzdCBwZWVycyB0byBzZWxmIGluIERIVFxuICAgKi9cbiAgYXN5bmMgYm9vdHN0cmFwKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnNvbGUubG9nKFwiQm9vdHN0cmFwcGluZyBESFQuLi5cIik7XG4gICAgY29uc3QgcGVlcnMgPSBhd2FpdCB0aGlzLmRodC5maW5kTm9kZSh0aGlzLmxvY2FsUGVlcklkKTtcbiAgICBjb25zb2xlLmxvZyhgREhUIEJvb3RzdHJhcCBjb21wbGV0ZS4gRm91bmQgJHtwZWVycy5sZW5ndGh9IHBlZXJzLmApO1xuXG4gICAgLy8gQXR0ZW1wdCBjb25uZWN0aW9ucyB0byBkaXNjb3ZlcmVkIHBlZXJzXG4gICAgLy8gQXR0ZW1wdCBjb25uZWN0aW9ucyB0byBkaXNjb3ZlcmVkIHBlZXJzXG4gICAgZm9yIChjb25zdCBwZWVyIG9mIHBlZXJzKSB7XG4gICAgICBpZiAocGVlci5pZCAhPT0gdGhpcy5sb2NhbFBlZXJJZCAmJiAhdGhpcy5yb3V0aW5nVGFibGUuZ2V0UGVlcihwZWVyLmlkKSkge1xuICAgICAgICAvLyBXZSBrbm93IGFib3V0IHRoZW0sIGJ1dCBhcmVuJ3QgY29ubmVjdGVkLlxuICAgICAgICAvLyBJZiB3ZSBoYXZlIGNvbm5lY3Rpb24gaW5mbyAobWV0YWRhdGEgaW1wbGllcyB3ZSBtaWdodCwgY3VycmVudGx5IHdlIGRvbid0IHN0b3JlIGl0IGZ1bGx5IGluIERIVCByZXNwb25zZSlcbiAgICAgICAgLy8gSW4gZnVsbCBpbXBsLCBGSU5EX05PREUgcmV0dXJuIHZhbHVlcyBpbmNsdWRlIElQL3NpZ25hbCBpbmZvLlxuICAgICAgICAvLyBGb3Igbm93LCBpZiB3ZSBmb3VuZCB0aGVtIHZpYSBESFQsIGl0IG1lYW5zIHNvbWVvbmUgZWxzZSBrbm93cyB0aGVtLlxuICAgICAgICAvLyBXZSByZWx5IG9uIHRoZSBmYWN0IHRoYXQgYGRodC50c2AgYWRkZWQgdGhlbSB0byByb3V0aW5nIHRhYmxlLlxuICAgICAgICAvLyBXZSBtYXkgdHJpZ2dlciBjb25uZWN0aW9uIGF0dGVtcHRzIGhlcmUgaWYgd2UgaGF2ZSBhIHdheSB0byBzaWduYWwgdGhlbS5cblxuICAgICAgICAvLyBJZiB3ZSBmb3VuZCB0aGVtLCB3ZSBtaWdodCB3YW50IHRvIHRyeSBjb25uZWN0aW5nIGlmIHdlIGFyZSBiZWxvdyBtYXhQZWVyc1xuICAgICAgICBpZiAodGhpcy5yb3V0aW5nVGFibGUuZ2V0QWxsUGVlcnMoKS5sZW5ndGggPCB0aGlzLm1heFBlZXJzKSB7XG4gICAgICAgICAgLy8gY29ubmVjdGlvbiBsb2dpYyB3b3VsZCBnbyBoZXJlIGlmIHdlIGhhZCBzaWduYWxpbmcgaW5mb1xuICAgICAgICAgIC8vIEZvciB0aGlzIHZlcnNpb24sIGp1c3QgcG9wdWxhdGluZyB0aGUgcm91dGluZyB0YWJsZSAoZG9uZSBpbiBESFQpIGlzIHRoZSBmaXJzdCBzdGVwLlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgREhUIGluc3RhbmNlXG4gICAqL1xuICBnZXRESFQoKTogREhUIHtcbiAgICByZXR1cm4gdGhpcy5kaHQ7XG4gIH1cblxuICAvKipcbiAgICogU2VuZCB0ZXh0IG1lc3NhZ2VcbiAgICovXG4gIGFzeW5jIHNlbmRUZXh0TWVzc2FnZShyZWNpcGllbnRJZDogc3RyaW5nLCB0ZXh0OiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICByZXR1cm4gdGhpcy5zZW5kTWVzc2FnZShyZWNpcGllbnRJZCwgdGV4dCk7XG4gIH1cblxuICAvKipcbiAgICogU2VuZCBiaW5hcnkgbWVzc2FnZVxuICAgKi9cbiAgYXN5bmMgc2VuZEJpbmFyeU1lc3NhZ2UoXG4gICAgcmVjaXBpZW50SWQ6IHN0cmluZyxcbiAgICBkYXRhOiBVaW50OEFycmF5LFxuICAgIHR5cGU6IE1lc3NhZ2VUeXBlID0gTWVzc2FnZVR5cGUuRklMRV9DSFVOSyxcbiAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgbWVzc2FnZTogTWVzc2FnZSA9IHtcbiAgICAgIGhlYWRlcjoge1xuICAgICAgICB2ZXJzaW9uOiAweDAxLFxuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICB0dGw6IHRoaXMuZGVmYXVsdFRUTCxcbiAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgICBzZW5kZXJJZDogdGhpcy5pZGVudGl0eS5wdWJsaWNLZXksXG4gICAgICAgIHNpZ25hdHVyZTogbmV3IFVpbnQ4QXJyYXkoNjUpLFxuICAgICAgfSxcbiAgICAgIHBheWxvYWQ6IGRhdGEsXG4gICAgfTtcblxuICAgIGNvbnN0IG1lc3NhZ2VCeXRlcyA9IGVuY29kZU1lc3NhZ2UobWVzc2FnZSk7XG4gICAgbWVzc2FnZS5oZWFkZXIuc2lnbmF0dXJlID0gc2lnbk1lc3NhZ2UoXG4gICAgICBtZXNzYWdlQnl0ZXMsXG4gICAgICB0aGlzLmlkZW50aXR5LnByaXZhdGVLZXksXG4gICAgKTtcbiAgICBjb25zdCBlbmNvZGVkTWVzc2FnZSA9IGVuY29kZU1lc3NhZ2UobWVzc2FnZSk7XG5cbiAgICBjb25zdCBuZXh0SG9wID0gdGhpcy5yb3V0aW5nVGFibGUuZ2V0TmV4dEhvcChyZWNpcGllbnRJZCk7XG5cbiAgICBpZiAobmV4dEhvcCkge1xuICAgICAgLy8gRGlyZWN0IHJvdXRlIGF2YWlsYWJsZVxuICAgICAgdGhpcy50cmFuc3BvcnRNYW5hZ2VyLnNlbmQobmV4dEhvcCwgZW5jb2RlZE1lc3NhZ2UpLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgY29uc29sZS53YXJuKGBGYWlsZWQgdG8gc2VuZCBiaW5hcnkgbWVzc2FnZSB0byAke25leHRIb3B9OmAsIGVycik7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQnJvYWRjYXN0IHRvIGFsbCBwZWVycyAoZmxvb2Qgcm91dGluZylcbiAgICAgIHRoaXMucm91dGluZ1RhYmxlLmdldEFsbFBlZXJzKCkuZm9yRWFjaCgocGVlcikgPT4ge1xuICAgICAgICBpZiAocGVlci5zdGF0ZSA9PT0gXCJjb25uZWN0ZWRcIikge1xuICAgICAgICAgIHRoaXMudHJhbnNwb3J0TWFuYWdlci5zZW5kKHBlZXIuaWQsIGVuY29kZWRNZXNzYWdlKS5jYXRjaCgoKSA9PiB7fSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBCcm9hZGNhc3QgbWVzc2FnZSB0byBhbGwgcGVlcnNcbiAgICovXG4gIGFzeW5jIGJyb2FkY2FzdE1lc3NhZ2UodGV4dDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgcGF5bG9hZCA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSh0ZXh0KTtcbiAgICBjb25zdCBtZXNzYWdlOiBNZXNzYWdlID0ge1xuICAgICAgaGVhZGVyOiB7XG4gICAgICAgIHZlcnNpb246IDB4MDEsXG4gICAgICAgIHR5cGU6IE1lc3NhZ2VUeXBlLlRFWFQsXG4gICAgICAgIHR0bDogdGhpcy5kZWZhdWx0VFRMLFxuICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICAgIHNlbmRlcklkOiB0aGlzLmlkZW50aXR5LnB1YmxpY0tleSxcbiAgICAgICAgc2lnbmF0dXJlOiBuZXcgVWludDhBcnJheSg2NSksXG4gICAgICB9LFxuICAgICAgcGF5bG9hZCxcbiAgICB9O1xuXG4gICAgY29uc3QgbWVzc2FnZUJ5dGVzID0gZW5jb2RlTWVzc2FnZShtZXNzYWdlKTtcbiAgICBtZXNzYWdlLmhlYWRlci5zaWduYXR1cmUgPSBzaWduTWVzc2FnZShcbiAgICAgIG1lc3NhZ2VCeXRlcyxcbiAgICAgIHRoaXMuaWRlbnRpdHkucHJpdmF0ZUtleSxcbiAgICApO1xuICAgIGNvbnN0IGVuY29kZWRNZXNzYWdlID0gZW5jb2RlTWVzc2FnZShtZXNzYWdlKTtcblxuICAgIHRoaXMucm91dGluZ1RhYmxlLmdldEFsbFBlZXJzKCkuZm9yRWFjaCgocGVlcikgPT4ge1xuICAgICAgaWYgKHBlZXIuc3RhdGUgPT09IFwiY29ubmVjdGVkXCIpIHtcbiAgICAgICAgdGhpcy50cmFuc3BvcnRNYW5hZ2VyLnNlbmQocGVlci5pZCwgZW5jb2RlZE1lc3NhZ2UpLmNhdGNoKCgpID0+IHt9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNjb25uZWN0IGZyb20gYSBzcGVjaWZpYyBwZWVyXG4gICAqL1xuICBhc3luYyBkaXNjb25uZWN0RnJvbVBlZXIocGVlcklkOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAvLyBTaGltOiBNYW51YWxseSB2ZXJpZnkgc3BlY2lmaWMgdHJhbnNwb3J0IHJlbW92YWxcbiAgICAvLyBJZGVhbGx5IHRoaXMgc2hvdWxkIGRpZmZlciB0byBUcmFuc3BvcnRNYW5hZ2VyXG4gICAgdGhpcy53ZWJydGNUcmFuc3BvcnQuZ2V0UG9vbCgpLnJlbW92ZVBlZXIocGVlcklkKTtcblxuICAgIHRoaXMucm91dGluZ1RhYmxlLnJlbW92ZVBlZXIocGVlcklkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNjb25uZWN0IGZyb20gYWxsIHBlZXJzXG4gICAqL1xuICBhc3luYyBkaXNjb25uZWN0QWxsKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRoaXMuc2h1dGRvd24oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBjb25uZWN0ZWQgdG8gYSBwZWVyXG4gICAqL1xuICBpc0Nvbm5lY3RlZFRvUGVlcihwZWVySWQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IHBlZXIgPSB0aGlzLnJvdXRpbmdUYWJsZS5nZXRQZWVyKHBlZXJJZCk7XG4gICAgcmV0dXJuIEJvb2xlYW4ocGVlciAmJiBwZWVyLnN0YXRlID09PSBcImNvbm5lY3RlZFwiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgbmV0d29yayBzdGF0aXN0aWNzXG4gICAqL1xuICBnZXRTdGF0aXN0aWNzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBwZWVyQ291bnQ6IHRoaXMuZ2V0UGVlckNvdW50KCksXG4gICAgICBtZXNzYWdlc1NlbnQ6IHRoaXMubWVzc2FnZXNTZW50LFxuICAgICAgbWVzc2FnZXNSZWNlaXZlZDogdGhpcy5tZXNzYWdlc1JlY2VpdmVkLFxuICAgICAgYnl0ZXNUcmFuc2ZlcnJlZDogdGhpcy5ieXRlc1RyYW5zZmVycmVkLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogU3RhcnQgdGhlIG5ldHdvcmtcbiAgICovXG4gIGFzeW5jIHN0YXJ0KCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGF3YWl0IHRoaXMudHJhbnNwb3J0TWFuYWdlci5zdGFydCgpO1xuICAgIHRoaXMuc3RhcnRIZWFydGJlYXQoKTtcbiAgICB0aGlzLnN0YXJ0U2Vzc2lvblByZXNlbmNlKCk7XG4gICAgdGhpcy5zdGFydENvbm5lY3Rpb25IZWFsdGhNb25pdG9yaW5nKCk7XG4gICAgdGhpcy5tZXNzYWdlUmVsYXkuc3RhcnQoKTsgLy8gU3RhcnQgc25lYWtlcm5ldCBtZXNzYWdlIHJldHJ5XG4gIH1cblxuICAvKipcbiAgICogU3RhcnQgY29ubmVjdGlvbiBoZWFsdGggbW9uaXRvcmluZyBmb3Igcm9jay1zb2xpZCBjb25uZWN0aW9uc1xuICAgKi9cbiAgcHJpdmF0ZSBzdGFydENvbm5lY3Rpb25IZWFsdGhNb25pdG9yaW5nKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmNvbm5lY3Rpb25IZWFsdGhDaGVja0ludGVydmFsKSB7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMuY29ubmVjdGlvbkhlYWx0aENoZWNrSW50ZXJ2YWwpO1xuICAgIH1cblxuICAgIHRoaXMuY29ubmVjdGlvbkhlYWx0aENoZWNrSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICB0aGlzLnBlcmZvcm1Db25uZWN0aW9uSGVhbHRoQ2hlY2soKTtcbiAgICB9LCB0aGlzLkhFQUxUSF9DSEVDS19JTlRFUlZBTCk7XG5cbiAgICBjb25zb2xlLmxvZygnW01lc2hOZXR3b3JrXSDwn5SNIFN0YXJ0ZWQgY29ubmVjdGlvbiBoZWFsdGggbW9uaXRvcmluZycpO1xuICB9XG5cbiAgLyoqXG4gICAqIFBlcmZvcm0gY29tcHJlaGVuc2l2ZSBjb25uZWN0aW9uIGhlYWx0aCBjaGVja1xuICAgKi9cbiAgcHJpdmF0ZSBwZXJmb3JtQ29ubmVjdGlvbkhlYWx0aENoZWNrKCk6IHZvaWQge1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgY29uc3QgY29ubmVjdGVkUGVlcnMgPSB0aGlzLnJvdXRpbmdUYWJsZS5nZXRBbGxQZWVycygpLmZpbHRlcihwID0+IHAuc3RhdGUgPT09ICdjb25uZWN0ZWQnKTtcbiAgICBcbiAgICBjb25zb2xlLmxvZyhgW01lc2hOZXR3b3JrXSDwn5KTIEhlYWx0aCBjaGVjazogJHtjb25uZWN0ZWRQZWVycy5sZW5ndGh9IGNvbm5lY3RlZCBwZWVyc2ApO1xuXG4gICAgZm9yIChjb25zdCBwZWVyIG9mIGNvbm5lY3RlZFBlZXJzKSB7XG4gICAgICBjb25zdCBsYXN0U2VlbiA9IHBlZXIubGFzdFNlZW4gfHwgMDtcbiAgICAgIGNvbnN0IGNvbm5lY3Rpb25BZ2UgPSBub3cgLSBsYXN0U2VlbjtcbiAgICAgIGNvbnN0IGF0dGVtcHRzID0gdGhpcy5jb25uZWN0aW9uQXR0ZW1wdHMuZ2V0KHBlZXIuaWQpIHx8IDA7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGZvciBzdGFsZSBjb25uZWN0aW9uc1xuICAgICAgaWYgKGNvbm5lY3Rpb25BZ2UgPiB0aGlzLkNPTk5FQ1RJT05fVElNRU9VVCkge1xuICAgICAgICBjb25zb2xlLndhcm4oYFtNZXNoTmV0d29ya10g4pqg77iPIFN0YWxlIGNvbm5lY3Rpb24gZGV0ZWN0ZWQgZm9yICR7cGVlci5pZH0gKCR7Y29ubmVjdGlvbkFnZX1tcyBhZ28pYCk7XG4gICAgICAgIFxuICAgICAgICBpZiAoYXR0ZW1wdHMgPCB0aGlzLk1BWF9DT05ORUNUSU9OX0FUVEVNUFRTKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYFtNZXNoTmV0d29ya10g8J+UhCBBdHRlbXB0aW5nIHRvIHJlY292ZXIgY29ubmVjdGlvbiB0byAke3BlZXIuaWR9YCk7XG4gICAgICAgICAgdGhpcy5hdHRlbXB0Q29ubmVjdGlvblJlY292ZXJ5KHBlZXIuaWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFtNZXNoTmV0d29ya10g8J+SpSBUb28gbWFueSBmYWlsZWQgYXR0ZW1wdHMgZm9yICR7cGVlci5pZH0sIGRpc2Nvbm5lY3RpbmdgKTtcbiAgICAgICAgICB0aGlzLnJvdXRpbmdUYWJsZS5yZW1vdmVQZWVyKHBlZXIuaWQpO1xuICAgICAgICAgIHRoaXMucGVlckRpc2Nvbm5lY3RlZExpc3RlbmVycy5mb3JFYWNoKGxpc3RlbmVyID0+IGxpc3RlbmVyKHBlZXIuaWQpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUmVzZXQgY29ubmVjdGlvbiBhdHRlbXB0cyBmb3IgaGVhbHRoeSBjb25uZWN0aW9uc1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb25BdHRlbXB0cy5kZWxldGUocGVlci5pZCk7XG4gICAgICAgIHRoaXMubGFzdENvbm5lY3Rpb25BdHRlbXB0LmRlbGV0ZShwZWVyLmlkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQXR0ZW1wdCB0byByZWNvdmVyIGEgZmFpbGluZyBjb25uZWN0aW9uXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGF0dGVtcHRDb25uZWN0aW9uUmVjb3ZlcnkocGVlcklkOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBhdHRlbXB0cyA9ICh0aGlzLmNvbm5lY3Rpb25BdHRlbXB0cy5nZXQocGVlcklkKSB8fCAwKSArIDE7XG4gICAgdGhpcy5jb25uZWN0aW9uQXR0ZW1wdHMuc2V0KHBlZXJJZCwgYXR0ZW1wdHMpO1xuICAgIHRoaXMubGFzdENvbm5lY3Rpb25BdHRlbXB0LnNldChwZWVySWQsIERhdGUubm93KCkpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKGBbTWVzaE5ldHdvcmtdIPCflIQgUmVjb3ZlcnkgYXR0ZW1wdCAke2F0dGVtcHRzfS8ke3RoaXMuTUFYX0NPTk5FQ1RJT05fQVRURU1QVFN9IGZvciAke3BlZXJJZH1gKTtcbiAgICAgIFxuICAgICAgLy8gUmVtb3ZlIG9sZCBwZWVyIGVudHJ5XG4gICAgICB0aGlzLnJvdXRpbmdUYWJsZS5yZW1vdmVQZWVyKHBlZXJJZCk7XG4gICAgICBcbiAgICAgIC8vIFRyeSB0byByZWNvbm5lY3QgdmlhIHRyYW5zcG9ydFxuICAgICAgYXdhaXQgdGhpcy50cmFuc3BvcnRNYW5hZ2VyLmNvbm5lY3QocGVlcklkKTtcbiAgICAgIFxuICAgICAgLy8gV2FpdCBhIGJpdCBmb3IgY29ubmVjdGlvbiB0byBlc3RhYmxpc2hcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAyMDAwKSk7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGlmIGNvbm5lY3Rpb24gd2FzIHN1Y2Nlc3NmdWxcbiAgICAgIGNvbnN0IHBlZXIgPSB0aGlzLnJvdXRpbmdUYWJsZS5nZXRQZWVyKHBlZXJJZCk7XG4gICAgICBpZiAocGVlciAmJiBwZWVyLnN0YXRlID09PSAnY29ubmVjdGVkJykge1xuICAgICAgICBjb25zb2xlLmxvZyhgW01lc2hOZXR3b3JrXSDinIUgU3VjY2Vzc2Z1bGx5IHJlY292ZXJlZCBjb25uZWN0aW9uIHRvICR7cGVlcklkfWApO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb25BdHRlbXB0cy5kZWxldGUocGVlcklkKTtcbiAgICAgICAgdGhpcy5sYXN0Q29ubmVjdGlvbkF0dGVtcHQuZGVsZXRlKHBlZXJJZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nvbm5lY3Rpb24gbm90IGVzdGFibGlzaGVkIGFmdGVyIHJlY292ZXJ5IGF0dGVtcHQnKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihgW01lc2hOZXR3b3JrXSDinYwgUmVjb3ZlcnkgYXR0ZW1wdCAke2F0dGVtcHRzfSBmYWlsZWQgZm9yICR7cGVlcklkfTpgLCBlcnJvcik7XG4gICAgICBcbiAgICAgIGlmIChhdHRlbXB0cyA+PSB0aGlzLk1BWF9DT05ORUNUSU9OX0FUVEVNUFRTKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYFtNZXNoTmV0d29ya10g8J+SpSBHaXZpbmcgdXAgb24gY29ubmVjdGlvbiB0byAke3BlZXJJZH0gYWZ0ZXIgJHthdHRlbXB0c30gYXR0ZW1wdHNgKTtcbiAgICAgICAgdGhpcy5yb3V0aW5nVGFibGUucmVtb3ZlUGVlcihwZWVySWQpO1xuICAgICAgICB0aGlzLnBlZXJEaXNjb25uZWN0ZWRMaXN0ZW5lcnMuZm9yRWFjaChsaXN0ZW5lciA9PiBsaXN0ZW5lcihwZWVySWQpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3RvcCB0aGUgbmV0d29ya1xuICAgKi9cbiAgYXN5bmMgc3RvcCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAvLyBDbGVhbiB1cCBjb25uZWN0aW9uIGhlYWx0aCBtb25pdG9yaW5nXG4gICAgaWYgKHRoaXMuY29ubmVjdGlvbkhlYWx0aENoZWNrSW50ZXJ2YWwpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5jb25uZWN0aW9uSGVhbHRoQ2hlY2tJbnRlcnZhbCk7XG4gICAgICB0aGlzLmNvbm5lY3Rpb25IZWFsdGhDaGVja0ludGVydmFsID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBcbiAgICAvLyBTdG9wIG1lc3NhZ2UgcmVsYXkgcmV0cnkgcHJvY2Vzc1xuICAgIHRoaXMubWVzc2FnZVJlbGF5LnN0b3AoKTtcbiAgICBcbiAgICB0aGlzLnNodXRkb3duKCk7XG4gIH1cblxuICAvLyAtLS0gTWFudWFsIENvbm5lY3Rpb24gTWV0aG9kcyAoV0FOIFN1cHBvcnQpIC0tLVxuXG4gIC8qKlxuICAgKiBJbml0aWF0ZSBhIG1hbnVhbCBjb25uZWN0aW9uIHRvIGEgcGVlciAoZm9yIFdBTi9TZXJ2ZXJsZXNzKS5cbiAgICogUmV0dXJucyB0aGUgU0RQIE9mZmVyIHRvIGJlIHNoYXJlZCB3aXRoIHRoZSByZW1vdGUgcGVlci5cbiAgICovXG4gIGFzeW5jIGNyZWF0ZU1hbnVhbENvbm5lY3Rpb24ocGVlcklkOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIGlmICh0aGlzLnJvdXRpbmdUYWJsZS5nZXRBbGxQZWVycygpLmxlbmd0aCA+PSB0aGlzLm1heFBlZXJzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNYXhpbXVtIG51bWJlciBvZiBwZWVycyByZWFjaGVkXCIpO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBvciBnZXQgcGVlciBjb25uZWN0aW9uXG4gICAgLy8gTWFudWFsIGNvbm5lY3Rpb24gaXMgc3BlY2lmaWNhbGx5IFdFQlJUQyBmZWF0dXJlLCBzbyB3ZSBhY2Nlc3Mgc2hpbS5cbiAgICAvLyBJTVBPUlRBTlQ6IGlmIHdlIGFscmVhZHkgaGF2ZSBhIHBlZXIgY29ubmVjdGlvbiBmb3IgdGhpcyBwZWVyLCByZWNyZWF0ZSBpdFxuICAgIC8vIGJlZm9yZSBnZW5lcmF0aW5nIGEgbmV3IG9mZmVyLiBHZW5lcmF0aW5nIG11bHRpcGxlIG9mZmVycyAvIHJlLWNyZWF0aW5nIGRhdGFcbiAgICAvLyBjaGFubmVscyBvbiBhbiBleGlzdGluZyBSVENQZWVyQ29ubmVjdGlvbiBjYW4gY2F1c2UgU0RQIG0tbGluZSBvcmRlciBtaXNtYXRjaC5cbiAgICBjb25zdCBwb29sID0gdGhpcy53ZWJydGNUcmFuc3BvcnQuZ2V0UG9vbCgpO1xuICAgIGlmICh0eXBlb2YgKHBvb2wgYXMgYW55KS5oYXMgPT09IFwiZnVuY3Rpb25cIiAmJiAocG9vbCBhcyBhbnkpLmhhcyhwZWVySWQpKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBtYXliZVByb21pc2UgPSAocG9vbCBhcyBhbnkpLnJlbW92ZVBlZXIocGVlcklkKTtcbiAgICAgICAgaWYgKG1heWJlUHJvbWlzZSAmJiB0eXBlb2YgbWF5YmVQcm9taXNlLnRoZW4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIGF3YWl0IG1heWJlUHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBuby1vcFxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBwZWVyID0gcG9vbC5nZXRPckNyZWF0ZVBlZXIocGVlcklkKTtcblxuICAgIC8vIE1hbnVhbCBjb25uZWN0aW9uIGZsb3cgZXhwbGljaXRseSBjb250cm9scyBvZmZlci9hbnN3ZXIgZXhjaGFuZ2UuXG4gICAgLy8gRGlzYWJsZSBhdXRvbWF0aWMgcmVuZWdvdGlhdGlvbiBvZmZlcnMgZHVyaW5nIGluaXRpYWwgc2V0dXAgdG8gYXZvaWRcbiAgICAvLyBjb25jdXJyZW50IG9mZmVycyBhbmQgU0RQIG0tbGluZSBvcmRlciBtaXNtYXRjaC5cbiAgICB0cnkge1xuICAgICAgaWYgKChwZWVyIGFzIGFueSkuY29ubmVjdGlvbiAmJiB0eXBlb2YgKHBlZXIgYXMgYW55KS5jb25uZWN0aW9uID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIChwZWVyIGFzIGFueSkuY29ubmVjdGlvbi5vbm5lZ290aWF0aW9ubmVlZGVkID0gbnVsbDtcbiAgICAgIH1cbiAgICB9IGNhdGNoIHtcbiAgICAgIC8vIG5vLW9wXG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIGRhdGEgY2hhbm5lbHNcbiAgICBwZWVyLmNyZWF0ZURhdGFDaGFubmVsKHsgbGFiZWw6IFwicmVsaWFibGVcIiwgb3JkZXJlZDogdHJ1ZSB9KTtcbiAgICBwZWVyLmNyZWF0ZURhdGFDaGFubmVsKHtcbiAgICAgIGxhYmVsOiBcInVucmVsaWFibGVcIixcbiAgICAgIG9yZGVyZWQ6IGZhbHNlLFxuICAgICAgbWF4UmV0cmFuc21pdHM6IDAsXG4gICAgfSk7XG5cbiAgICAvLyBDcmVhdGUgb2ZmZXJcbiAgICBhd2FpdCBwZWVyLmNyZWF0ZU9mZmVyKCk7XG5cbiAgICAvLyBTZXQgdXAgc3RhdGUgY2hhbmdlIGhhbmRsZXIgdG8gZW5zdXJlIHBlZXIgaXMgcmVnaXN0ZXJlZCB3aGVuIGNvbm5lY3RlZFxuICAgIHBlZXIub25TdGF0ZUNoYW5nZSgoc3RhdGU6IHN0cmluZykgPT4ge1xuICAgICAgaWYgKHN0YXRlID09PSBcImNvbm5lY3RlZFwiKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlUGVlckNvbm5lY3RlZChwZWVySWQpO1xuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgc3RhdGUgPT09IFwiZGlzY29ubmVjdGVkXCIgfHxcbiAgICAgICAgc3RhdGUgPT09IFwiZmFpbGVkXCIgfHxcbiAgICAgICAgc3RhdGUgPT09IFwiY2xvc2VkXCJcbiAgICAgICkge1xuICAgICAgICB0aGlzLmhhbmRsZVBlZXJEaXNjb25uZWN0ZWQocGVlcklkKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFdhaXQgZm9yIElDRSBnYXRoZXJpbmcgdG8gY29tcGxldGUgKHNvIGNhbmRpZGF0ZXMgYXJlIGluY2x1ZGVkIGluIFNEUClcbiAgICBhd2FpdCBwZWVyLndhaXRGb3JJY2VHYXRoZXJpbmcoKTtcbiAgICBjb25zdCBvZmZlciA9IGF3YWl0IHBlZXIuZ2V0TG9jYWxEZXNjcmlwdGlvbigpO1xuXG4gICAgLy8gUmV0dXJuIHRoZSBvZmZlciB3cmFwcGVkIHdpdGggbWV0YWRhdGFcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgdHlwZTogXCJvZmZlclwiLFxuICAgICAgcGVlcklkOiB0aGlzLmxvY2FsUGVlcklkLFxuICAgICAgc2RwOiBvZmZlcixcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIGNhbGxiYWNrIGZvciBzaWduYWxpbmcgKElDRSBjYW5kaWRhdGVzLCBvZmZlcnMsIGFuc3dlcnMpIHRvIGJlIHNlbnQgdmlhIGV4dGVybmFsIGNoYW5uZWxcbiAgICovXG4gIHJlZ2lzdGVyU2lnbmFsaW5nQ2FsbGJhY2soXG4gICAgY2FsbGJhY2s6IChwZWVySWQ6IHN0cmluZywgc2lnbmFsOiB7IHR5cGU6IHN0cmluZzsgY2FuZGlkYXRlPzogUlRDSWNlQ2FuZGlkYXRlSW5pdDsgc2RwPzogUlRDU2Vzc2lvbkRlc2NyaXB0aW9uSW5pdCB9KSA9PiBQcm9taXNlPHZvaWQ+LFxuICApOiB2b2lkIHtcbiAgICB0aGlzLnNpZ25hbGluZ0NhbGxiYWNrID0gY2FsbGJhY2s7XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXIgYSBjYWxsYmFjayBmb3Igb3V0Ym91bmQgbWVzc2FnZXMgdmlhIGV4dGVybmFsIHRyYW5zcG9ydCAoZS5nLiwgTmF0aXZlIEJMRSlcbiAgICovXG4gIHJlZ2lzdGVyT3V0Ym91bmRUcmFuc3BvcnQoXG4gICAgY2FsbGJhY2s6IChwZWVySWQ6IHN0cmluZywgZGF0YTogVWludDhBcnJheSkgPT4gUHJvbWlzZTx2b2lkPixcbiAgKTogdm9pZCB7XG4gICAgdGhpcy5vdXRib3VuZFRyYW5zcG9ydENhbGxiYWNrID0gY2FsbGJhY2s7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIGluY29taW5nIHJhdyBwYWNrZXQgZnJvbSBleHRlcm5hbCB0cmFuc3BvcnQgKGUuZy4sIE5hdGl2ZSBCTEUpXG4gICAqL1xuICBhc3luYyBoYW5kbGVJbmNvbWluZ1BhY2tldChwZWVySWQ6IHN0cmluZywgZGF0YTogVWludDhBcnJheSk6IFByb21pc2U8dm9pZD4ge1xuICAgIC8vIFRyZWF0IGFzIGlmIHJlY2VpdmVkIGZyb20gcGVlciBwb29sXG4gICAgYXdhaXQgdGhpcy5tZXNzYWdlUmVsYXkucHJvY2Vzc01lc3NhZ2UoZGF0YSwgcGVlcklkKTtcblxuICAgIC8vIFVwZGF0ZSBtZXRyaWNzIG9yIGNoZWNraW5nIGlmIHdlIG5lZWQgdG8gYWRkIHRvIHRhYmxlP1xuICAgIC8vIHByb2Nlc3NNZXNzYWdlIGhhbmRsZXMgcmVsYXkgbG9naWMuXG4gICAgLy8gV2Ugc2hvdWxkIGVuc3VyZSB0aGUgcGVlciBleGlzdHMgaW4gcm91dGluZyB0YWJsZT9cbiAgICAvLyBJZiBpdCdzIGEgbmV3IHBlZXIgc2VuZGluZyB1cyBkYXRhLCB3ZSBtaWdodCB3YW50IHRvIGVuc3VyZSB0aGV5IGFyZSBcImNvbm5lY3RlZFwiXG4gICAgaWYgKCF0aGlzLnJvdXRpbmdUYWJsZS5nZXRQZWVyKHBlZXJJZCkpIHtcbiAgICAgIC8vIFdlIHJlY2VpdmVkIGRhdGEgZnJvbSBhbiB1bmtub3duIHBlZXIgdmlhIG5hdGl2ZSB0cmFuc3BvcnQuXG4gICAgICAvLyBUaGUgRGlzY292ZXJ5TWFuYWdlciBvciBuYXRpdmUgYnJpZGdlIHNob3V0ZCBpZGVhbGx5IHJlZ2lzdGVyIHRoZW0gZmlyc3QuXG4gICAgICAvLyBCdXQgd2UgY2FuIGltcGxpY2l0bHkgcmVnaXN0ZXIgb3IgdXBkYXRlIGxhc3Qgc2Vlbi5cbiAgICAgIC8vIEZvciBub3csIGxldCdzIGFzc3VtZSBEaXNjb3ZlcnkgaGFuZGxlZCByZWdpc3RyYXRpb24gb3Igd2UganVzdCBsZXQgaXQgZmxvdy5cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQWNjZXB0IGEgbWFudWFsIGNvbm5lY3Rpb24gb2ZmZXIuXG4gICAqIFJldHVybnMgdGhlIFNEUCBBbnN3ZXIgdG8gYmUgc2VudCBiYWNrIHRvIHRoZSBpbml0aWF0b3IuXG4gICAqL1xuICBhc3luYyBhY2NlcHRNYW51YWxDb25uZWN0aW9uKG9mZmVyRGF0YTogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICBjb25zdCBwYXlsb2FkID0gSlNPTi5wYXJzZShvZmZlckRhdGEpO1xuICAgIGNvbnN0IHsgcGVlcklkLCBzZHAgfSA9IHBheWxvYWQ7XG5cbiAgICBpZiAoIXBlZXJJZCB8fCAhc2RwIHx8IHNkcC50eXBlICE9PSBcIm9mZmVyXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbWFudWFsIG9mZmVyIGRhdGFcIik7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIHBlZXIgY29ubmVjdGlvblxuICAgIGNvbnN0IHBlZXIgPSB0aGlzLndlYnJ0Y1RyYW5zcG9ydC5nZXRQb29sKCkuZ2V0T3JDcmVhdGVQZWVyKHBlZXJJZCk7XG5cbiAgICAvLyBTZXQgcmVtb3RlIGRlc2NyaXB0aW9uIChPZmZlcilcbiAgICBhd2FpdCBwZWVyLnNldFJlbW90ZURlc2NyaXB0aW9uKHNkcCk7XG5cbiAgICAvLyBDcmVhdGUgYW5zd2VyXG4gICAgYXdhaXQgcGVlci5jcmVhdGVBbnN3ZXIoKTtcblxuICAgIC8vIFNldCB1cCBzdGF0ZSBjaGFuZ2UgaGFuZGxlciB0byBlbnN1cmUgcGVlciBpcyByZWdpc3RlcmVkIHdoZW4gY29ubmVjdGVkXG4gICAgcGVlci5vblN0YXRlQ2hhbmdlKChzdGF0ZTogc3RyaW5nKSA9PiB7XG4gICAgICBpZiAoc3RhdGUgPT09IFwiY29ubmVjdGVkXCIpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVQZWVyQ29ubmVjdGVkKHBlZXJJZCk7XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICBzdGF0ZSA9PT0gXCJkaXNjb25uZWN0ZWRcIiB8fFxuICAgICAgICBzdGF0ZSA9PT0gXCJmYWlsZWRcIiB8fFxuICAgICAgICBzdGF0ZSA9PT0gXCJjbG9zZWRcIlxuICAgICAgKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlUGVlckRpc2Nvbm5lY3RlZChwZWVySWQpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gV2FpdCBmb3IgSUNFIGdhdGhlcmluZ1xuICAgIGF3YWl0IHBlZXIud2FpdEZvckljZUdhdGhlcmluZygpO1xuICAgIGNvbnN0IGFuc3dlciA9IGF3YWl0IHBlZXIuZ2V0TG9jYWxEZXNjcmlwdGlvbigpO1xuXG4gICAgLy8gUmV0dXJuIHRoZSBhbnN3ZXIgd3JhcHBlZCB3aXRoIG1ldGFkYXRhXG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgIHR5cGU6IFwiYW5zd2VyXCIsXG4gICAgICBwZWVySWQ6IHRoaXMubG9jYWxQZWVySWQsXG4gICAgICBzZHA6IGFuc3dlcixcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5hbGl6ZSBhIG1hbnVhbCBjb25uZWN0aW9uIHdpdGggdGhlIGFuc3dlci5cbiAgICovXG4gIGFzeW5jIGZpbmFsaXplTWFudWFsQ29ubmVjdGlvbihhbnN3ZXJEYXRhOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBwYXlsb2FkID0gSlNPTi5wYXJzZShhbnN3ZXJEYXRhKTtcbiAgICBjb25zdCB7IHBlZXJJZCwgc2RwIH0gPSBwYXlsb2FkO1xuXG4gICAgaWYgKCFwZWVySWQgfHwgIXNkcCB8fCBzZHAudHlwZSAhPT0gXCJhbnN3ZXJcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBtYW51YWwgYW5zd2VyIGRhdGFcIik7XG4gICAgfVxuXG4gICAgY29uc3QgcGVlciA9IHRoaXMud2VicnRjVHJhbnNwb3J0LmdldFBvb2woKS5nZXRQZWVyKHBlZXJJZCk7XG4gICAgaWYgKCFwZWVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFBlZXIgJHtwZWVySWR9IG5vdCBmb3VuZCAoY29ubmVjdGlvbiBub3QgaW5pdGlhdGVkPylgKTtcbiAgICB9XG5cbiAgICBhd2FpdCBwZWVyLnNldFJlbW90ZUFuc3dlcihzZHApO1xuICB9XG5cbiAgLy8gLS0tIERIVCBPcGVyYXRpb25zIC0tLVxuXG4gIC8qKlxuICAgKiBTdG9yZSBhIHZhbHVlIGluIHRoZSBESFRcbiAgICovXG4gIGFzeW5jIGRodFN0b3JlKGtleTogc3RyaW5nLCB2YWx1ZTogVWludDhBcnJheSk6IFByb21pc2U8dm9pZD4ge1xuICAgIGF3YWl0IHRoaXMuZGh0LnN0b3JlKGtleSwgdmFsdWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmQgYSB2YWx1ZSBpbiB0aGUgREhUXG4gICAqL1xuICBhc3luYyBkaHRGaW5kVmFsdWUoa2V5OiBzdHJpbmcpOiBQcm9taXNlPFVpbnQ4QXJyYXkgfCBudWxsPiB7XG4gICAgcmV0dXJuIHRoaXMuZGh0LmZpbmRWYWx1ZShrZXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmQgYSBub2RlIGluIHRoZSBESFRcbiAgICovXG4gIGFzeW5jIGRodEZpbmROb2RlKG5vZGVJZDogc3RyaW5nKTogUHJvbWlzZTxQZWVyIHwgdW5kZWZpbmVkPiB7XG4gICAgY29uc3QgcGVlcnMgPSBhd2FpdCB0aGlzLmRodC5maW5kTm9kZShub2RlSWQpO1xuICAgIHJldHVybiBwZWVycy5maW5kKChwKSA9PiBwLmlkID09PSBub2RlSWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgYSBmaWxlIHRvIGEgcGVlclxuICAgKi9cbiAgYXN5bmMgc2VuZEZpbGUocGVlcklkOiBzdHJpbmcsIGZpbGU6IEZpbGUgfCBVaW50OEFycmF5KTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zlck1hbmFnZXIuc2VuZEZpbGUocGVlcklkLCBmaWxlKTtcbiAgfVxufVxuIl0sInZlcnNpb24iOjN9