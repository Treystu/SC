{"file":"/Users/christymaxwell/Desktop/Luke_Stuff/GitHub/SC/core/src/mesh/network.ts","mappings":"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","names":[],"sources":["/Users/christymaxwell/Desktop/Luke_Stuff/GitHub/SC/core/src/mesh/network.ts"],"sourcesContent":["/**\n * Mesh Network Manager\n * Orchestrates routing, relay, and transport connections\n */\n\nimport { bytesToHex, bytesToBase64, base64ToBytes } from \"../utils/encoding.js\";\nimport { Message, MessageType, encodeMessage } from \"../protocol/message.js\";\nimport { RoutingTable, Peer, createPeer, PeerState } from \"./routing.js\";\nimport { MessageRelay } from \"./relay.js\";\nimport { TransportManager, Transport } from \"./transport/Transport.js\";\nimport { WebRTCTransport } from \"../transport/WebRTCTransport.js\";\nimport {\n  generateIdentity,\n  IdentityKeyPair,\n  signMessage,\n} from \"../crypto/primitives.js\";\nimport { generateFingerprintSync as _generateFingerprintSync } from \"../utils/fingerprint.js\";\nimport { ConnectionMonitor } from \"../connection-quality.js\";\nimport { DHT } from \"./dht.js\";\nimport {\n  DiscoveryManager,\n  DiscoveryPeer,\n  DiscoveryProvider,\n} from \"./discovery.js\";\nimport { KademliaRoutingTable, publicKeyToNodeId } from \"./dht/index.js\";\nimport { HttpBootstrapProvider } from \"../discovery/http-bootstrap.js\";\nimport { StorageAdapter } from \"./dht/storage/StorageAdapter.js\";\nimport { RendezvousManager } from \"./rendezvous.js\";\nimport { BlobStore, IndexedDBBlobAdapter } from \"../storage/blob-store.js\";\nimport { SocialRecoveryManager } from \"../recovery/social-recovery.js\";\nimport { TransferManager } from \"../transfer/TransferManager.js\";\nimport { RoutingMode } from \"./routing.js\";\n\nexport interface MeshNetworkConfig {\n  identity?: IdentityKeyPair;\n  peerId?: string; // Explicit Peer ID (fingerprint)\n  maxPeers?: number;\n  defaultTTL?: number;\n  persistence?: PersistenceAdapter;\n  dhtStorage?: StorageAdapter;\n  transports?: Transport[];\n  bootstrapUrl?: string; // URL for HTTP bootstrap\n  \n  // Performance and scaling configurations\n  messageQueueSize?: number; // Max messages in queue (default: 10000)\n  connectionTimeout?: number; // Connection timeout in ms (default: 30000)\n  heartbeatInterval?: number; // Heartbeat interval in ms (default: 30000)\n  healthCheckInterval?: number; // Health check interval in ms (default: 5000)\n  maxMessageSize?: number; // Max message size in bytes (default: 1MB)\n  rateLimitPerPeer?: number; // Max messages per second per peer (default: 100)\n  enableSelectiveFlooding?: boolean; // Enable smart flooding (default: true)\n  enableMessageDeduplication?: boolean; // Enable deduplication (default: true)\n  enableLoopDetection?: boolean; // Enable loop detection (default: true)\n  maxRetries?: number; // Max retry attempts (default: 3)\n  retryBackoff?: number; // Retry backoff in ms (default: 5000)\n}\n\nimport { PersistenceAdapter } from \"./relay.js\";\n\n/**\n * Mesh Network Manager\n * High-level API for mesh networking\n */\nexport class MeshNetwork {\n  private identity: IdentityKeyPair;\n  private routingTable: RoutingTable;\n  private messageRelay: MessageRelay;\n\n  // Replaced PeerConnectionPool with TransportManager\n  private transportManager: TransportManager;\n  private webrtcTransport: WebRTCTransport; // Keep ref for signaling hook\n\n  private localPeerId: string;\n  private defaultTTL: number;\n  private maxPeers: number;\n  private dht: DHT;\n  public rendezvous: RendezvousManager;\n  public discovery: DiscoveryManager;\n  public blobStore: BlobStore;\n  public socialRecovery: SocialRecoveryManager;\n  public transferManager: TransferManager;\n\n  // Connection monitoring and recovery\n  private connectionHealthCheckInterval?: NodeJS.Timeout;\n  private readonly HEALTH_CHECK_INTERVAL = 15000; // 15 seconds\n  private readonly CONNECTION_TIMEOUT = 45000; // 45 seconds\n  private readonly MAX_CONNECTION_ATTEMPTS = 3;\n  private connectionAttempts: Map<string, number> = new Map();\n  private lastConnectionAttempt: Map<string, number> = new Map();\n\n  // Callbacks\n  private messageListeners: Set<(message: Message) => void> = new Set();\n  private peerConnectedListeners: Set<(peerId: string) => void> = new Set();\n  private peerDisconnectedListeners: Set<(peerId: string) => void> = new Set();\n  private peerTrackListeners: Set<\n    (peerId: string, track: MediaStreamTrack, stream: MediaStream) => void\n  > = new Set();\n  private discoveryUpdateListeners: Set<(peers: string[]) => void> = new Set();\n\n  // Replaced by Transport Registration (Legacy Support)\n  private outboundTransportCallback?: (\n    peerId: string,\n    data: Uint8Array,\n  ) => Promise<void>;\n\n  private signalingCallback?: (\n    peerId: string,\n    signal: { type: string; candidate?: RTCIceCandidateInit; sdp?: RTCSessionDescriptionInit },\n  ) => Promise<void>;\n\n  // State\n  private discoveredPeers: Set<string> = new Set();\n  private peerMonitors: Map<string, ConnectionMonitor> = new Map();\n  private healthCheckInterval: ReturnType<typeof setInterval> | null = null;\n  private pendingBlobRequests: Map<\n    string,\n    {\n      resolve: (blob: Uint8Array | null) => void;\n      reject: (err: Error) => void;\n      timeout: ReturnType<typeof setTimeout>;\n    }\n  > = new Map();\n\n  // Message statistics\n  private messagesStored: number = 0;\n\n  // Session enforcement (single-session per identity)\n  private sessionId: string;\n  private sessionTimestamp: number;\n  private sessionPresenceInterval: ReturnType<typeof setInterval> | null = null;\n  private onSessionInvalidatedCallback?: () => void;\n\n  // Metrics tracking\n  private messagesSent = 0;\n  private messagesReceived = 0;\n  private bytesTransferred = 0;\n  private heartbeatMs: number;\n  private healthCheckMs: number;\n  private maxMessageSize: number;\n  private rateLimitPerPeer: number;\n  private maxRetries: number;\n  private retryBackoff: number;\n\n  constructor(config: MeshNetworkConfig = {}) {\n    // Initialize identity\n    this.identity = config.identity || generateIdentity();\n\n    // Unified Identity: Use provided ID or the full hex-encoded public key as peer ID\n    // Peer IDs across the codebase are expected to be the hex-encoded public key.\n    this.localPeerId =\n      config.peerId || Buffer.from(this.identity.publicKey).toString(\"hex\");\n\n    // Initialize session for single-session enforcement\n    this.sessionId = this.generateSessionId();\n    this.sessionTimestamp = Date.now();\n\n    // Configuration with production-ready defaults for 1M+ users\n    this.defaultTTL = config.defaultTTL || 10;\n    this.maxPeers = config.maxPeers || 100; // Increased for better scaling\n\n    // Performance configuration\n    const messageQueueSize = config.messageQueueSize ?? 10000;\n    const _connectionTimeout = config.connectionTimeout ?? 30000;\n    this.heartbeatMs = config.heartbeatInterval ?? 30000;\n    this.healthCheckMs = config.healthCheckInterval ?? 5000;\n    this.maxMessageSize = config.maxMessageSize ?? 1024 * 1024; // 1MB\n    this.rateLimitPerPeer = config.rateLimitPerPeer ?? 100;\n    const enableSelectiveFlooding = config.enableSelectiveFlooding !== false;\n    const _enableMessageDeduplication = config.enableMessageDeduplication !== false;\n    const _enableLoopDetection = config.enableLoopDetection !== false;\n    this.maxRetries = config.maxRetries ?? 3;\n    this.retryBackoff = config.retryBackoff ?? 5000;\n\n    // Initialize components\n    // Derive DHT node ID from public key (not from hex peer ID which is 64 chars)\n    const dhtNodeId = publicKeyToNodeId(this.identity.publicKey);\n    const dhtRoutingTable = new KademliaRoutingTable(dhtNodeId);\n\n    this.routingTable = new RoutingTable(this.localPeerId, {\n      mode: RoutingMode.HYBRID, // Default to Hybrid (DHT + Flood)\n      dhtRoutingTable,\n    });\n\n    // Configure message relay for high-scale operations\n    const relayConfig = {\n      maxStoredMessages: messageQueueSize,\n      storeTimeout: 300000, // 5 minutes\n      maxRetries: this.maxRetries,\n      retryBackoff: this.retryBackoff,\n      floodRateLimit: this.rateLimitPerPeer,\n      selectiveFlooding: enableSelectiveFlooding,\n    };\n\n    this.messageRelay = new MessageRelay(\n      this.localPeerId,\n      this.routingTable,\n      relayConfig,\n      config.persistence as PersistenceAdapter,\n    );\n\n    // Initialize Transports\n    this.transportManager = new TransportManager();\n\n    // Register WebRTC Transport\n    this.webrtcTransport = new WebRTCTransport(this.localPeerId);\n    this.transportManager.registerTransport(this.webrtcTransport);\n\n    // Register custom transports\n    if (config.transports) {\n      config.transports.forEach((transport) => {\n        this.transportManager.registerTransport(transport);\n      });\n    }\n\n    // Bind Transport Events\n    this.transportManager.onMessage((peerId, data) => {\n      this.handleIncomingTransportMessage(peerId, data);\n    });\n\n    this.transportManager.onPeerConnected((peerId) => {\n      this.handlePeerConnected(peerId);\n    });\n\n    this.transportManager.onPeerDisconnected((peerId) => {\n      this.handlePeerDisconnected(peerId);\n    });\n\n    this.webrtcTransport.getPool().onSignal((peerId, signal) => {\n      if (this.signalingCallback) {\n        this.signalingCallback(peerId, signal).catch((err) =>\n          console.error(\"[MeshNetwork] Failed to send signal via callback:\", err),\n        );\n      } else if (this.outboundTransportCallback) {\n        this.outboundTransportCallback(peerId, new Uint8Array()).catch((err) =>\n          console.error(\"[MeshNetwork] Failed to send signal via outbound transport:\", err),\n        );\n      } else {\n        console.debug(\"[MeshNetwork] No signaling callback registered, ICE candidate dropped for:\", peerId);\n      }\n    });\n\n    this.webrtcTransport.getPool().onTrack((peerId, track, stream) => {\n      this.peerTrackListeners.forEach((listener) => {\n        try {\n          listener(peerId, track, stream);\n        } catch (e) {\n          console.error(\"Error in peer track listener:\", e);\n        }\n      });\n    });\n\n    // Initialize DHT\n    this.dht = new DHT(\n      this.routingTable,\n      async (peerId, type, payload) => {\n        const message: Message = {\n          header: {\n            version: 0x01,\n            type,\n            ttl: this.defaultTTL,\n            timestamp: Date.now(),\n            senderId: this.identity.publicKey,\n            signature: new Uint8Array(64),\n          },\n          payload,\n        };\n\n        const messageBytes = encodeMessage(message);\n        message.header.signature = signMessage(\n          messageBytes,\n          this.identity.privateKey,\n        );\n        const encodedMessage = encodeMessage(message);\n\n        // Route via Transport Manager\n        try {\n          await this.transportManager.send(peerId, encodedMessage);\n        } catch (e) {\n          // If an outbound transport callback is registered (simulation / native), use it\n          if (this.outboundTransportCallback) {\n            try {\n              await this.outboundTransportCallback(peerId, encodedMessage);\n            } catch (err) {\n              console.warn(\n                `[DHT] Failed to deliver message to ${peerId} via outboundTransportCallback.`,\n                err,\n              );\n            }\n          } else {\n            // Fallback to flood if needed, or handle error\n            console.warn(\n              `[DHT] Failed to send message to ${peerId} via transports.`,\n              e,\n            );\n          }\n        }\n      },\n      { storage: config.dhtStorage },\n    );\n\n    // Initialize Discovery Manager\n    this.discovery = new DiscoveryManager();\n    if (config.bootstrapUrl) {\n      this.discovery.registerProvider(\n        new HttpBootstrapProvider(config.bootstrapUrl),\n      );\n    }\n    this.discovery.onPeerDiscovered(this.handleDiscoveredPeer.bind(this));\n\n    // Initialize Rendezvous Manager\n    this.rendezvous = new RendezvousManager(\n      this.localPeerId,\n      this.dht,\n      async (peerId, type, payload) => {\n        const message: Message = {\n          header: {\n            version: 0x01,\n            type,\n            ttl: this.defaultTTL,\n            timestamp: Date.now(),\n            senderId: this.identity.publicKey,\n            signature: new Uint8Array(64),\n          },\n          payload,\n        };\n        const messageBytes = encodeMessage(message);\n        message.header.signature = signMessage(\n          messageBytes,\n          this.identity.privateKey,\n        );\n        const encodedMessage = encodeMessage(message);\n        try {\n          await this.transportManager.send(peerId, encodedMessage);\n        } catch (e) {\n          if (this.outboundTransportCallback) {\n            try {\n              await this.outboundTransportCallback(peerId, encodedMessage);\n            } catch (err) {\n              console.warn(\n                `[Rendezvous] Failed to deliver to ${peerId} via outboundTransportCallback.`,\n                err,\n              );\n            }\n          } else {\n            console.warn(`[Rendezvous] Failed to send to ${peerId}`, e);\n          }\n        }\n      },\n    );\n\n    // Initialize BlobStore with persistent storage for sneakernet relay\n    // In browser environments, use IndexedDB; in Node/test, use memory-only\n    let blobPersistence;\n    if (typeof indexedDB !== 'undefined') {\n      blobPersistence = new IndexedDBBlobAdapter();\n    }\n    this.blobStore = new BlobStore(blobPersistence);\n    \n    // Initialize blob store asynchronously (non-blocking)\n    this.blobStore.init().catch(err => {\n      console.error('[BlobStore] Failed to initialize persistent storage:', err);\n      // Continue with memory-only mode if IndexedDB fails\n    });\n\n    // Initialize Social Recovery\n    this.socialRecovery = new SocialRecoveryManager(this);\n\n    // Initialize Transfer Manager\n    this.transferManager = new TransferManager(this);\n\n    this.setupMessageHandlers();\n  }\n\n  /**\n   * Set up message handlers for relay and peer pool\n   */\n  private heartbeatInterval: ReturnType<typeof setInterval> | null = null;\n\n  /**\n   * Set up message handlers for relay and peer pool\n   */\n  private setupMessageHandlers(): void {\n    // Handle messages addressed to this peer\n    this.messageRelay.onMessageForSelf((message: Message) => {\n      this.messagesReceived++;\n      this.bytesTransferred += message.payload.byteLength;\n\n      // Extract sender ID - use first 16 chars (8 bytes) in uppercase to match peer ID format\n      const senderId = Array.from(message.header.senderId)\n        .map((b) => b.toString(16).padStart(2, \"0\"))\n        .join(\"\")\n        .substring(0, 16)\n        .toUpperCase();\n\n      // Handle Control Messages\n      if (message.header.type === MessageType.CONTROL_PING) {\n        this.sendPong(message.header.senderId, message.header.timestamp);\n        return;\n      }\n\n      // Handle File Transfer Messages\n      if (\n        message.header.type === MessageType.FILE_METADATA ||\n        message.header.type === MessageType.FILE_CHUNK\n      ) {\n        this.transferManager.handleMessage(\n          message.header.type,\n          message.payload,\n        );\n        return;\n      }\n\n      // Handle DHT Messages\n      if (\n        message.header.type === MessageType.DHT_FIND_NODE ||\n        message.header.type === MessageType.DHT_FOUND_NODES ||\n        message.header.type === MessageType.DHT_FIND_VALUE ||\n        message.header.type === MessageType.DHT_STORE\n      ) {\n        this.dht.handleMessage(message);\n        return;\n      }\n\n      if (\n        message.header.type === MessageType.RENDEZVOUS_ANNOUNCE ||\n        message.header.type === MessageType.RENDEZVOUS_QUERY ||\n        message.header.type === MessageType.RENDEZVOUS_RESPONSE\n      ) {\n        this.rendezvous.handleMessage(message);\n        return;\n      }\n\n      // Handle Blob Messages\n      if (\n        message.header.type === MessageType.REQUEST_BLOB ||\n        message.header.type === MessageType.RESPONSE_BLOB\n      ) {\n        this.handleBlobMessage(message);\n        return;\n      }\n\n      if (message.header.type === MessageType.CONTROL_PONG) {\n        // Calculate RTT\n        // Payload contains the original timestamp (8 bytes / 64-bit float stored as string or bytes)\n        // For simplicity, let's assume payload is JSON string of timestamp\n        try {\n          const payloadStr = new TextDecoder().decode(message.payload);\n          const data = JSON.parse(payloadStr);\n          if (data.pingTimestamp) {\n            const rtt = Date.now() - data.pingTimestamp;\n            const monitor = this.peerMonitors.get(senderId);\n            if (monitor) {\n              monitor.updateLatency(rtt);\n              // Update peer last seen timestamp\n              this.routingTable.updatePeerLastSeen(senderId);\n            }\n          }\n        } catch (e) {\n          // Ignore malformed PONG\n        }\n        return;\n      }\n\n      // Handle Session Presence (Single-Session Enforcement)\n      if (message.header.type === MessageType.SESSION_PRESENCE) {\n        this.handleSessionPresence(senderId, message.payload);\n        return;\n      }\n\n      // Notify all listeners\n      this.messageListeners.forEach((listener) => {\n        try {\n          listener(message);\n        } catch (error) {\n          console.error(\"Error in message listener:\", error);\n        }\n      });\n    });\n\n    // Handle message forwarding (Smart Routing)\n    this.messageRelay.onForwardMessage(\n      (message: Message, excludePeerId: string) => {\n        const encodedMessage = encodeMessage(message);\n        this.messagesSent++;\n        this.bytesTransferred += encodedMessage.byteLength;\n\n        // \"Smart Flood\" / Tiered Routing Logic\n        let targetId: string | undefined;\n        try {\n          const payloadStr = new TextDecoder().decode(message.payload);\n          const data = JSON.parse(payloadStr);\n          targetId = data.recipient;\n        } catch (e) {\n          // Not a JSON payload or parsing failed -> Broadcast\n        }\n\n        if (targetId) {\n          const candidates =\n            this.routingTable.getRankedPeersForTarget(targetId);\n\n          // Filter: Exclude sender and self\n          const validCandidates = candidates.filter(\n            (p) =>\n              p.id !== excludePeerId &&\n              p.id !== this.localPeerId &&\n              p.state === \"connected\",\n          );\n\n          // Adaptive Selection Logic\n          const totalCandidates = validCandidates.length;\n          const FLOOD_THRESHOLD = 5; // \"Few\" threshold\n\n          let countToSelect;\n          if (totalCandidates <= FLOOD_THRESHOLD) {\n            countToSelect = totalCandidates;\n          } else {\n            countToSelect = Math.max(\n              FLOOD_THRESHOLD,\n              Math.ceil(totalCandidates * 0.1),\n            );\n          }\n\n          const selectedPeers = validCandidates.slice(0, countToSelect);\n\n          if (selectedPeers.length === 0) {\n            console.warn(\n              `[MeshNetwork] No valid peers for forwarding to ${targetId}. Dropping.`,\n            );\n          }\n\n          selectedPeers.forEach((peer) => {\n            this.transportManager.send(peer.id, encodedMessage).catch((err) => {\n              console.error(`Failed to forward to ${peer.id}`, err);\n            });\n          });\n        } else {\n          // Fallback to Full Flood via TransportManager (needs broadcast capability or manual loop)\n          // TransportManager send is point-to-point.\n          // We must iterate manual peers.\n          this.routingTable.getAllPeers().forEach((peer) => {\n            if (\n              peer.id !== excludePeerId &&\n              peer.id !== this.localPeerId &&\n              peer.state === PeerState.CONNECTED\n            ) {\n              this.transportManager\n                .send(peer.id, encodedMessage)\n                .catch(() => {});\n            }\n          });\n        }\n      },\n    );\n  }\n\n  // Handle incoming from Transport\n  private handleIncomingTransportMessage(peerId: string, data: Uint8Array) {\n    this.messageRelay.processMessage(data, peerId);\n\n    // Update packet loss metrics (simplified)\n    const monitor = this.peerMonitors.get(peerId);\n    if (monitor) {\n      monitor.updateBandwidth(data.length, 1000);\n    }\n  }\n\n  /**\n   * Start sending heartbeat (PING) messages\n   */\n  startHeartbeat(intervalMs: number = 30000): void {\n    if (this.heartbeatInterval) clearInterval(this.heartbeatInterval);\n    const hbMs = intervalMs ?? this.heartbeatMs;\n    this.heartbeatInterval = setInterval(() => {\n      this.broadcastPing();\n    }, hbMs);\n    try {\n      if (\n        this.heartbeatInterval &&\n        typeof (this.heartbeatInterval as any).unref === \"function\"\n      ) {\n        (this.heartbeatInterval as any).unref();\n      }\n    } catch (e) {\n      /* no-op */\n    }\n\n    // Also start health check loop\n    if (this.healthCheckInterval) clearInterval(this.healthCheckInterval);\n    this.healthCheckInterval = setInterval(() => {\n      this.monitorConnectionHealth();\n    }, this.healthCheckMs); // Configurable check interval\n    try {\n      if (\n        this.healthCheckInterval &&\n        typeof (this.healthCheckInterval as any).unref === \"function\"\n      ) {\n        (this.healthCheckInterval as any).unref();\n      }\n    } catch (e) {\n      /* no-op */\n    }\n  }\n\n  /**\n   * Stop sending heartbeat messages\n   */\n  stopHeartbeat(): void {\n    // Stop internals\n    this.transportManager.stop().catch(console.error);\n\n    if (this.heartbeatInterval) {\n      clearInterval(this.heartbeatInterval);\n      this.heartbeatInterval = null;\n    }\n    if (this.healthCheckInterval) {\n      clearInterval(this.healthCheckInterval);\n      this.healthCheckInterval = null;\n    }\n  }\n\n  private async broadcastPing(): Promise<void> {\n    try {\n      // Validate identity keys before signing\n      if (!this.identity?.privateKey || this.identity.privateKey.length !== 32) {\n        console.warn('[MeshNetwork] broadcastPing skipped: invalid private key');\n        return;\n      }\n      if (!this.identity?.publicKey || this.identity.publicKey.length !== 32) {\n        console.warn('[MeshNetwork] broadcastPing skipped: invalid public key');\n        return;\n      }\n\n      const message: Message = {\n        header: {\n          version: 0x01,\n          type: MessageType.CONTROL_PING,\n          ttl: 1,\n          timestamp: Date.now(),\n          senderId: this.identity.publicKey,\n          signature: new Uint8Array(64),\n        },\n        payload: new Uint8Array(0),\n      };\n\n      const messageBytes = encodeMessage(message);\n      message.header.signature = signMessage(\n        messageBytes,\n        this.identity.privateKey,\n      );\n      const encodedMessage = encodeMessage(message);\n\n      this.routingTable.getAllPeers().forEach((peer) => {\n        if (\n          peer.state === PeerState.CONNECTED ||\n          peer.state === PeerState.DEGRADED\n        ) {\n          this.transportManager.send(peer.id, encodedMessage).catch(() => {});\n        }\n      });\n    } catch (error) {\n      console.error('[MeshNetwork] broadcastPing failed:', error);\n    }\n  }\n\n  private async sendPong(\n    recipientPublicKey: Uint8Array,\n    pingTimestamp: number,\n  ): Promise<void> {\n    const recipientId = Array.from(recipientPublicKey)\n      .map((b) => b.toString(16).padStart(2, \"0\"))\n      .join(\"\");\n\n    // Echo back the ping timestamp\n    const payload = new TextEncoder().encode(JSON.stringify({ pingTimestamp }));\n\n    const message: Message = {\n      header: {\n        version: 0x01,\n        type: MessageType.CONTROL_PONG,\n        ttl: 1,\n        timestamp: Date.now(),\n        senderId: this.identity.publicKey,\n        signature: new Uint8Array(64),\n      },\n      payload: payload,\n    };\n\n    const messageBytes = encodeMessage(message);\n    message.header.signature = signMessage(\n      messageBytes,\n      this.identity.privateKey,\n    );\n    const encodedMessage = encodeMessage(message);\n\n    this.transportManager.send(recipientId, encodedMessage).catch(() => {});\n  }\n\n  /**\n   * Monitor connection health and handle degradation\n   */\n  private peerFailureCounts: Map<string, number> = new Map();\n\n  private monitorConnectionHealth(): void {\n    this.peerMonitors.forEach((monitor, peerId) => {\n      let quality = monitor.getQuality();\n      const peer = this.routingTable.getPeer(peerId);\n\n      if (!peer) {\n        this.peerMonitors.delete(peerId);\n        this.peerFailureCounts.delete(peerId);\n        return;\n      }\n\n      // Check lastSeen as a fallback for silence detection\n      const lastSeenAge = Date.now() - peer.lastSeen;\n      if (lastSeenAge > 30000) {\n        // 30 seconds silence\n        quality = \"offline\";\n      } else if (lastSeenAge > 10000 && quality !== \"offline\") {\n        // 10 seconds silence\n        quality = \"poor\";\n      }\n\n      // Update peer state based on quality\n      if (quality === \"poor\" && peer.state === PeerState.CONNECTED) {\n        peer.state = PeerState.DEGRADED;\n      } else if (\n        (quality === \"good\" || quality === \"excellent\") &&\n        peer.state === PeerState.DEGRADED\n      ) {\n        peer.state = PeerState.CONNECTED;\n        this.peerFailureCounts.set(peerId, 0);\n      } else if (quality === \"offline\") {\n        // Track consecutive offline checks\n        const failures = (this.peerFailureCounts.get(peerId) || 0) + 1;\n        this.peerFailureCounts.set(peerId, failures);\n\n        if (failures >= 6) {\n          // ~30 seconds of consecutive offline checks\n          this.disconnectFromPeer(peerId).catch((err) =>\n            console.error(`Error disconnecting peer ${peerId}:`, err),\n          );\n          this.peerFailureCounts.delete(peerId);\n        }\n      } else {\n        // Reset failure count if healthy\n        this.peerFailureCounts.set(peerId, 0);\n      }\n    });\n  }\n\n  /**\n   * Connect to a peer via available transports\n   */\n  async connectToPeer(peerId: string): Promise<void> {\n    console.log(`[MeshNetwork] connectToPeer called for ${peerId}`);\n\n    if (this.routingTable.getAllPeers().length >= this.maxPeers) {\n      console.warn(\n        `[MeshNetwork] Max peers reached (${this.maxPeers}), cannot connect to ${peerId}`,\n      );\n      throw new Error(\"Maximum number of peers reached\");\n    }\n\n    // Check if already connected\n    const existingPeer = this.routingTable.getPeer(peerId);\n    if (existingPeer && existingPeer.state === \"connected\") {\n      console.log(`[MeshNetwork] Already connected to ${peerId}, skipping`);\n      return;\n    }\n\n    const webrtcTransport = this.transportManager.getTransport(\"webrtc\");\n    if (webrtcTransport) {\n      const state = webrtcTransport.getConnectionState(peerId);\n      if (state === \"connecting\" || state === \"connected\") {\n        console.log(`[MeshNetwork] Connection to ${peerId} is already in state: ${state}, skipping`);\n        return;\n      }\n    }\n\n    console.log(\n      `[MeshNetwork] Initiating connection to ${peerId} via WebRTC...`,\n    );\n\n    // Use TransportManager to connect\n    // Currently defaults to WebRTC as it's the only registered transport\n    // but in future will try multiple\n    return this.transportManager\n      .connect(peerId, \"webrtc\")\n      .then(() => {\n        console.log(\n          `[MeshNetwork] Connection initiated to ${peerId}, waiting for signaling...`,\n        );\n      })\n      .catch((err) => {\n        console.error(`[MeshNetwork] Failed to connect to ${peerId}:`, err);\n        throw err;\n      });\n  }\n\n  /**\n   * Handle peer connected\n   */\n  private handlePeerConnected(peerId: string): void {\n    // Get transport type - if it's not one of the known types, default to \"webrtc\"\n    const transportName = this.webrtcTransport.name;\n    const validTransportTypes = [\"webrtc\", \"bluetooth\", \"local\"] as const;\n    const transportType = validTransportTypes.includes(transportName as any)\n      ? (transportName as \"webrtc\" | \"bluetooth\" | \"local\")\n      : \"webrtc\"; // Safe default fallback\n\n    const peer = createPeer(\n      peerId,\n      new Uint8Array(32), // Would be obtained during handshake\n      transportType,\n    );\n\n    this.routingTable.addPeer(peer);\n    this.peerMonitors.set(peerId, new ConnectionMonitor()); // Start monitoring\n    this.peerConnectedListeners.forEach((listener) => {\n      try {\n        listener(peerId);\n      } catch (e) {\n        console.error(\"Error in peer connected listener:\", e);\n      }\n    });\n\n    // Send peer announcement\n    this.sendPeerAnnouncement();\n  }\n\n  /**\n   * Handle peer disconnected\n   */\n  private handlePeerDisconnected(peerId: string): void {\n    this.routingTable.removePeer(peerId);\n    this.peerMonitors.delete(peerId); // Stop monitoring\n    this.peerDisconnectedListeners.forEach((listener) => {\n      try {\n        listener(peerId);\n      } catch (e) {\n        console.error(\"Error in peer disconnected listener:\", e);\n      }\n    });\n  }\n\n  /**\n   * Send a text message with enhanced validation and rate limiting\n   */\n  async sendMessage(\n    recipientId: string,\n    content: string,\n    type: MessageType = MessageType.TEXT,\n  ): Promise<void> {\n    // Normalize recipient ID to uppercase for consistent matching\n    const normalizedRecipientId = recipientId.replace(/\\s/g, \"\").toUpperCase();\n    \n    console.log(\n      `[MeshNetwork] sendMessage to ${normalizedRecipientId}, type=${MessageType[type]}`,\n    );\n\n    // Validate message size for scaling\n    const contentSize = new TextEncoder().encode(content).length;\n    if (contentSize > this.maxMessageSize) {\n      throw new Error(`Message size ${contentSize} exceeds maximum ${this.maxMessageSize} bytes`);\n    }\n\n    const payload = new TextEncoder().encode(\n      JSON.stringify({\n        text: content,\n        timestamp: Date.now(),\n        recipient: normalizedRecipientId,\n      }),\n    );\n\n    const message: Message = {\n      header: {\n        version: 0x01,\n        type: type,\n        ttl: this.defaultTTL,\n        timestamp: Date.now(),\n        senderId: this.identity.publicKey,\n        signature: new Uint8Array(64), // Placeholder\n      },\n      payload,\n    };\n\n    // Sign the message\n    const messageBytes = encodeMessage(message);\n    message.header.signature = signMessage(\n      messageBytes,\n      this.identity.privateKey,\n    );\n\n    // Send via mesh\n    const encodedMessage = encodeMessage(message);\n    const nextHop = this.routingTable.getNextHop(normalizedRecipientId);\n\n    console.log(\n      `[MeshNetwork] Route lookup for ${normalizedRecipientId}: nextHop=${nextHop || \"none\"}, connectedPeers=${this.routingTable.getAllPeers().filter((p) => p.state === \"connected\").length}`,\n    );\n\n    if (nextHop) {\n      // Direct route available\n      console.log(`[MeshNetwork] Sending directly to nextHop=${nextHop}`);\n      this.transportManager.send(nextHop, encodedMessage).catch((err) => {\n        console.error(\n          `[MeshNetwork] Failed to send to next hop ${nextHop}:`,\n          err,\n        );\n      });\n    } else {\n      // Check if we have any connected peers at all\n      const connectedPeers = this.routingTable\n        .getAllPeers()\n        .filter((p) => p.state === \"connected\" && p.id !== this.localPeerId);\n\n      console.log(\n        `[MeshNetwork] No direct route. Connected peers: ${connectedPeers.length}`,\n      );\n\n      if (connectedPeers.length === 0) {\n        console.warn(\n          `[MeshNetwork] No connected peers! Using sneakernet storage for ${recipientId}.`,\n        );\n        \n        // SNEAKERNET: Store message for later delivery via any available peer\n        try {\n          await this.messageRelay.storeMessage(message, normalizedRecipientId);\n          console.log(`[MeshNetwork]  Message stored for sneakernet delivery to ${recipientId}`);\n          this.messagesStored++;\n        } catch (error) {\n          console.error(`[MeshNetwork] Failed to store message for ${recipientId}:`, error);\n          throw new Error(`No connected peers and failed to store message: ${error}`);\n        }\n        return;\n      }\n\n      // Attempt DHT lookup if no candidates found\n      const candidates = this.routingTable.getRankedPeersForTarget(recipientId);\n\n      const connectedCandidates = candidates.filter(\n        (p) => p.state === \"connected\" && p.id !== this.localPeerId,\n      );\n\n      if (connectedCandidates.length === 0 && this.dht) {\n        console.log(\n          `[MeshNetwork] No known path to ${recipientId}, attempting DHT lookup...`,\n        );\n        try {\n          const foundPeers = await this.dht.findNode(recipientId);\n          const targetPeer = foundPeers.find((p) => p.id === recipientId);\n          if (targetPeer) {\n            console.log(\n              `[MeshNetwork] Found ${recipientId} in DHT, attempting connection...`,\n            );\n            await this.connectToPeer(recipientId);\n          }\n        } catch (e) {\n          console.warn(`[MeshNetwork] DHT lookup failed for ${recipientId}`, e);\n        }\n      }\n\n      console.log(\n        `[MeshNetwork] No direct route to ${recipientId}, initiating Smart Flood...`,\n      );\n\n      // Flood Fallback via TransportManager\n      this.routingTable.getAllPeers().forEach((peer) => {\n        if (\n          peer.state === PeerState.CONNECTED &&\n          peer.id !== this.localPeerId\n        ) {\n          this.transportManager.send(peer.id, encodedMessage).catch(() => {});\n        }\n      });\n    }\n  }\n\n  /**\n   * Send peer announcement to mesh\n   */\n  private sendPeerAnnouncement(): void {\n    const payload = new TextEncoder().encode(\n      JSON.stringify({\n        publicKey: Array.from(this.identity.publicKey)\n          .map((b: number) => b.toString(16).padStart(2, \"0\"))\n          .join(\"\"),\n        endpoints: [{ type: \"webrtc\", signaling: this.localPeerId }],\n        capabilities: {\n          supportedTransports: [\"webrtc\"],\n          protocolVersion: 1,\n        },\n        timestamp: Date.now(),\n      }),\n    );\n\n    const message: Message = {\n      header: {\n        version: 0x01,\n        type: MessageType.PEER_DISCOVERY,\n        ttl: this.defaultTTL,\n        timestamp: Date.now(),\n        senderId: this.identity.publicKey,\n        signature: new Uint8Array(64),\n      },\n      payload,\n    };\n\n    // Sign and broadcast\n    const messageBytes = encodeMessage(message);\n    message.header.signature = signMessage(\n      messageBytes,\n      this.identity.privateKey,\n    );\n    const encodedMessage = encodeMessage(message);\n\n    // Broadcast via routing table\n    this.routingTable.getAllPeers().forEach((peer) => {\n      if (peer.state === PeerState.CONNECTED) {\n        this.transportManager.send(peer.id, encodedMessage).catch(() => {});\n      }\n    });\n  }\n\n\n\n  onMessage(callback: (message: Message) => void): void {\n    this.messageListeners.add(callback);\n  }\n\n  /**\n   * Unregister callback for incoming messages\n   */\n  offMessage(callback: (message: Message) => void): void {\n    this.messageListeners.delete(callback);\n  }\n\n  /**\n   * Register a discovery provider\n   */\n  registerDiscoveryProvider(provider: DiscoveryProvider): void {\n    this.discovery.registerProvider(provider);\n  }\n\n  /**\n   * Handle discovered peer\n   */\n  private handleDiscoveredPeer(peer: DiscoveryPeer): void {\n    const peerId = peer.id;\n    if (peerId === this.localPeerId) return;\n\n    if (!this.discoveredPeers.has(peerId)) {\n      this.discoveredPeers.add(peerId);\n      console.log(`Discovered new peer ${peerId} via ${peer.source}`);\n\n      // Attempt to connect if we have capacity\n      if (this.routingTable.getAllPeers().length < this.maxPeers) {\n        console.log(\n          `Discovered new peer ${peer.id} via ${peer.source}. Attempting connection...`,\n        );\n\n        try {\n          if (peer.transportType === \"ble\") {\n            console.log(\n              `[MeshNetwork] BLE peer discovered. Native bridge required to connect to ${peer.id}`,\n            );\n            // In a real implementation: Bridge.connect(peer.id, peer.connectionDetails)\n          } else {\n            // Default to WebRTC / standard connection\n            this.connectToPeer(peer.id).catch((err) => {\n              console.warn(\n                `Failed to auto-connect to discovered peer ${peerId}:`,\n                err,\n              );\n            });\n          }\n        } catch (e) {\n          console.error(`Failed to connect to discovered peer ${peer.id}:`, e);\n        }\n      }\n    }\n\n    // Notify listeners\n    this.discoveryUpdateListeners.forEach((listener) => {\n      try {\n        listener(Array.from(this.discoveredPeers));\n      } catch (e) {\n        console.error(\"Error in discovery update listener:\", e);\n      }\n    });\n  }\n\n  /**\n   * Register callback for peer connected events\n   */\n  onPeerConnected(callback: (peerId: string) => void): void {\n    this.peerConnectedListeners.add(callback);\n  }\n\n  /**\n   * Unregister callback for peer connected events\n   */\n  offPeerConnected(callback: (peerId: string) => void): void {\n    this.peerConnectedListeners.delete(callback);\n  }\n\n  /**\n   * Register callback for peer disconnected events\n   */\n  onPeerDisconnected(callback: (peerId: string) => void): void {\n    this.peerDisconnectedListeners.add(callback);\n  }\n\n  /**\n   * Unregister callback for peer disconnected events\n   */\n  offPeerDisconnected(callback: (peerId: string) => void): void {\n    this.peerDisconnectedListeners.delete(callback);\n  }\n\n  /**\n   * Register callback for incoming peer tracks\n   */\n  /**\n   * Register callback for incoming peer tracks\n   */\n  onPeerTrack(\n    callback: (\n      peerId: string,\n      track: MediaStreamTrack,\n      stream: MediaStream,\n    ) => void,\n  ): void {\n    this.peerTrackListeners.add(callback);\n  }\n\n  offPeerTrack(\n    callback: (\n      peerId: string,\n      track: MediaStreamTrack,\n      stream: MediaStream,\n    ) => void,\n  ): void {\n    this.peerTrackListeners.delete(callback);\n  }\n\n  // --- Blob Handlers ---\n\n  private async handleBlobMessage(message: Message): Promise<void> {\n    // Normalize sender ID to 16-char uppercase format\n    const senderId = bytesToHex(message.header.senderId).substring(0, 16).toUpperCase();\n\n    if (message.header.type === MessageType.REQUEST_BLOB) {\n      try {\n        const data = JSON.parse(new TextDecoder().decode(message.payload));\n        const { hash, requestId } = data;\n\n        const blob = await this.blobStore.get(hash);\n        if (blob) {\n          // Send Response\n          const payload = new TextEncoder().encode(\n            JSON.stringify({\n              hash,\n              requestId,\n              blob: bytesToBase64(blob),\n              recipient: senderId, // Add recipient for relay routing\n            }),\n          );\n\n          const responseMsg: Message = {\n            header: {\n              version: 0x01,\n              type: MessageType.RESPONSE_BLOB,\n              ttl: this.defaultTTL,\n              timestamp: Date.now(),\n              senderId: this.identity.publicKey,\n              signature: new Uint8Array(64),\n            },\n            payload,\n          };\n          const msgBytes = encodeMessage(responseMsg);\n          responseMsg.header.signature = signMessage(\n            msgBytes,\n            this.identity.privateKey,\n          );\n          const encoded = encodeMessage(responseMsg);\n\n          await this.transportManager.send(senderId, encoded);\n        }\n      } catch (e) {\n        console.error(\"Error handling REQUEST_BLOB\", e);\n      }\n    } else if (message.header.type === MessageType.RESPONSE_BLOB) {\n      try {\n        const data = JSON.parse(new TextDecoder().decode(message.payload));\n        const { hash: _hash, requestId, blob } = data;\n\n        const pending = this.pendingBlobRequests.get(requestId);\n        if (pending) {\n          const blobBuffer = base64ToBytes(blob);\n          // Verify hash? Ideally yes.\n          pending.resolve(blobBuffer);\n          clearTimeout(pending.timeout);\n          this.pendingBlobRequests.delete(requestId);\n        }\n      } catch (e) {\n        console.error(\"Error processing RESPONSE_BLOB\", e);\n      }\n    }\n  }\n\n  /**\n   * Request a blob from a specific peer\n   */\n  async requestBlob(\n    peerId: string,\n    hash: string,\n    timeoutMs: number = 5000,\n  ): Promise<Uint8Array | null> {\n    const requestId = Math.random().toString(36).substring(7);\n\n    return new Promise<Uint8Array | null>((resolve, reject) => {\n      const timeout = setTimeout(() => {\n        this.pendingBlobRequests.delete(requestId);\n        // Don't reject, just return null if not found/timed out? Or reject.\n        // For a DHT/Content fetch, null might be better if just \"not found here\".\n        // But explicit timeout is useful.\n        resolve(null);\n      }, timeoutMs);\n\n      this.pendingBlobRequests.set(requestId, { resolve, reject, timeout });\n\n      const payload = new TextEncoder().encode(\n        JSON.stringify({\n          hash,\n          requestId,\n        }),\n      );\n\n      const message: Message = {\n        header: {\n          version: 0x01,\n          type: MessageType.REQUEST_BLOB,\n          ttl: this.defaultTTL,\n          timestamp: Date.now(),\n          senderId: this.identity.publicKey,\n          signature: new Uint8Array(64),\n        },\n        payload,\n      };\n\n      const msgBytes = encodeMessage(message);\n      message.header.signature = signMessage(\n        msgBytes,\n        this.identity.privateKey,\n      );\n      const encoded = encodeMessage(message);\n\n      this.transportManager.send(peerId, encoded).catch((e) => {\n        clearTimeout(timeout);\n        this.pendingBlobRequests.delete(requestId);\n        reject(e);\n      });\n    });\n  }\n\n  /**\n   * Register callback for discovery updates\n   */\n  onDiscoveryUpdate(callback: (peers: string[]) => void): void {\n    this.discoveryUpdateListeners.add(callback);\n  }\n\n  /**\n   * Unregister callback for discovery updates\n   */\n  offDiscoveryUpdate(callback: (peers: string[]) => void): void {\n    this.discoveryUpdateListeners.delete(callback);\n  }\n\n  /**\n   * Add media stream to peer connection\n   */\n  async addStreamToPeer(peerId: string, stream: MediaStream): Promise<void> {\n    const peer = this.webrtcTransport.getPool().getPeer(peerId);\n    if (!peer) {\n      throw new Error(`Peer ${peerId} not found`);\n    }\n\n    stream.getTracks().forEach((track) => {\n      peer.addTrack(track, stream);\n    });\n\n    // If connection is already established, we might need to renegotiate\n    // But for now, we assume this is called before or during connection setup\n    // Or that the browser handles renegotiation (which requires sending a new offer)\n\n    // Trigger renegotiation if connected\n    if (peer.getState() === \"connected\") {\n      const offer = await peer.createOffer();\n      await this.sendMessage(\n        peerId,\n        JSON.stringify({\n          type: \"SIGNAL\",\n          signal: { type: \"offer\", sdp: offer },\n        }),\n      );\n    }\n  }\n\n  /**\n   * Get connected peers\n   */\n  getConnectedPeers(): Peer[] {\n    return this.routingTable.getAllPeers();\n  }\n\n  /**\n   * Get a specific peer by ID\n   */\n  getPeer(peerId: string): Peer | undefined {\n    return this.routingTable.getPeer(peerId);\n  }\n\n  /**\n   * Get comprehensive network statistics for monitoring and scaling\n   */\n  async getStats() {\n    const now = Date.now();\n    const uptime = now - this.sessionTimestamp;\n    const dhtTable = this.routingTable.getDHTRoutingTable();\n    const dhtStats = dhtTable?.getStats ? dhtTable.getStats() : undefined;\n    const dhtNodeCount = dhtStats?.nodeCount ?? 0;\n\n    return {\n      localPeerId: this.localPeerId,\n      uptime,\n      sessionTimestamp: this.sessionTimestamp,\n      messagesSent: this.messagesSent,\n      messagesReceived: this.messagesReceived,\n      bytesTransferred: this.bytesTransferred,\n      routing: this.routingTable.getStats(),\n      relay: this.messageRelay.getStats(),\n      peers: await this.webrtcTransport.getPool().getStats(),\n      dht: this.dht\n        ? {\n            nodeId: bytesToHex(publicKeyToNodeId(this.identity.publicKey)),\n            nodeCount: dhtNodeCount,\n          }\n        : null,\n      performance: {\n        maxPeers: this.maxPeers,\n        currentPeers: this.routingTable.getAllPeers().length,\n        connectedPeers: this.routingTable.getAllPeers().filter(p => p.state === 'connected').length,\n        defaultTTL: this.defaultTTL,\n        messageQueueSize: 10000, // Default from config\n        rateLimitPerPeer: 100, // Default from config\n      },\n    };\n  }\n\n  async handleIceCandidate(peerId: string, candidate: RTCIceCandidateInit): Promise<void> {\n    try {\n      const signalingData = {\n        type: \"candidate\" as const,\n        data: candidate,\n        from: peerId,\n        to: this.localPeerId,\n      };\n      \n      await this.webrtcTransport.handleSignaling(signalingData);\n    } catch (error) {\n      console.warn(`[MeshNetwork] Failed to process ICE candidate for ${peerId}:`, error);\n    }\n  }\n\n  // ===== SESSION MANAGEMENT (Single-Session Enforcement) =====\n\n  /**\n   * Generate a unique session ID\n   */\n  private generateSessionId(): string {\n    const randomBytes = new Uint8Array(16);\n    crypto.getRandomValues(randomBytes);\n    return Array.from(randomBytes)\n      .map((b) => b.toString(16).padStart(2, \"0\"))\n      .join(\"\");\n  }\n\n  /**\n   * Start broadcasting session presence\n   */\n  private startSessionPresence(): void {\n    // Clear existing interval if any\n    if (this.sessionPresenceInterval)\n      clearInterval(this.sessionPresenceInterval);\n\n    // Broadcast immediately\n    this.broadcastSessionPresence();\n\n    // Then broadcast every 30 seconds\n    this.sessionPresenceInterval = setInterval(() => {\n      this.broadcastSessionPresence();\n    }, 30000);\n\n    // Allow Node.js to exit cleanly\n    try {\n      if (\n        this.sessionPresenceInterval &&\n        typeof (this.sessionPresenceInterval as any).unref === \"function\"\n      ) {\n        (this.sessionPresenceInterval as any).unref();\n      }\n    } catch (e) {\n      /* no-op */\n    }\n  }\n\n  /**\n   * Stop broadcasting session presence\n   */\n  private stopSessionPresence(): void {\n    if (this.sessionPresenceInterval) {\n      clearInterval(this.sessionPresenceInterval);\n      this.sessionPresenceInterval = null;\n    }\n  }\n\n  /**\n   * Broadcast session presence to all connected peers\n   */\n  private async broadcastSessionPresence(): Promise<void> {\n    try {\n      const payload = JSON.stringify({\n        sessionId: this.sessionId,\n        timestamp: this.sessionTimestamp,\n        identityFingerprint: bytesToHex(this.identity.publicKey),\n      });\n\n      const payloadBytes = new TextEncoder().encode(payload);\n      const message: Message = {\n        header: {\n          version: 0x01,\n          type: MessageType.SESSION_PRESENCE,\n          ttl: this.defaultTTL,\n          timestamp: Date.now(),\n          senderId: this.identity.publicKey,\n          signature: new Uint8Array(64),\n        },\n        payload: payloadBytes,\n      };\n\n      // Sign and broadcast\n      // Note: We encode twice because signature must be computed over the message\n      // without the signature field populated, then we set the signature and encode again\n      const messageBytes = encodeMessage(message);\n      message.header.signature = signMessage(\n        messageBytes,\n        this.identity.privateKey,\n      );\n      const encodedMessage = encodeMessage(message);\n\n      // Broadcast to all connected peers\n      this.routingTable.getAllPeers().forEach((peer) => {\n        if (\n          peer.state === PeerState.CONNECTED ||\n          peer.state === PeerState.DEGRADED\n        ) {\n          this.transportManager.send(peer.id, encodedMessage).catch(() => {});\n        }\n      });\n    } catch (error) {\n      console.error(\"Failed to broadcast session presence:\", error);\n    }\n  }\n\n  /**\n   * Handle incoming session presence message\n   */\n  private handleSessionPresence(fromPeerId: string, payload: any): void {\n    try {\n      const data = JSON.parse(new TextDecoder().decode(payload));\n      const { sessionId, timestamp, identityFingerprint } = data;\n\n      // Get our own identity fingerprint\n      const ourFingerprint = bytesToHex(this.identity.publicKey);\n\n      // Check if this is a duplicate session of our identity\n      if (\n        identityFingerprint === ourFingerprint &&\n        sessionId !== this.sessionId\n      ) {\n        // Another session with our identity exists!\n        // Determine which session should be invalidated\n        let shouldInvalidate = false;\n\n        if (timestamp > this.sessionTimestamp) {\n          // Their timestamp is newer - invalidate this session\n          shouldInvalidate = true;\n        } else if (timestamp === this.sessionTimestamp) {\n          // Race condition: same timestamp (e.g., simultaneous logins)\n          // Use sessionId lexicographic comparison as deterministic tie-breaker\n          shouldInvalidate = sessionId > this.sessionId;\n        }\n\n        if (shouldInvalidate) {\n          console.warn(\n            `Detected newer session for our identity. Invalidating this session.\n            Our session: ${this.sessionId} (${new Date(this.sessionTimestamp).toISOString()})\n            New session: ${sessionId} (${new Date(timestamp).toISOString()})`,\n          );\n\n          // Call the invalidation callback\n          if (this.onSessionInvalidatedCallback) {\n            this.onSessionInvalidatedCallback();\n          }\n\n          // Shutdown this instance\n          this.shutdown();\n        } else {\n          // Our session is newer - the other session should invalidate itself\n          console.info(\n            `Detected older session for our identity. Our session is newer - keeping it.\n            Our session: ${this.sessionId} (${new Date(this.sessionTimestamp).toISOString()})\n            Old session: ${sessionId} (${new Date(timestamp).toISOString()})`,\n          );\n        }\n      }\n    } catch (error) {\n      console.error(\"Failed to handle session presence:\", error);\n    }\n  }\n\n  /**\n   * Register callback for session invalidation\n   */\n  onSessionInvalidated(callback: () => void): void {\n    this.onSessionInvalidatedCallback = callback;\n  }\n\n  /**\n   * Disconnect from all peers and shut down\n   */\n  shutdown(): void {\n    this.transportManager.stop().catch(console.error);\n    this.routingTable.getAllPeers().forEach((peer: Peer) => {\n      this.routingTable.removePeer(peer.id);\n    });\n    this.stopHeartbeat();\n    this.stopSessionPresence();\n  } /**\n   * Get local identity\n   */\n  getIdentity(): IdentityKeyPair {\n    return this.identity;\n  }\n\n  /**\n   * Get local peer ID\n   */\n  getLocalPeerId(): string {\n    return this.localPeerId;\n  }\n\n  /**\n   * Get public key\n   */\n  getPublicKey(): Uint8Array {\n    return this.identity.publicKey;\n  }\n\n  /**\n   * Get peer count\n   */\n  getPeerCount(): number {\n    return this.routingTable.getAllPeers().length;\n  }\n\n  /**\n   * Bootstrap the network by finding closest peers to self in DHT\n   */\n  async bootstrap(): Promise<void> {\n    console.log(\"Bootstrapping DHT...\");\n    const peers = await this.dht.findNode(this.localPeerId);\n    console.log(`DHT Bootstrap complete. Found ${peers.length} peers.`);\n\n    // Attempt connections to discovered peers\n    // Attempt connections to discovered peers\n    for (const peer of peers) {\n      if (peer.id !== this.localPeerId && !this.routingTable.getPeer(peer.id)) {\n        // We know about them, but aren't connected.\n        // If we have connection info (metadata implies we might, currently we don't store it fully in DHT response)\n        // In full impl, FIND_NODE return values include IP/signal info.\n        // For now, if we found them via DHT, it means someone else knows them.\n        // We rely on the fact that `dht.ts` added them to routing table.\n        // We may trigger connection attempts here if we have a way to signal them.\n\n        // If we found them, we might want to try connecting if we are below maxPeers\n        if (this.routingTable.getAllPeers().length < this.maxPeers) {\n          // connection logic would go here if we had signaling info\n          // For this version, just populating the routing table (done in DHT) is the first step.\n        }\n      }\n    }\n  }\n\n  /**\n   * Get the DHT instance\n   */\n  getDHT(): DHT {\n    return this.dht;\n  }\n\n  /**\n   * Send text message\n   */\n  async sendTextMessage(recipientId: string, text: string): Promise<void> {\n    return this.sendMessage(recipientId, text);\n  }\n\n  /**\n   * Send binary message\n   */\n  async sendBinaryMessage(\n    recipientId: string,\n    data: Uint8Array,\n    type: MessageType = MessageType.FILE_CHUNK,\n  ): Promise<void> {\n    const message: Message = {\n      header: {\n        version: 0x01,\n        type: type,\n        ttl: this.defaultTTL,\n        timestamp: Date.now(),\n        senderId: this.identity.publicKey,\n        signature: new Uint8Array(65),\n      },\n      payload: data,\n    };\n\n    const messageBytes = encodeMessage(message);\n    message.header.signature = signMessage(\n      messageBytes,\n      this.identity.privateKey,\n    );\n    const encodedMessage = encodeMessage(message);\n\n    const nextHop = this.routingTable.getNextHop(recipientId);\n\n    if (nextHop) {\n      // Direct route available\n      this.transportManager.send(nextHop, encodedMessage).catch((err) => {\n        console.warn(`Failed to send binary message to ${nextHop}:`, err);\n      });\n    } else {\n      // Broadcast to all peers (flood routing)\n      this.routingTable.getAllPeers().forEach((peer) => {\n        if (peer.state === \"connected\") {\n          this.transportManager.send(peer.id, encodedMessage).catch(() => {});\n        }\n      });\n    }\n  }\n\n  /**\n   * Broadcast message to all peers\n   */\n  async broadcastMessage(text: string): Promise<void> {\n    const payload = new TextEncoder().encode(text);\n    const message: Message = {\n      header: {\n        version: 0x01,\n        type: MessageType.TEXT,\n        ttl: this.defaultTTL,\n        timestamp: Date.now(),\n        senderId: this.identity.publicKey,\n        signature: new Uint8Array(65),\n      },\n      payload,\n    };\n\n    const messageBytes = encodeMessage(message);\n    message.header.signature = signMessage(\n      messageBytes,\n      this.identity.privateKey,\n    );\n    const encodedMessage = encodeMessage(message);\n\n    this.routingTable.getAllPeers().forEach((peer) => {\n      if (peer.state === \"connected\") {\n        this.transportManager.send(peer.id, encodedMessage).catch(() => {});\n      }\n    });\n  }\n\n  /**\n   * Disconnect from a specific peer\n   */\n  async disconnectFromPeer(peerId: string): Promise<void> {\n    // Shim: Manually verify specific transport removal\n    // Ideally this should differ to TransportManager\n    this.webrtcTransport.getPool().removePeer(peerId);\n\n    this.routingTable.removePeer(peerId);\n  }\n\n  /**\n   * Disconnect from all peers\n   */\n  async disconnectAll(): Promise<void> {\n    this.shutdown();\n  }\n\n  /**\n   * Check if connected to a peer\n   */\n  isConnectedToPeer(peerId: string): boolean {\n    const peer = this.routingTable.getPeer(peerId);\n    return Boolean(peer && peer.state === \"connected\");\n  }\n\n  /**\n   * Get network statistics\n   */\n  getStatistics() {\n    return {\n      peerCount: this.getPeerCount(),\n      messagesSent: this.messagesSent,\n      messagesReceived: this.messagesReceived,\n      bytesTransferred: this.bytesTransferred,\n    };\n  }\n\n  /**\n   * Start the network\n   */\n  async start(): Promise<void> {\n    await this.transportManager.start();\n    this.startHeartbeat();\n    this.startSessionPresence();\n    this.startConnectionHealthMonitoring();\n    this.messageRelay.start(); // Start sneakernet message retry\n  }\n\n  /**\n   * Start connection health monitoring for rock-solid connections\n   */\n  private startConnectionHealthMonitoring(): void {\n    if (this.connectionHealthCheckInterval) {\n      clearInterval(this.connectionHealthCheckInterval);\n    }\n\n    this.connectionHealthCheckInterval = setInterval(() => {\n      this.performConnectionHealthCheck();\n    }, this.HEALTH_CHECK_INTERVAL);\n\n    console.log('[MeshNetwork]  Started connection health monitoring');\n  }\n\n  /**\n   * Perform comprehensive connection health check\n   */\n  private performConnectionHealthCheck(): void {\n    const now = Date.now();\n    const connectedPeers = this.routingTable.getAllPeers().filter(p => p.state === 'connected');\n    \n    console.log(`[MeshNetwork]  Health check: ${connectedPeers.length} connected peers`);\n\n    for (const peer of connectedPeers) {\n      const lastSeen = peer.lastSeen || 0;\n      const connectionAge = now - lastSeen;\n      const attempts = this.connectionAttempts.get(peer.id) || 0;\n      \n      // Check for stale connections\n      if (connectionAge > this.CONNECTION_TIMEOUT) {\n        console.warn(`[MeshNetwork]  Stale connection detected for ${peer.id} (${connectionAge}ms ago)`);\n        \n        if (attempts < this.MAX_CONNECTION_ATTEMPTS) {\n          console.log(`[MeshNetwork]  Attempting to recover connection to ${peer.id}`);\n          this.attemptConnectionRecovery(peer.id);\n        } else {\n          console.error(`[MeshNetwork]  Too many failed attempts for ${peer.id}, disconnecting`);\n          this.routingTable.removePeer(peer.id);\n          this.peerDisconnectedListeners.forEach(listener => listener(peer.id));\n        }\n      } else {\n        // Reset connection attempts for healthy connections\n        this.connectionAttempts.delete(peer.id);\n        this.lastConnectionAttempt.delete(peer.id);\n      }\n    }\n  }\n\n  /**\n   * Attempt to recover a failing connection\n   */\n  private async attemptConnectionRecovery(peerId: string): Promise<void> {\n    const attempts = (this.connectionAttempts.get(peerId) || 0) + 1;\n    this.connectionAttempts.set(peerId, attempts);\n    this.lastConnectionAttempt.set(peerId, Date.now());\n\n    try {\n      console.log(`[MeshNetwork]  Recovery attempt ${attempts}/${this.MAX_CONNECTION_ATTEMPTS} for ${peerId}`);\n      \n      // Remove old peer entry\n      this.routingTable.removePeer(peerId);\n      \n      // Try to reconnect via transport\n      await this.transportManager.connect(peerId);\n      \n      // Wait a bit for connection to establish\n      await new Promise(resolve => setTimeout(resolve, 2000));\n      \n      // Check if connection was successful\n      const peer = this.routingTable.getPeer(peerId);\n      if (peer && peer.state === 'connected') {\n        console.log(`[MeshNetwork]  Successfully recovered connection to ${peerId}`);\n        this.connectionAttempts.delete(peerId);\n        this.lastConnectionAttempt.delete(peerId);\n      } else {\n        throw new Error('Connection not established after recovery attempt');\n      }\n    } catch (error) {\n      console.error(`[MeshNetwork]  Recovery attempt ${attempts} failed for ${peerId}:`, error);\n      \n      if (attempts >= this.MAX_CONNECTION_ATTEMPTS) {\n        console.error(`[MeshNetwork]  Giving up on connection to ${peerId} after ${attempts} attempts`);\n        this.routingTable.removePeer(peerId);\n        this.peerDisconnectedListeners.forEach(listener => listener(peerId));\n      }\n    }\n  }\n\n  /**\n   * Stop the network\n   */\n  async stop(): Promise<void> {\n    // Clean up connection health monitoring\n    if (this.connectionHealthCheckInterval) {\n      clearInterval(this.connectionHealthCheckInterval);\n      this.connectionHealthCheckInterval = undefined;\n    }\n    \n    // Stop message relay retry process\n    this.messageRelay.stop();\n    \n    this.shutdown();\n  }\n\n  // --- Manual Connection Methods (WAN Support) ---\n\n  /**\n   * Initiate a manual connection to a peer (for WAN/Serverless).\n   * Returns the SDP Offer to be shared with the remote peer.\n   */\n  async createManualConnection(peerId: string): Promise<string> {\n    if (this.routingTable.getAllPeers().length >= this.maxPeers) {\n      throw new Error(\"Maximum number of peers reached\");\n    }\n\n    // Create or get peer connection\n    // Manual connection is specifically WEBRTC feature, so we access shim.\n    // IMPORTANT: if we already have a peer connection for this peer, recreate it\n    // before generating a new offer. Generating multiple offers / re-creating data\n    // channels on an existing RTCPeerConnection can cause SDP m-line order mismatch.\n    const pool = this.webrtcTransport.getPool();\n    if (typeof (pool as any).has === \"function\" && (pool as any).has(peerId)) {\n      try {\n        const maybePromise = (pool as any).removePeer(peerId);\n        if (maybePromise && typeof maybePromise.then === \"function\") {\n          await maybePromise;\n        }\n      } catch (e) {\n        // no-op\n      }\n    }\n    const peer = pool.getOrCreatePeer(peerId);\n\n    // Manual connection flow explicitly controls offer/answer exchange.\n    // Disable automatic renegotiation offers during initial setup to avoid\n    // concurrent offers and SDP m-line order mismatch.\n    try {\n      if ((peer as any).connection && typeof (peer as any).connection === \"object\") {\n        (peer as any).connection.onnegotiationneeded = null;\n      }\n    } catch {\n      // no-op\n    }\n\n    // Create data channels\n    peer.createDataChannel({ label: \"reliable\", ordered: true });\n    peer.createDataChannel({\n      label: \"unreliable\",\n      ordered: false,\n      maxRetransmits: 0,\n    });\n\n    // Create offer\n    await peer.createOffer();\n\n    // Set up state change handler to ensure peer is registered when connected\n    peer.onStateChange((state: string) => {\n      if (state === \"connected\") {\n        this.handlePeerConnected(peerId);\n      } else if (\n        state === \"disconnected\" ||\n        state === \"failed\" ||\n        state === \"closed\"\n      ) {\n        this.handlePeerDisconnected(peerId);\n      }\n    });\n\n    // Wait for ICE gathering to complete (so candidates are included in SDP)\n    await peer.waitForIceGathering();\n    const offer = await peer.getLocalDescription();\n\n    // Return the offer wrapped with metadata\n    return JSON.stringify({\n      type: \"offer\",\n      peerId: this.localPeerId,\n      sdp: offer,\n    });\n  }\n\n  /**\n   * Register a callback for signaling (ICE candidates, offers, answers) to be sent via external channel\n   */\n  registerSignalingCallback(\n    callback: (peerId: string, signal: { type: string; candidate?: RTCIceCandidateInit; sdp?: RTCSessionDescriptionInit }) => Promise<void>,\n  ): void {\n    this.signalingCallback = callback;\n  }\n\n  /**\n   * Register a callback for outbound messages via external transport (e.g., Native BLE)\n   */\n  registerOutboundTransport(\n    callback: (peerId: string, data: Uint8Array) => Promise<void>,\n  ): void {\n    this.outboundTransportCallback = callback;\n  }\n\n  /**\n   * Handle incoming raw packet from external transport (e.g., Native BLE)\n   */\n  async handleIncomingPacket(peerId: string, data: Uint8Array): Promise<void> {\n    // Treat as if received from peer pool\n    await this.messageRelay.processMessage(data, peerId);\n\n    // Update metrics or checking if we need to add to table?\n    // processMessage handles relay logic.\n    // We should ensure the peer exists in routing table?\n    // If it's a new peer sending us data, we might want to ensure they are \"connected\"\n    if (!this.routingTable.getPeer(peerId)) {\n      // We received data from an unknown peer via native transport.\n      // The DiscoveryManager or native bridge shoutd ideally register them first.\n      // But we can implicitly register or update last seen.\n      // For now, let's assume Discovery handled registration or we just let it flow.\n    }\n  }\n\n  /**\n   * Accept a manual connection offer.\n   * Returns the SDP Answer to be sent back to the initiator.\n   */\n  async acceptManualConnection(offerData: string): Promise<string> {\n    const payload = JSON.parse(offerData);\n    const { peerId, sdp } = payload;\n\n    if (!peerId || !sdp || sdp.type !== \"offer\") {\n      throw new Error(\"Invalid manual offer data\");\n    }\n\n    // Create peer connection\n    const peer = this.webrtcTransport.getPool().getOrCreatePeer(peerId);\n\n    // Set remote description (Offer)\n    await peer.setRemoteDescription(sdp);\n\n    // Create answer\n    await peer.createAnswer();\n\n    // Set up state change handler to ensure peer is registered when connected\n    peer.onStateChange((state: string) => {\n      if (state === \"connected\") {\n        this.handlePeerConnected(peerId);\n      } else if (\n        state === \"disconnected\" ||\n        state === \"failed\" ||\n        state === \"closed\"\n      ) {\n        this.handlePeerDisconnected(peerId);\n      }\n    });\n\n    // Wait for ICE gathering\n    await peer.waitForIceGathering();\n    const answer = await peer.getLocalDescription();\n\n    // Return the answer wrapped with metadata\n    return JSON.stringify({\n      type: \"answer\",\n      peerId: this.localPeerId,\n      sdp: answer,\n    });\n  }\n\n  /**\n   * Finalize a manual connection with the answer.\n   */\n  async finalizeManualConnection(answerData: string): Promise<void> {\n    const payload = JSON.parse(answerData);\n    const { peerId, sdp } = payload;\n\n    if (!peerId || !sdp || sdp.type !== \"answer\") {\n      throw new Error(\"Invalid manual answer data\");\n    }\n\n    const peer = this.webrtcTransport.getPool().getPeer(peerId);\n    if (!peer) {\n      throw new Error(`Peer ${peerId} not found (connection not initiated?)`);\n    }\n\n    await peer.setRemoteAnswer(sdp);\n  }\n\n  // --- DHT Operations ---\n\n  /**\n   * Store a value in the DHT\n   */\n  async dhtStore(key: string, value: Uint8Array): Promise<void> {\n    await this.dht.store(key, value);\n  }\n\n  /**\n   * Find a value in the DHT\n   */\n  async dhtFindValue(key: string): Promise<Uint8Array | null> {\n    return this.dht.findValue(key);\n  }\n\n  /**\n   * Find a node in the DHT\n   */\n  async dhtFindNode(nodeId: string): Promise<Peer | undefined> {\n    const peers = await this.dht.findNode(nodeId);\n    return peers.find((p) => p.id === nodeId);\n  }\n\n  /**\n   * Send a file to a peer\n   */\n  async sendFile(peerId: string, file: File | Uint8Array): Promise<string> {\n    return this.transferManager.sendFile(peerId, file);\n  }\n}\n"],"version":3}