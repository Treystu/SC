{"file":"/Users/christymaxwell/Desktop/Luke_Stuff/GitHub/SC/core/src/mesh/routing.ts","mappings":";AAAA;;GAEG;;;AAkDH,gCA2BC;AA3ED,uDAAqD;AAErD,6CAIwB;AACxB,+CAA4C;AAE5C,IAAY,SAKX;AALD,WAAY,SAAS;IACnB,sCAAyB,CAAA;IACzB,oCAAuB,CAAA;IACvB,kCAAqB,CAAA;IACrB,0CAA6B,CAAA;AAC/B,CAAC,EALW,SAAS,yBAAT,SAAS,QAKpB;AA+BD;;GAEG;AACH,SAAgB,UAAU,CACxB,EAAU,EACV,SAAqB,EACrB,gBAAkD,QAAQ;IAE1D,OAAO;QACL,EAAE;QACF,SAAS;QACT,QAAQ,EAAE,IAAI,CAAC,GAAG,EAAE;QACpB,WAAW,EAAE,IAAI,CAAC,GAAG,EAAE;QACvB,aAAa;QACb,iBAAiB,EAAE,GAAG;QACtB,SAAS,EAAE,CAAC;QACZ,aAAa,EAAE,CAAC;QAChB,KAAK,EAAE,SAAS,CAAC,SAAS;QAC1B,QAAQ,EAAE;YACR,YAAY,EAAE;gBACZ,mBAAmB,EAAE,CAAC,aAAa,CAAC;gBACpC,eAAe,EAAE,CAAC;gBAClB,QAAQ,EAAE,EAAE;aACb;YACD,UAAU,EAAE,EAAE;YACd,WAAW,EAAE,KAAK;YAClB,YAAY,EAAE,CAAC;YACf,YAAY,EAAE,CAAC;SAChB;KACF,CAAC;AACJ,CAAC;AAmBD;;GAEG;AACH,IAAY,WAOX;AAPD,WAAY,WAAW;IACrB,gDAAgD;IAChD,8BAAe,CAAA;IACf,iCAAiC;IACjC,0BAAW,CAAA;IACX,wDAAwD;IACxD,gCAAiB,CAAA;AACnB,CAAC,EAPW,WAAW,2BAAX,WAAW,QAOtB;AAcD;;GAEG;AACH,MAAa,YAAY;IAcvB,YAAY,WAAmB,EAAE,SAAwB,EAAE;QAbnD,WAAM,GAAuB,IAAI,GAAG,EAAE,CAAC;QACvC,UAAK,GAAsB,IAAI,GAAG,EAAE,CAAC;QACrC,iBAAY,GAAwB,IAAI,GAAG,EAAE,CAAC,CAAC,oBAAoB;QACnE,gBAAW,GAAgB,IAAI,GAAG,EAAE,CAAC,CAAC,sBAAsB;QAWlE,IAAI,CAAC,WAAW,GAAG,WAAW,CAAC;QAC/B,IAAI,CAAC,cAAc,GAAG,MAAM,CAAC,YAAY,IAAI,KAAK,CAAC;QACnD,IAAI,CAAC,SAAS,GAAG,MAAM,CAAC,QAAQ,IAAI,MAAM,CAAC,CAAC,sDAAsD;QAClG,IAAI,CAAC,SAAS,GAAG,MAAM,CAAC,QAAQ,IAAI,MAAM,CAAC,CAAC,YAAY;QACxD,IAAI,CAAC,UAAU,GAAG,MAAM,CAAC,SAAS,IAAI,KAAK,CAAC;QAC5C,IAAI,CAAC,YAAY,GAAG,MAAM,CAAC,iBAAiB,KAAK,KAAK,CAAC;QACvD,IAAI,CAAC,IAAI,GAAG,MAAM,CAAC,IAAI,IAAI,WAAW,CAAC,KAAK,CAAC;QAC7C,IAAI,CAAC,eAAe,GAAG,MAAM,CAAC,eAAe,CAAC;QAE9C,yBAAyB;QACzB,IACE,CAAC,IAAI,CAAC,IAAI,KAAK,WAAW,CAAC,GAAG,IAAI,IAAI,CAAC,IAAI,KAAK,WAAW,CAAC,MAAM,CAAC;YACnE,CAAC,IAAI,CAAC,eAAe,EACrB,CAAC;YACD,MAAM,IAAI,KAAK,CAAC,kCAAkC,IAAI,CAAC,IAAI,OAAO,CAAC,CAAC;QACtE,CAAC;IACH,CAAC;IAED;;OAEG;IACH,OAAO,CAAC,IAAU;QAChB,yDAAyD;QACzD,MAAM,YAAY,GAAG,IAAI,CAAC,EAAE,CAAC,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC,WAAW,EAAE,CAAC;QAC9D,MAAM,UAAU,GAAG,IAAI,CAAC,EAAE,CAAC,CAAC,2BAA2B;QAEvD,oCAAoC;QACpC,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE,CAAC;YAChB,IAAI,CAAC,KAAK,GAAG,SAAS,CAAC,SAAS,CAAC;QACnC,CAAC;QACD,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC;YACnB,IAAI,CAAC,QAAQ,GAAG;gBACd,YAAY,EAAE;oBACZ,mBAAmB,EAAE,CAAC,IAAI,CAAC,aAAa,CAAC;oBACzC,eAAe,EAAE,CAAC;oBAClB,QAAQ,EAAE,EAAE;iBACb;gBACD,UAAU,EAAE,EAAE;gBACd,WAAW,EAAE,KAAK;gBAClB,YAAY,EAAE,CAAC;gBACf,YAAY,EAAE,CAAC;aAChB,CAAC;QACJ,CAAC;QAED,wEAAwE;QACxE,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,YAAY,EAAE,IAAI,CAAC,CAAC;QACnC,iCAAiC;QACjC,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,YAAY,EAAE;YAC5B,WAAW,EAAE,YAAY;YACzB,OAAO,EAAE,UAAU,EAAE,oCAAoC;YACzD,QAAQ,EAAE,CAAC;YACX,SAAS,EAAE,IAAI,CAAC,GAAG,EAAE;YACrB,OAAO,EAAE;gBACP,QAAQ,EAAE,CAAC;gBACX,OAAO,EAAE,CAAC;gBACV,WAAW,EAAE,GAAG;gBAChB,SAAS,EAAE,CAAC;gBACZ,QAAQ,EAAE,IAAI,CAAC,GAAG,EAAE;aACrB;YACD,SAAS,EAAE,IAAI,CAAC,GAAG,EAAE,GAAG,IAAI,CAAC,SAAS;SACvC,CAAC,CAAC;QAEH,wDAAwD;QACxD,IACE,IAAI,CAAC,eAAe;YACpB,CAAC,IAAI,CAAC,IAAI,KAAK,WAAW,CAAC,GAAG,IAAI,IAAI,CAAC,IAAI,KAAK,WAAW,CAAC,MAAM,CAAC,EACnE,CAAC;YACD,IAAI,IAAA,yBAAc,EAAC,IAAI,CAAC,EAAE,CAAC;gBACzB,MAAM,UAAU,GAAG,IAAA,2BAAgB,EAAC,IAAI,CAAC,CAAC;gBAC1C,4DAA4D;gBAC5D,IAAI,CAAC,eAAe,CAAC,UAAU,CAAC,UAAU,CAAC,CAAC;YAC9C,CAAC;QACH,CAAC;IACH,CAAC;IAED;;OAEG;IACH,UAAU,CAAC,MAAc;QACvB,0CAA0C;QAC1C,MAAM,YAAY,GAAG,MAAM,CAAC,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC,WAAW,EAAE,CAAC;QAC7D,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,YAAY,CAAC,CAAC;QAChC,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,YAAY,CAAC,CAAC;QACjC,0CAA0C;QAC1C,KAAK,MAAM,CAAC,IAAI,EAAE,KAAK,CAAC,IAAI,IAAI,CAAC,MAAM,CAAC,OAAO,EAAE,EAAE,CAAC;YAClD,IAAI,KAAK,CAAC,OAAO,KAAK,YAAY,EAAE,CAAC;gBACnC,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;YAC3B,CAAC;QACH,CAAC;IACH,CAAC;IAED;;OAEG;IACH,OAAO,CAAC,MAAc;QACpB,0CAA0C;QAC1C,MAAM,YAAY,GAAG,MAAM,CAAC,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC,WAAW,EAAE,CAAC;QAC7D,OAAO,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC;IACtC,CAAC;IAED;;OAEG;IACH,WAAW;QACT,OAAO,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE,CAAC,CAAC;IACzC,CAAC;IAED;;OAEG;IACH,kBAAkB,CAAC,MAAc;QAC/B,0CAA0C;QAC1C,MAAM,YAAY,GAAG,MAAM,CAAC,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC,WAAW,EAAE,CAAC;QAC7D,MAAM,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC;QAC1C,IAAI,IAAI,EAAE,CAAC;YACT,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;QAC7B,CAAC;IACH,CAAC;IAED;;OAEG;IACH,QAAQ,CAAC,KAAY;QACnB,MAAM,QAAQ,GAAG,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,KAAK,CAAC,WAAW,CAAC,CAAC;QAEpD,6CAA6C;QAC7C,MAAM,YAAY,GAAG,CAAC,QAAQ,IAAI,IAAI,CAAC,kBAAkB,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC;QAE3E,IAAI,YAAY,EAAE,CAAC;YACjB,0BAA0B;YAC1B,IAAI,CAAC,KAAK,CAAC,SAAS,EAAE,CAAC;gBACrB,KAAK,CAAC,SAAS,GAAG,IAAI,CAAC,GAAG,EAAE,GAAG,IAAI,CAAC,SAAS,CAAC;YAChD,CAAC;YAED,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,KAAK,CAAC,WAAW,EAAE,KAAK,CAAC,CAAC;YAC1C,IAAI,CAAC,oBAAoB,EAAE,CAAC;QAC9B,CAAC;IACH,CAAC;IAED;;OAEG;IACK,kBAAkB,CAAC,QAAe,EAAE,QAAe;QACzD,qCAAqC;QACrC,IAAI,QAAQ,CAAC,SAAS,GAAG,IAAI,CAAC,GAAG,EAAE,EAAE,CAAC;YACpC,OAAO,IAAI,CAAC;QACd,CAAC;QAED,gCAAgC;QAChC,IAAI,QAAQ,CAAC,OAAO,CAAC,QAAQ,GAAG,QAAQ,CAAC,OAAO,CAAC,QAAQ,EAAE,CAAC;YAC1D,OAAO,IAAI,CAAC;QACd,CAAC;QAED,0CAA0C;QAC1C,IAAI,QAAQ,CAAC,OAAO,CAAC,QAAQ,KAAK,QAAQ,CAAC,OAAO,CAAC,QAAQ,EAAE,CAAC;YAC5D,IAAI,QAAQ,CAAC,OAAO,CAAC,OAAO,GAAG,QAAQ,CAAC,OAAO,CAAC,OAAO,EAAE,CAAC;gBACxD,OAAO,IAAI,CAAC;YACd,CAAC;YAED,6CAA6C;YAC7C,IAAI,QAAQ,CAAC,OAAO,CAAC,OAAO,KAAK,QAAQ,CAAC,OAAO,CAAC,OAAO,EAAE,CAAC;gBAC1D,IAAI,QAAQ,CAAC,OAAO,CAAC,WAAW,GAAG,QAAQ,CAAC,OAAO,CAAC,WAAW,EAAE,CAAC;oBAChE,OAAO,IAAI,CAAC;gBACd,CAAC;gBAED,+CAA+C;gBAC/C,MAAM,KAAK,GAAG,QAAQ,CAAC,OAAO,CAAC,SAAS,IAAI,CAAC,CAAC;gBAC9C,MAAM,UAAU,GAAG,QAAQ,CAAC,OAAO,CAAC,SAAS,IAAI,CAAC,CAAC;gBACnD,IACE,QAAQ,CAAC,OAAO,CAAC,WAAW,KAAK,QAAQ,CAAC,OAAO,CAAC,WAAW;oBAC7D,KAAK,GAAG,UAAU,EAClB,CAAC;oBACD,OAAO,IAAI,CAAC;gBACd,CAAC;YACH,CAAC;YAED,uCAAuC;YACvC,IACE,QAAQ,CAAC,OAAO,CAAC,OAAO,KAAK,QAAQ,CAAC,OAAO,CAAC,OAAO;gBACrD,QAAQ,CAAC,OAAO,CAAC,WAAW,KAAK,QAAQ,CAAC,OAAO,CAAC,WAAW;gBAC7D,CAAC,QAAQ,CAAC,OAAO,CAAC,SAAS,IAAI,CAAC,CAAC;oBAC/B,CAAC,QAAQ,CAAC,OAAO,CAAC,SAAS,IAAI,CAAC,CAAC;gBACnC,QAAQ,CAAC,SAAS,GAAG,QAAQ,CAAC,SAAS,EACvC,CAAC;gBACD,OAAO,IAAI,CAAC;YACd,CAAC;QACH,CAAC;QAED,OAAO,KAAK,CAAC;IACf,CAAC;IAED;;OAEG;IACK,oBAAoB;QAC1B,IAAI,IAAI,CAAC,MAAM,CAAC,IAAI,GAAG,IAAI,CAAC,UAAU,EAAE,CAAC;YACvC,OAAO;QACT,CAAC;QAED,MAAM,GAAG,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;QACvB,MAAM,QAAQ,GAAa,EAAE,CAAC;QAE9B,KAAK,MAAM,CAAC,IAAI,EAAE,KAAK,CAAC,IAAI,IAAI,CAAC,MAAM,CAAC,OAAO,EAAE,EAAE,CAAC;YAClD,IAAI,KAAK,CAAC,SAAS,GAAG,GAAG,EAAE,CAAC;gBAC1B,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;YACtB,CAAC;QACH,CAAC;QAED,QAAQ,CAAC,OAAO,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC;QAErD,yDAAyD;QACzD,IAAI,IAAI,CAAC,MAAM,CAAC,IAAI,IAAI,IAAI,CAAC,UAAU,EAAE,CAAC;YACxC,MAAM,MAAM,GAAG,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,OAAO,EAAE,CAAC,CAAC,IAAI,CACnD,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,QAAQ,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,QAAQ,CACxD,CAAC;YAEF,MAAM,WAAW,GAAG,IAAI,CAAC,MAAM,CAAC,IAAI,GAAG,IAAI,CAAC,UAAU,GAAG,GAAG,CAAC;YAC7D,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,WAAW,IAAI,CAAC,GAAG,MAAM,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;gBAC1D,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;YACnC,CAAC;QACH,CAAC;IACH,CAAC;IAED;;OAEG;IACH,kBAAkB,CAChB,WAAmB,EACnB,OAAe,EACf,OAAgB,EAChB,SAAkB;QAElB,iDAAiD;QACjD,MAAM,cAAc,GAAG,WAAW,CAAC,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC,WAAW,EAAE,CAAC;QACpE,MAAM,KAAK,GAAG,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,cAAc,CAAC,CAAC;QAC9C,IAAI,KAAK,EAAE,CAAC;YACV,KAAK,CAAC,OAAO,CAAC,OAAO,GAAG,OAAO,CAAC;YAChC,KAAK,CAAC,OAAO,CAAC,QAAQ,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;YAEpC,qDAAqD;YACrD,MAAM,KAAK,GAAG,GAAG,CAAC;YAClB,KAAK,CAAC,OAAO,CAAC,WAAW;gBACvB,KAAK,GAAG,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC,OAAO,CAAC,WAAW,CAAC;YAEtE,IAAI,SAAS,KAAK,SAAS,EAAE,CAAC;gBAC5B,KAAK,CAAC,OAAO,CAAC,SAAS,GAAG,SAAS,CAAC;YACtC,CAAC;YAED,oDAAoD;YACpD,MAAM,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,cAAc,CAAC,CAAC;YAC5C,IAAI,IAAI,EAAE,CAAC;gBACT,IAAI,OAAO,EAAE,CAAC;oBACZ,IAAI,CAAC,QAAQ,CAAC,YAAY,IAAI,CAAC,CAAC;oBAChC,IAAI,CAAC,QAAQ,CAAC,UAAU,GAAG,IAAI,CAAC,GAAG,CAAC,GAAG,EAAE,IAAI,CAAC,QAAQ,CAAC,UAAU,GAAG,CAAC,CAAC,CAAC;gBACzE,CAAC;qBAAM,CAAC;oBACN,IAAI,CAAC,QAAQ,CAAC,YAAY,IAAI,CAAC,CAAC;oBAChC,IAAI,CAAC,QAAQ,CAAC,UAAU,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC,QAAQ,CAAC,UAAU,GAAG,CAAC,CAAC,CAAC;oBAErE,+CAA+C;oBAC/C,IAAI,IAAI,CAAC,QAAQ,CAAC,UAAU,GAAG,EAAE,IAAI,IAAI,CAAC,KAAK,KAAK,SAAS,CAAC,SAAS,EAAE,CAAC;wBACxE,IAAI,CAAC,KAAK,GAAG,SAAS,CAAC,QAAQ,CAAC;oBAClC,CAAC;gBACH,CAAC;YACH,CAAC;QACH,CAAC;IACH,CAAC;IAED;;OAEG;IACH,UAAU,CAAC,WAAmB;QAC5B,iDAAiD;QACjD,MAAM,cAAc,GAAG,WAAW,CAAC,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC,WAAW,EAAE,CAAC;QACpE,MAAM,KAAK,GAAG,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,cAAc,CAAC,IAAI,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC;QAC9E,yDAAyD;QACzD,OAAO,KAAK,EAAE,OAAO,CAAC;IACxB,CAAC;IAED;;;OAGG;IACH,cAAc,CAAC,WAAmB;QAChC,0BAA0B;QAC1B,IAAI,IAAI,CAAC,YAAY,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,WAAW,CAAC,EAAE,CAAC;YAC5D,OAAO,KAAK,CAAC;QACf,CAAC;QACD,OAAO,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC;IAC5C,CAAC;IAED;;OAEG;IACH,eAAe,CAAC,WAAmB;QACjC,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,WAAW,EAAE,IAAI,CAAC,GAAG,EAAE,CAAC,CAAC;QAE/C,IAAI,IAAI,CAAC,YAAY,EAAE,CAAC;YACtB,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC;QACpC,CAAC;QAED,IAAI,CAAC,mBAAmB,EAAE,CAAC;IAC7B,CAAC;IAED;;OAEG;IACK,mBAAmB;QACzB,MAAM,GAAG,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;QAEvB,0DAA0D;QAC1D,IAAI,IAAI,CAAC,YAAY,CAAC,IAAI,GAAG,IAAI,CAAC,cAAc,EAAE,CAAC;YACjD,MAAM,QAAQ,GAAa,EAAE,CAAC;YAC9B,KAAK,MAAM,CAAC,IAAI,EAAE,SAAS,CAAC,IAAI,IAAI,CAAC,YAAY,CAAC,OAAO,EAAE,EAAE,CAAC;gBAC5D,IAAI,GAAG,GAAG,SAAS,GAAG,IAAI,CAAC,SAAS,EAAE,CAAC;oBACrC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;gBACtB,CAAC;YACH,CAAC;YACD,QAAQ,CAAC,OAAO,CAAC,CAAC,IAAI,EAAE,EAAE;gBACxB,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;gBAC/B,IAAI,IAAI,CAAC,YAAY,EAAE,CAAC;oBACtB,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;gBAChC,CAAC;YACH,CAAC,CAAC,CAAC;YACH,OAAO;QACT,CAAC;QAED,oDAAoD;QACpD,MAAM,OAAO,GAAG,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC,OAAO,EAAE,CAAC,CAAC,IAAI,CAC1D,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CACtB,CAAC;QAEF,MAAM,WAAW,GAAG,IAAI,CAAC,YAAY,CAAC,IAAI,GAAG,IAAI,CAAC,cAAc,GAAG,GAAG,CAAC;QACvE,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,WAAW,IAAI,CAAC,GAAG,OAAO,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;YAC3D,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;YACxC,IAAI,IAAI,CAAC,YAAY,EAAE,CAAC;gBACtB,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;YACzC,CAAC;QACH,CAAC;IACH,CAAC;IAED;;OAEG;IACH,oBAAoB,CAAC,MAAc,EAAE,OAAgB;QACnD,0CAA0C;QAC1C,MAAM,YAAY,GAAG,MAAM,CAAC,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC,WAAW,EAAE,CAAC;QAC7D,MAAM,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC;QAC1C,IAAI,CAAC,IAAI;YAAE,OAAO;QAElB,IAAI,OAAO,EAAE,CAAC;YACZ,IAAI,CAAC,QAAQ,CAAC,YAAY,EAAE,CAAC;YAC7B,IAAI,CAAC,QAAQ,CAAC,UAAU,GAAG,IAAI,CAAC,GAAG,CAAC,GAAG,EAAE,IAAI,CAAC,QAAQ,CAAC,UAAU,GAAG,CAAC,CAAC,CAAC;QACzE,CAAC;aAAM,CAAC;YACN,IAAI,CAAC,QAAQ,CAAC,YAAY,EAAE,CAAC;YAC7B,IAAI,CAAC,QAAQ,CAAC,UAAU,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC,QAAQ,CAAC,UAAU,GAAG,CAAC,CAAC,CAAC;QACvE,CAAC;QAED,wCAAwC;QACxC,IAAI,IAAI,CAAC,QAAQ,CAAC,UAAU,GAAG,EAAE,EAAE,CAAC;YAClC,IAAI,CAAC,KAAK,GAAG,SAAS,CAAC,QAAQ,CAAC;QAClC,CAAC;aAAM,IACL,IAAI,CAAC,KAAK,KAAK,SAAS,CAAC,QAAQ;YACjC,IAAI,CAAC,QAAQ,CAAC,UAAU,GAAG,EAAE,EAC7B,CAAC;YACD,IAAI,CAAC,KAAK,GAAG,SAAS,CAAC,SAAS,CAAC;QACnC,CAAC;IACH,CAAC;IAED;;OAEG;IACH,aAAa,CAAC,MAAc,EAAE,UAAmB;QAC/C,0CAA0C;QAC1C,MAAM,YAAY,GAAG,MAAM,CAAC,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC,WAAW,EAAE,CAAC;QAC7D,MAAM,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC;QAC1C,IAAI,CAAC,IAAI;YAAE,OAAO;QAElB,IAAI,CAAC,QAAQ,CAAC,WAAW,GAAG,IAAI,CAAC;QACjC,IAAI,UAAU,EAAE,CAAC;YACf,IAAI,CAAC,QAAQ,CAAC,eAAe,GAAG,IAAI,CAAC,GAAG,EAAE,GAAG,UAAU,CAAC;QAC1D,CAAC;QACD,IAAI,CAAC,KAAK,GAAG,SAAS,CAAC,YAAY,CAAC;IACtC,CAAC;IAED;;OAEG;IACH,eAAe,CAAC,MAAc;QAC5B,0CAA0C;QAC1C,MAAM,YAAY,GAAG,MAAM,CAAC,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC,WAAW,EAAE,CAAC;QAC7D,MAAM,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC;QAC1C,IAAI,CAAC,IAAI;YAAE,OAAO;QAElB,IAAI,CAAC,QAAQ,CAAC,WAAW,GAAG,KAAK,CAAC;QAClC,IAAI,CAAC,QAAQ,CAAC,eAAe,GAAG,SAAS,CAAC;IAC5C,CAAC;IAED;;OAEG;IACH,iBAAiB;QACf,MAAM,GAAG,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;QACvB,KAAK,MAAM,IAAI,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE,EAAE,CAAC;YACvC,IACE,IAAI,CAAC,QAAQ,CAAC,WAAW;gBACzB,IAAI,CAAC,QAAQ,CAAC,eAAe;gBAC7B,IAAI,CAAC,QAAQ,CAAC,eAAe,GAAG,GAAG,EACnC,CAAC;gBACD,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;YAChC,CAAC;QACH,CAAC;IACH,CAAC;IAED;;OAEG;IACH,iBAAiB,CAAC,MAAc;QAC9B,0CAA0C;QAC1C,MAAM,YAAY,GAAG,MAAM,CAAC,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC,WAAW,EAAE,CAAC;QAC7D,MAAM,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC;QAC1C,IAAI,CAAC,IAAI;YAAE,OAAO,KAAK,CAAC;QAExB,eAAe;QACf,IAAI,IAAI,CAAC,QAAQ,CAAC,WAAW,IAAI,IAAI,CAAC,QAAQ,CAAC,eAAe,EAAE,CAAC;YAC/D,IAAI,IAAI,CAAC,QAAQ,CAAC,eAAe,GAAG,IAAI,CAAC,GAAG,EAAE,EAAE,CAAC;gBAC/C,IAAI,CAAC,eAAe,CAAC,MAAM,CAAC,CAAC;gBAC7B,OAAO,KAAK,CAAC;YACf,CAAC;QACH,CAAC;QAED,OAAO,IAAI,CAAC,QAAQ,CAAC,WAAW,CAAC;IACnC,CAAC;IAED;;OAEG;IACH,gBAAgB,CAAC,YAAoB,KAAK;QACxC,MAAM,GAAG,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;QACvB,MAAM,KAAK,GAAa,EAAE,CAAC;QAE3B,KAAK,MAAM,CAAC,aAAa,EAAE,IAAI,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,OAAO,EAAE,EAAE,CAAC;YACzD,IAAI,GAAG,GAAG,IAAI,CAAC,QAAQ,GAAG,SAAS,EAAE,CAAC;gBACpC,sDAAsD;gBACtD,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;YACtB,CAAC;QACH,CAAC;QAED,8BAA8B;QAC9B,KAAK,CAAC,OAAO,CAAC,CAAC,MAAM,EAAE,EAAE;YACvB,MAAM,YAAY,GAAG,MAAM,CAAC,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC,WAAW,EAAE,CAAC;YAC7D,IAAI,CAAC,UAAU,CAAC,YAAY,CAAC,CAAC;QAChC,CAAC,CAAC,CAAC;QACH,OAAO,KAAK,CAAC;IACf,CAAC;IAED;;OAEG;IACH,cAAc;QACZ,MAAM,SAAS,GAAG;YAChB,MAAM,EAAE,IAAI,CAAC,MAAM,CAAC,IAAI,GAAG,GAAG,EAAE,6BAA6B;YAC7D,KAAK,EAAE,IAAI,CAAC,KAAK,CAAC,IAAI,GAAG,GAAG,EAAE,4BAA4B;YAC1D,YAAY,EAAE,IAAI,CAAC,YAAY,CAAC,IAAI,GAAG,EAAE,EAAE,4BAA4B;YACvE,WAAW,EAAE,IAAI,CAAC,WAAW,CAAC,IAAI,GAAG,EAAE;SACxC,CAAC;QAEF,MAAM,KAAK,GAAG,MAAM,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC,MAAM,CAAC,CAAC,GAAG,EAAE,GAAG,EAAE,EAAE,CAAC,GAAG,GAAG,GAAG,EAAE,CAAC,CAAC,CAAC;QAC1E,OAAO,EAAE,KAAK,EAAE,SAAS,EAAE,CAAC;IAC9B,CAAC;IAED;;OAEG;IACH,QAAQ;QACN,OAAO;YACL,SAAS,EAAE,IAAI,CAAC,KAAK,CAAC,IAAI;YAC1B,UAAU,EAAE,IAAI,CAAC,MAAM,CAAC,IAAI;YAC5B,SAAS,EAAE,IAAI,CAAC,YAAY,CAAC,IAAI;YACjC,WAAW,EAAE,IAAI,CAAC,cAAc,EAAE,CAAC,KAAK;SACzC,CAAC;IACJ,CAAC;IAED;;OAEG;IACH,cAAc;QACZ,OAAO,IAAI,CAAC,IAAI,CAAC;IACnB,CAAC;IAED;;OAEG;IACH,kBAAkB;QAChB,OAAO,IAAI,CAAC,eAAe,CAAC;IAC9B,CAAC;IAED;;OAEG;IACH,YAAY;QACV,OAAO,IAAI,CAAC,IAAI,KAAK,WAAW,CAAC,GAAG,IAAI,IAAI,CAAC,IAAI,KAAK,WAAW,CAAC,MAAM,CAAC;IAC3E,CAAC;IAED;;OAEG;IACH,KAAK,CAAC,cAAc,CAAC,YAAoB;QACvC,IAAI,CAAC,IAAI,CAAC,eAAe,EAAE,CAAC;YAC1B,MAAM,IAAI,KAAK,CAAC,kCAAkC,CAAC,CAAC;QACtD,CAAC;QAED,0EAA0E;QAC1E,4DAA4D;QAC5D,MAAM,QAAQ,GAAG,IAAI,CAAC,WAAW,EAAE,CAAC;QACpC,MAAM,UAAU,GAAG,IAAI,CAAC,OAAO,CAAC,YAAY,CAAC,CAAC;QAE9C,IAAI,UAAU,EAAE,CAAC;YACf,OAAO,CAAC,UAAU,CAAC,CAAC;QACtB,CAAC;QAED,2DAA2D;QAC3D,OAAO,QAAQ,CAAC,KAAK,CAAC,CAAC,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,QAAQ,CAAC,MAAM,CAAC,CAAC,CAAC;IACzD,CAAC;IAED;;;;;;;OAOG;IACH,uBAAuB,CAAC,QAAgB;QACtC,MAAM,KAAK,GAAG,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE,CAAC,CAAC;QAC9C,MAAM,SAAS,GAAG,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;QAE5C,0BAA0B;QAC1B,MAAM,UAAU,GAAG,IAAI,GAAG,EAAkB,CAAC;QAE7C,KAAK,MAAM,IAAI,IAAI,KAAK,EAAE,CAAC;YACzB,IAAI,IAAI,CAAC,KAAK,KAAK,SAAS,CAAC,YAAY,EAAE,CAAC;gBAC1C,UAAU,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC;gBAC5B,SAAS;YACX,CAAC;YAED,IAAI,KAAK,GAAG,CAAC,CAAC;YAEd,qCAAqC;YACrC,qEAAqE;YACrE,KAAK,IAAI,IAAI,CAAC,iBAAiB,IAAI,EAAE,CAAC;YAEtC,2EAA2E;YAC3E,iDAAiD;YACjD,wGAAwG;YACxG,uDAAuD;YACvD,0DAA0D;YAC1D,iDAAiD;YACjD,IAAI,IAAI,CAAC,KAAK,KAAK,SAAS,CAAC,QAAQ,EAAE,CAAC;gBACtC,MAAM,aAAa,GAAG,GAAG,GAAG,CAAC,IAAI,CAAC,iBAAiB,IAAI,EAAE,CAAC,CAAC;gBAC3D,KAAK,IAAI,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,aAAa,GAAG,CAAC,CAAC,CAAC;YAC1C,CAAC;YAED,iCAAiC;YACjC,IAAI,IAAI,CAAC,EAAE,KAAK,QAAQ,EAAE,CAAC;gBACzB,KAAK,IAAI,IAAI,CAAC;YAChB,CAAC;YAED,sDAAsD;YACtD,8EAA8E;YAC9E,iCAAiC;YAEjC,kCAAkC;YAClC,gDAAgD;YAChD,IAAI,SAAS,IAAI,SAAS,CAAC,OAAO,KAAK,IAAI,CAAC,EAAE,EAAE,CAAC;gBAC/C,iEAAiE;gBACjE,MAAM,gBAAgB,GAAG,CAAC,IAAI,CAAC,iBAAiB,IAAI,EAAE,CAAC,GAAG,GAAG,CAAC;gBAC9D,KAAK,IAAI,GAAG,GAAG,gBAAgB,CAAC;YAClC,CAAC;YAED,qEAAqE;YACrE,uDAAuD;YAEvD,+CAA+C;YAC/C,IAAI,SAAS,IAAI,SAAS,CAAC,OAAO,CAAC,SAAS,EAAE,CAAC;gBAC7C,2DAA2D;gBAC3D,KAAK,IAAI,IAAI,CAAC,GAAG,CAAC,GAAG,EAAE,SAAS,CAAC,OAAO,CAAC,SAAS,GAAG,MAAM,CAAC,CAAC;YAC/D,CAAC;YAED,yCAAyC;YACzC,IAAI,IAAI,CAAC,QAAQ,CAAC,YAAY,CAAC,YAAY,EAAE,CAAC;gBAC5C,KAAK,IAAI,IAAI,CAAC,GAAG,CACf,EAAE,EACF,IAAI,CAAC,QAAQ,CAAC,YAAY,CAAC,YAAY,GAAG,OAAO,CAClD,CAAC,CAAC,oBAAoB;YACzB,CAAC;YAED,+BAA+B;YAC/B,mDAAmD;YACnD,IAAI,IAAI,CAAC,aAAa,KAAK,OAAO,EAAE,CAAC;gBACnC,KAAK,IAAI,EAAE,CAAC,CAAC,wBAAwB;YACvC,CAAC;iBAAM,IAAI,IAAI,CAAC,aAAa,KAAK,WAAW,EAAE,CAAC;gBAC9C,KAAK,IAAI,EAAE,CAAC,CAAC,6CAA6C;YAC5D,CAAC;YAED,UAAU,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,EAAE,KAAK,CAAC,CAAC;QACjC,CAAC;QAED,OAAO,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE;YACzB,MAAM,MAAM,GAAG,UAAU,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,IAAI,CAAC,CAAC;YACzC,MAAM,MAAM,GAAG,UAAU,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,IAAI,CAAC,CAAC;YAEzC,iEAAiE;YACjE,4EAA4E;YAC5E,IAAI,IAAI,CAAC,GAAG,CAAC,MAAM,GAAG,MAAM,CAAC,GAAG,EAAE,EAAE,CAAC;gBACnC,OAAO,MAAM,GAAG,MAAM,CAAC;YACzB,CAAC;YAED,6DAA6D;YAC7D,MAAM,KAAK,GAAG,IAAA,yBAAW,EAAC,QAAQ,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC;YAC1C,MAAM,KAAK,GAAG,IAAA,yBAAW,EAAC,QAAQ,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC;YAE1C,OAAO,KAAK,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QACpD,CAAC,CAAC,CAAC;IACL,CAAC;IAED;;;OAGG;IACH,gBAAgB,CAAC,QAAgB,EAAE,QAAgB,EAAE;QACnD,kEAAkE;QAClE,IAAI,IAAI,CAAC,eAAe,EAAE,CAAC;YACzB,IAAI,CAAC;gBACH,MAAM,SAAS,GAAG,IAAA,yBAAc,EAAC,QAAQ,CAAC,CAAC;gBAC3C,MAAM,QAAQ,GAAG,IAAI,CAAC,eAAe,CAAC,kBAAkB,CACtD,SAAS,EACT,KAAK,CACN,CAAC;gBAEF,qCAAqC;gBACrC,mFAAmF;gBACnF,OAAO,QAAQ,CAAC,GAAG,CAAC,CAAC,OAAO,EAAE,EAAE;oBAC9B,MAAM,YAAY,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;oBACpD,IAAI,YAAY;wBAAE,OAAO,YAAY,CAAC;oBAEtC,6CAA6C;oBAC7C,IAAI,SAAS,GAAI,OAAO,CAAC,SAAS,EAAE,CAAC,CAAC,CAAC,EAAE,IAAY,IAAI,QAAQ,CAAC;oBAClE,IAAI,SAAS,KAAK,QAAQ;wBAAE,SAAS,GAAG,QAAQ,CAAC;oBAEjD,OAAO,UAAU,CACf,OAAO,CAAC,MAAM,EACd,IAAI,UAAU,CAAC,CAAC,CAAC,EAAE,kCAAkC;oBACrD,SAAS,CACV,CAAC;gBACJ,CAAC,CAAC,CAAC;YACL,CAAC;YAAC,OAAO,CAAC,EAAE,CAAC;gBACX,OAAO,CAAC,IAAI,CAAC,gDAAgD,EAAE,CAAC,CAAC,CAAC;YACpE,CAAC;QACH,CAAC;QAED,sDAAsD;QACtD,6CAA6C;QAC7C,MAAM,KAAK,GAAG,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE,CAAC,CAAC;QAE9C,qBAAqB;QACrB,MAAM,UAAU,GAAG,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,IAAI,CAAC,iBAAiB,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QAEtE,OAAO,UAAU;aACd,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE;YACb,MAAM,KAAK,GAAG,IAAA,yBAAW,EAAC,QAAQ,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC;YAC1C,MAAM,KAAK,GAAG,IAAA,yBAAW,EAAC,QAAQ,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC;YAC1C,OAAO,KAAK,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QACpD,CAAC,CAAC;aACD,KAAK,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC;IACrB,CAAC;CACF;AAlrBD,oCAkrBC;AAED;;GAEG;AACH,MAAa,YAAY;IAAzB;QACU,WAAM,GAGV,IAAI,GAAG,EAAE,CAAC;QACG,eAAU,GAAG;YAC5B,wBAAW,CAAC,YAAY;YACxB,wBAAW,CAAC,YAAY;YACxB,wBAAW,CAAC,WAAW;YACvB,wBAAW,CAAC,KAAK;YACjB,wBAAW,CAAC,IAAI;YAChB,wBAAW,CAAC,UAAU;YACtB,wBAAW,CAAC,aAAa;SAC1B,CAAC;QACe,yBAAoB,GAAG,KAAK,CAAC,CAAC,aAAa;QAC3C,8BAAyB,GAAG,IAAI,CAAC,CAAC,YAAY;QACvD,wBAAmB,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;IAwH3C,CAAC;IAtHC,OAAO,CAAC,WAAwB,EAAE,OAAY;QAC5C,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,WAAW,CAAC,EAAE,CAAC;YAClC,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,WAAW,EAAE,EAAE,CAAC,CAAC;QACnC,CAAC;QACD,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,WAAW,CAAE,CAAC,IAAI,CAAC;YACjC,OAAO;YACP,SAAS,EAAE,IAAI,CAAC,GAAG,EAAE;YACrB,gBAAgB,EAAE,WAAW;SAC9B,CAAC,CAAC;IACL,CAAC;IAED,OAAO;QACL,oCAAoC;QACpC,MAAM,GAAG,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;QACvB,IAAI,GAAG,GAAG,IAAI,CAAC,mBAAmB,GAAG,IAAI,CAAC,yBAAyB,EAAE,CAAC;YACpE,IAAI,CAAC,iBAAiB,EAAE,CAAC;YACzB,IAAI,CAAC,mBAAmB,GAAG,GAAG,CAAC;QACjC,CAAC;QAED,mCAAmC;QACnC,KAAK,MAAM,QAAQ,IAAI,IAAI,CAAC,UAAU,EAAE,CAAC;YACvC,MAAM,KAAK,GAAG,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;YACxC,IAAI,KAAK,IAAI,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;gBAC9B,MAAM,IAAI,GAAG,KAAK,CAAC,KAAK,EAAE,CAAC;gBAC3B,OAAO,IAAI,EAAE,OAAO,IAAI,IAAI,CAAC;YAC/B,CAAC;QACH,CAAC;QACD,OAAO,IAAI,CAAC;IACd,CAAC;IAED;;OAEG;IACK,iBAAiB;QACvB,MAAM,GAAG,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;QAEvB,6CAA6C;QAC7C,KAAK,IAAI,CAAC,GAAG,IAAI,CAAC,UAAU,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC;YACpD,MAAM,eAAe,GAAG,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;YAC3C,MAAM,KAAK,GAAG,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,eAAe,CAAC,CAAC;YAE/C,IAAI,CAAC,KAAK,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC;gBAAE,SAAS;YAE3C,MAAM,eAAe,GAIhB,EAAE,CAAC;YACR,MAAM,cAAc,GAIf,EAAE,CAAC;YAER,KAAK,MAAM,IAAI,IAAI,KAAK,EAAE,CAAC;gBACzB,MAAM,GAAG,GAAG,GAAG,GAAG,IAAI,CAAC,SAAS,CAAC;gBACjC,IAAI,GAAG,GAAG,IAAI,CAAC,oBAAoB,EAAE,CAAC;oBACpC,eAAe,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;gBAC7B,CAAC;qBAAM,CAAC;oBACN,cAAc,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;gBAC5B,CAAC;YACH,CAAC;YAED,uBAAuB;YACvB,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,eAAe,EAAE,cAAc,CAAC,CAAC;YAEjD,gDAAgD;YAChD,IAAI,eAAe,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;gBAC/B,MAAM,cAAc,GAAG,IAAI,CAAC,UAAU,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;gBAC9C,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,cAAc,CAAC,EAAE,CAAC;oBACrC,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,cAAc,EAAE,EAAE,CAAC,CAAC;gBACtC,CAAC;gBACD,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,cAAc,CAAE,CAAC,IAAI,CAAC,GAAG,eAAe,CAAC,CAAC;YAC5D,CAAC;QACH,CAAC;IACH,CAAC;IAED,IAAI;QACF,IAAI,KAAK,GAAG,CAAC,CAAC;QACd,KAAK,MAAM,KAAK,IAAI,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE,EAAE,CAAC;YACzC,KAAK,IAAI,KAAK,CAAC,MAAM,CAAC;QACxB,CAAC;QACD,OAAO,KAAK,CAAC;IACf,CAAC;IAED;;OAEG;IACH,iBAAiB;QACf,MAAM,KAAK,GAAG,IAAI,GAAG,EAAuB,CAAC;QAC7C,KAAK,MAAM,CAAC,QAAQ,EAAE,KAAK,CAAC,IAAI,IAAI,CAAC,MAAM,CAAC,OAAO,EAAE,EAAE,CAAC;YACtD,KAAK,CAAC,GAAG,CAAC,QAAQ,EAAE,KAAK,CAAC,MAAM,CAAC,CAAC;QACpC,CAAC;QACD,OAAO,KAAK,CAAC;IACf,CAAC;IAED;;OAEG;IACH,mBAAmB;QACjB,MAAM,GAAG,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;QACvB,IAAI,MAAM,GAAG,CAAC,CAAC;QAEf,KAAK,MAAM,KAAK,IAAI,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE,EAAE,CAAC;YACzC,KAAK,MAAM,IAAI,IAAI,KAAK,EAAE,CAAC;gBACzB,MAAM,GAAG,GAAG,GAAG,GAAG,IAAI,CAAC,SAAS,CAAC;gBACjC,IAAI,GAAG,GAAG,MAAM,EAAE,CAAC;oBACjB,MAAM,GAAG,GAAG,CAAC;gBACf,CAAC;YACH,CAAC;QACH,CAAC;QAED,OAAO,MAAM,CAAC;IAChB,CAAC;IAED,KAAK;QACH,IAAI,CAAC,MAAM,CAAC,KAAK,EAAE,CAAC;IACtB,CAAC;CACF;AAxID,oCAwIC","names":[],"sources":["/Users/christymaxwell/Desktop/Luke_Stuff/GitHub/SC/core/src/mesh/routing.ts"],"sourcesContent":["/**\n * Mesh networking core - routing table and peer management\n */\n\nimport { MessageType } from \"../protocol/message.js\";\nimport type { KademliaRoutingTable } from \"./dht/index.js\";\nimport {\n  peerToDHTContact,\n  isValidDHTPeer,\n  peerIdToDHTKey,\n} from \"./dht/index.js\";\nimport { xorDistance } from \"./kademlia.js\";\n\nexport enum PeerState {\n  CONNECTING = \"connecting\",\n  CONNECTED = \"connected\",\n  DEGRADED = \"degraded\",\n  DISCONNECTED = \"disconnected\",\n}\n\nexport interface PeerCapabilities {\n  maxBandwidth?: number;\n  supportedTransports: (\"webrtc\" | \"bluetooth\" | \"local\")[];\n  protocolVersion: number;\n  features: string[];\n}\n\nexport interface PeerMetadata {\n  capabilities: PeerCapabilities;\n  reputation: number; // 0-100, default 50\n  blacklisted: boolean;\n  blacklistExpiry?: number;\n  failureCount: number;\n  successCount: number;\n}\n\nexport interface Peer {\n  id: string; // Hex-encoded public key\n  publicKey: Uint8Array;\n  lastSeen: number;\n  connectedAt: number;\n  transportType: \"webrtc\" | \"bluetooth\" | \"local\";\n  connectionQuality: number; // 0-100\n  bytesSent: number;\n  bytesReceived: number;\n  state: PeerState;\n  metadata: PeerMetadata;\n}\n\n/**\n * Create a new peer with default values\n */\nexport function createPeer(\n  id: string,\n  publicKey: Uint8Array,\n  transportType: \"webrtc\" | \"bluetooth\" | \"local\" = \"webrtc\",\n): Peer {\n  return {\n    id,\n    publicKey,\n    lastSeen: Date.now(),\n    connectedAt: Date.now(),\n    transportType,\n    connectionQuality: 100,\n    bytesSent: 0,\n    bytesReceived: 0,\n    state: PeerState.CONNECTED,\n    metadata: {\n      capabilities: {\n        supportedTransports: [transportType],\n        protocolVersion: 1,\n        features: [],\n      },\n      reputation: 50,\n      blacklisted: false,\n      failureCount: 0,\n      successCount: 0,\n    },\n  };\n}\n\nexport interface RouteMetrics {\n  hopCount: number;\n  latency: number; // milliseconds\n  reliability: number; // 0-1, success rate\n  bandwidth?: number; // bytes per second (optional)\n  lastUsed: number;\n}\n\nexport interface Route {\n  destination: string;\n  nextHop: string;\n  hopCount: number;\n  timestamp: number;\n  metrics: RouteMetrics;\n  expiresAt: number;\n}\n\n/**\n * Routing mode for the mesh network\n */\nexport enum RoutingMode {\n  /** Traditional flood-based routing (default) */\n  FLOOD = \"flood\",\n  /** Kademlia DHT-based routing */\n  DHT = \"dht\",\n  /** Hybrid: use DHT for discovery, flood for delivery */\n  HYBRID = \"hybrid\",\n}\n\nexport interface RoutingConfig {\n  maxCacheSize?: number;\n  cacheTTL?: number;\n  routeTTL?: number;\n  maxRoutes?: number;\n  enableBloomFilter?: boolean;\n  /** Routing mode (default: FLOOD for backward compatibility) */\n  mode?: RoutingMode;\n  /** DHT routing table (required if mode is DHT or HYBRID) */\n  dhtRoutingTable?: KademliaRoutingTable;\n}\n\n/**\n * In-memory routing table for mesh network\n */\nexport class RoutingTable {\n  private routes: Map<string, Route> = new Map();\n  private peers: Map<string, Peer> = new Map();\n  private messageCache: Map<string, number> = new Map(); // hash -> timestamp\n  private bloomFilter: Set<string> = new Set(); // Simple bloom filter\n  private readonly MAX_CACHE_SIZE: number;\n  private readonly CACHE_TTL: number;\n  private readonly ROUTE_TTL: number;\n  private readonly MAX_ROUTES: number;\n  private readonly ENABLE_BLOOM: boolean;\n  private readonly mode: RoutingMode;\n  public readonly localNodeId: string;\n  private dhtRoutingTable?: KademliaRoutingTable;\n\n  constructor(localNodeId: string, config: RoutingConfig = {}) {\n    this.localNodeId = localNodeId;\n    this.MAX_CACHE_SIZE = config.maxCacheSize || 10000;\n    this.CACHE_TTL = config.cacheTTL || 600000; // 10 minutes (increased to exceed Relay storeTimeout)\n    this.ROUTE_TTL = config.routeTTL || 300000; // 5 minutes\n    this.MAX_ROUTES = config.maxRoutes || 10000;\n    this.ENABLE_BLOOM = config.enableBloomFilter !== false;\n    this.mode = config.mode || RoutingMode.FLOOD;\n    this.dhtRoutingTable = config.dhtRoutingTable;\n\n    // Validate configuration\n    if (\n      (this.mode === RoutingMode.DHT || this.mode === RoutingMode.HYBRID) &&\n      !this.dhtRoutingTable\n    ) {\n      throw new Error(`DHT routing table required for ${this.mode} mode`);\n    }\n  }\n\n  /**\n   * Add or update a peer\n   */\n  addPeer(peer: Peer): void {\n    // Normalize peer ID to uppercase for consistent matching\n    const normalizedId = peer.id.replace(/\\s/g, \"\").toUpperCase();\n    const originalId = peer.id; // Preserve original format\n    \n    // Ensure peer has required metadata\n    if (!peer.state) {\n      peer.state = PeerState.CONNECTED;\n    }\n    if (!peer.metadata) {\n      peer.metadata = {\n        capabilities: {\n          supportedTransports: [peer.transportType],\n          protocolVersion: 1,\n          features: [],\n        },\n        reputation: 50,\n        blacklisted: false,\n        failureCount: 0,\n        successCount: 0,\n      };\n    }\n\n    // Store peer with original ID format, but use normalized key for lookup\n    this.peers.set(normalizedId, peer);\n    // Direct route to connected peer\n    this.routes.set(normalizedId, {\n      destination: normalizedId,\n      nextHop: originalId, // Return original ID for getNextHop\n      hopCount: 0,\n      timestamp: Date.now(),\n      metrics: {\n        hopCount: 0,\n        latency: 0,\n        reliability: 1.0,\n        bandwidth: 0,\n        lastUsed: Date.now(),\n      },\n      expiresAt: Date.now() + this.ROUTE_TTL,\n    });\n\n    // If DHT mode is enabled, also add to DHT routing table\n    if (\n      this.dhtRoutingTable &&\n      (this.mode === RoutingMode.DHT || this.mode === RoutingMode.HYBRID)\n    ) {\n      if (isValidDHTPeer(peer)) {\n        const dhtContact = peerToDHTContact(peer);\n        // Add valid peer to DHT routing table in DHT or HYBRID mode\n        this.dhtRoutingTable.addContact(dhtContact);\n      }\n    }\n  }\n\n  /**\n   * Remove a peer\n   */\n  removePeer(peerId: string): void {\n    // Normalize peer ID for consistent lookup\n    const normalizedId = peerId.replace(/\\s/g, \"\").toUpperCase();\n    this.peers.delete(normalizedId);\n    this.routes.delete(normalizedId);\n    // Remove routes that go through this peer\n    for (const [dest, route] of this.routes.entries()) {\n      if (route.nextHop === normalizedId) {\n        this.routes.delete(dest);\n      }\n    }\n  }\n\n  /**\n   * Get a peer by ID\n   */\n  getPeer(peerId: string): Peer | undefined {\n    // Normalize peer ID for consistent lookup\n    const normalizedId = peerId.replace(/\\s/g, \"\").toUpperCase();\n    return this.peers.get(normalizedId);\n  }\n\n  /**\n   * Get all connected peers\n   */\n  getAllPeers(): Peer[] {\n    return Array.from(this.peers.values());\n  }\n\n  /**\n   * Update peer last seen timestamp\n   */\n  updatePeerLastSeen(peerId: string): void {\n    // Normalize peer ID for consistent lookup\n    const normalizedId = peerId.replace(/\\s/g, \"\").toUpperCase();\n    const peer = this.peers.get(normalizedId);\n    if (peer) {\n      peer.lastSeen = Date.now();\n    }\n  }\n\n  /**\n   * Add or update a route with conflict resolution\n   */\n  addRoute(route: Route): void {\n    const existing = this.routes.get(route.destination);\n\n    // Route conflict resolution based on metrics\n    const shouldUpdate = !existing || this.shouldReplaceRoute(existing, route);\n\n    if (shouldUpdate) {\n      // Ensure route has expiry\n      if (!route.expiresAt) {\n        route.expiresAt = Date.now() + this.ROUTE_TTL;\n      }\n\n      this.routes.set(route.destination, route);\n      this.cleanupExpiredRoutes();\n    }\n  }\n\n  /**\n   * Determine if new route should replace existing route\n   */\n  private shouldReplaceRoute(existing: Route, newRoute: Route): boolean {\n    // Check if existing route is expired\n    if (existing.expiresAt < Date.now()) {\n      return true;\n    }\n\n    // Prefer routes with fewer hops\n    if (newRoute.metrics.hopCount < existing.metrics.hopCount) {\n      return true;\n    }\n\n    // If same hop count, prefer lower latency\n    if (newRoute.metrics.hopCount === existing.metrics.hopCount) {\n      if (newRoute.metrics.latency < existing.metrics.latency) {\n        return true;\n      }\n\n      // If same latency, prefer higher reliability\n      if (newRoute.metrics.latency === existing.metrics.latency) {\n        if (newRoute.metrics.reliability > existing.metrics.reliability) {\n          return true;\n        }\n\n        // If same reliability, prefer higher bandwidth\n        const newBw = newRoute.metrics.bandwidth || 0;\n        const existingBw = existing.metrics.bandwidth || 0;\n        if (\n          newRoute.metrics.reliability === existing.metrics.reliability &&\n          newBw > existingBw\n        ) {\n          return true;\n        }\n      }\n\n      // If metrics equal, prefer newer route\n      if (\n        newRoute.metrics.latency === existing.metrics.latency &&\n        newRoute.metrics.reliability === existing.metrics.reliability &&\n        (newRoute.metrics.bandwidth || 0) ===\n          (existing.metrics.bandwidth || 0) &&\n        newRoute.timestamp > existing.timestamp\n      ) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Clean up expired routes\n   */\n  private cleanupExpiredRoutes(): void {\n    if (this.routes.size < this.MAX_ROUTES) {\n      return;\n    }\n\n    const now = Date.now();\n    const toDelete: string[] = [];\n\n    for (const [dest, route] of this.routes.entries()) {\n      if (route.expiresAt < now) {\n        toDelete.push(dest);\n      }\n    }\n\n    toDelete.forEach((dest) => this.routes.delete(dest));\n\n    // If still over limit, remove least recently used routes\n    if (this.routes.size >= this.MAX_ROUTES) {\n      const routes = Array.from(this.routes.entries()).sort(\n        (a, b) => a[1].metrics.lastUsed - b[1].metrics.lastUsed,\n      );\n\n      const removeCount = this.routes.size - this.MAX_ROUTES + 100;\n      for (let i = 0; i < removeCount && i < routes.length; i++) {\n        this.routes.delete(routes[i][0]);\n      }\n    }\n  }\n\n  /**\n   * Update route metrics\n   */\n  updateRouteMetrics(\n    destination: string,\n    latency: number,\n    success: boolean,\n    bandwidth?: number,\n  ): void {\n    // Normalize destination ID for consistent lookup\n    const normalizedDest = destination.replace(/\\s/g, \"\").toUpperCase();\n    const route = this.routes.get(normalizedDest);\n    if (route) {\n      route.metrics.latency = latency;\n      route.metrics.lastUsed = Date.now();\n\n      // Update reliability with exponential moving average\n      const alpha = 0.3;\n      route.metrics.reliability =\n        alpha * (success ? 1 : 0) + (1 - alpha) * route.metrics.reliability;\n\n      if (bandwidth !== undefined) {\n        route.metrics.bandwidth = bandwidth;\n      }\n\n      // Also update peer metadata for reputation tracking\n      const peer = this.peers.get(normalizedDest);\n      if (peer) {\n        if (success) {\n          peer.metadata.successCount += 1;\n          peer.metadata.reputation = Math.min(100, peer.metadata.reputation + 1);\n        } else {\n          peer.metadata.failureCount += 1;\n          peer.metadata.reputation = Math.max(0, peer.metadata.reputation - 2);\n          \n          // If reputation gets too low, mark as degraded\n          if (peer.metadata.reputation < 20 && peer.state === PeerState.CONNECTED) {\n            peer.state = PeerState.DEGRADED;\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Get next hop for a destination\n   */\n  getNextHop(destination: string): string | undefined {\n    // Normalize destination ID for consistent lookup\n    const normalizedDest = destination.replace(/\\s/g, \"\").toUpperCase();\n    const route = this.routes.get(normalizedDest) || this.routes.get(destination);\n    // Return the nextHop which stores the original ID format\n    return route?.nextHop;\n  }\n\n  /**\n   * Check if message has been seen (for deduplication)\n   * Uses Bloom filter for fast pre-check if enabled\n   */\n  hasSeenMessage(messageHash: string): boolean {\n    // Fast bloom filter check\n    if (this.ENABLE_BLOOM && !this.bloomFilter.has(messageHash)) {\n      return false;\n    }\n    return this.messageCache.has(messageHash);\n  }\n\n  /**\n   * Mark message as seen with LRU eviction\n   */\n  markMessageSeen(messageHash: string): void {\n    this.messageCache.set(messageHash, Date.now());\n\n    if (this.ENABLE_BLOOM) {\n      this.bloomFilter.add(messageHash);\n    }\n\n    this.cleanupMessageCache();\n  }\n\n  /**\n   * Clean up old entries from message cache with LRU eviction\n   */\n  private cleanupMessageCache(): void {\n    const now = Date.now();\n\n    // If cache is below max size, just remove expired entries\n    if (this.messageCache.size < this.MAX_CACHE_SIZE) {\n      const toDelete: string[] = [];\n      for (const [hash, timestamp] of this.messageCache.entries()) {\n        if (now - timestamp > this.CACHE_TTL) {\n          toDelete.push(hash);\n        }\n      }\n      toDelete.forEach((hash) => {\n        this.messageCache.delete(hash);\n        if (this.ENABLE_BLOOM) {\n          this.bloomFilter.delete(hash);\n        }\n      });\n      return;\n    }\n\n    // LRU eviction: sort by timestamp and remove oldest\n    const entries = Array.from(this.messageCache.entries()).sort(\n      (a, b) => a[1] - b[1],\n    );\n\n    const removeCount = this.messageCache.size - this.MAX_CACHE_SIZE + 100;\n    for (let i = 0; i < removeCount && i < entries.length; i++) {\n      this.messageCache.delete(entries[i][0]);\n      if (this.ENABLE_BLOOM) {\n        this.bloomFilter.delete(entries[i][0]);\n      }\n    }\n  }\n\n  /**\n   * Update peer reputation based on behavior\n   */\n  updatePeerReputation(peerId: string, success: boolean): void {\n    // Normalize peer ID for consistent lookup\n    const normalizedId = peerId.replace(/\\s/g, \"\").toUpperCase();\n    const peer = this.peers.get(normalizedId);\n    if (!peer) return;\n\n    if (success) {\n      peer.metadata.successCount++;\n      peer.metadata.reputation = Math.min(100, peer.metadata.reputation + 1);\n    } else {\n      peer.metadata.failureCount++;\n      peer.metadata.reputation = Math.max(0, peer.metadata.reputation - 2);\n    }\n\n    // Update peer state based on reputation\n    if (peer.metadata.reputation < 20) {\n      peer.state = PeerState.DEGRADED;\n    } else if (\n      peer.state === PeerState.DEGRADED &&\n      peer.metadata.reputation > 40\n    ) {\n      peer.state = PeerState.CONNECTED;\n    }\n  }\n\n  /**\n   * Blacklist a peer temporarily or permanently\n   */\n  blacklistPeer(peerId: string, durationMs?: number): void {\n    // Normalize peer ID for consistent lookup\n    const normalizedId = peerId.replace(/\\s/g, \"\").toUpperCase();\n    const peer = this.peers.get(normalizedId);\n    if (!peer) return;\n\n    peer.metadata.blacklisted = true;\n    if (durationMs) {\n      peer.metadata.blacklistExpiry = Date.now() + durationMs;\n    }\n    peer.state = PeerState.DISCONNECTED;\n  }\n\n  /**\n   * Remove peer from blacklist\n   */\n  unblacklistPeer(peerId: string): void {\n    // Normalize peer ID for consistent lookup\n    const normalizedId = peerId.replace(/\\s/g, \"\").toUpperCase();\n    const peer = this.peers.get(normalizedId);\n    if (!peer) return;\n\n    peer.metadata.blacklisted = false;\n    peer.metadata.blacklistExpiry = undefined;\n  }\n\n  /**\n   * Check and clean up expired blacklists\n   */\n  cleanupBlacklists(): void {\n    const now = Date.now();\n    for (const peer of this.peers.values()) {\n      if (\n        peer.metadata.blacklisted &&\n        peer.metadata.blacklistExpiry &&\n        peer.metadata.blacklistExpiry < now\n      ) {\n        this.unblacklistPeer(peer.id);\n      }\n    }\n  }\n\n  /**\n   * Check if peer is blacklisted\n   */\n  isPeerBlacklisted(peerId: string): boolean {\n    // Normalize peer ID for consistent lookup\n    const normalizedId = peerId.replace(/\\s/g, \"\").toUpperCase();\n    const peer = this.peers.get(normalizedId);\n    if (!peer) return false;\n\n    // Check expiry\n    if (peer.metadata.blacklisted && peer.metadata.blacklistExpiry) {\n      if (peer.metadata.blacklistExpiry < Date.now()) {\n        this.unblacklistPeer(peerId);\n        return false;\n      }\n    }\n\n    return peer.metadata.blacklisted;\n  }\n\n  /**\n   * Remove stale peers (haven't been seen recently)\n   */\n  removeStalepeers(timeoutMs: number = 60000): string[] {\n    const now = Date.now();\n    const stale: string[] = [];\n\n    for (const [_normalizedId, peer] of this.peers.entries()) {\n      if (now - peer.lastSeen > timeoutMs) {\n        // Return the original peer ID, not the normalized one\n        stale.push(peer.id);\n      }\n    }\n\n    // Remove using normalized IDs\n    stale.forEach((peerId) => {\n      const normalizedId = peerId.replace(/\\s/g, \"\").toUpperCase();\n      this.removePeer(normalizedId);\n    });\n    return stale;\n  }\n\n  /**\n   * Get memory usage statistics\n   */\n  getMemoryUsage(): { bytes: number; breakdown: Record<string, number> } {\n    const breakdown = {\n      routes: this.routes.size * 100, // Approximate size per route\n      peers: this.peers.size * 200, // Approximate size per peer\n      messageCache: this.messageCache.size * 50, // Approximate size per hash\n      bloomFilter: this.bloomFilter.size * 50,\n    };\n\n    const bytes = Object.values(breakdown).reduce((sum, val) => sum + val, 0);\n    return { bytes, breakdown };\n  }\n\n  /**\n   * Get routing table statistics\n   */\n  getStats() {\n    return {\n      peerCount: this.peers.size,\n      routeCount: this.routes.size,\n      cacheSize: this.messageCache.size,\n      memoryUsage: this.getMemoryUsage().bytes,\n    };\n  }\n\n  /**\n   * Get the current routing mode\n   */\n  getRoutingMode(): RoutingMode {\n    return this.mode;\n  }\n\n  /**\n   * Get the DHT routing table (if enabled)\n   */\n  getDHTRoutingTable(): KademliaRoutingTable | undefined {\n    return this.dhtRoutingTable;\n  }\n\n  /**\n   * Check if DHT routing is enabled\n   */\n  isDHTEnabled(): boolean {\n    return this.mode === RoutingMode.DHT || this.mode === RoutingMode.HYBRID;\n  }\n\n  /**\n   * Find peers via DHT lookup\n   */\n  async findPeerViaDHT(targetPeerId: string): Promise<Peer[]> {\n    if (!this.dhtRoutingTable) {\n      throw new Error('DHT routing table not configured');\n    }\n\n    // For now, return peers that are close to the target in the routing table\n    // In a real implementation, this would perform a DHT lookup\n    const allPeers = this.getAllPeers();\n    const targetPeer = this.getPeer(targetPeerId);\n    \n    if (targetPeer) {\n      return [targetPeer];\n    }\n\n    // Return a subset of peers (simulating DHT lookup results)\n    return allPeers.slice(0, Math.min(5, allPeers.length));\n  }\n\n  /**\n   * Get peers ranked by likelihood of reaching the target\n   * Scoring strategy: \"Score for NOW\" (Real-time Value > History)\n   * 1. Direct connection (Immediate Delivery)\n   * 2. Kademlia Proximity (Topological Potential)\n   * 3. Connection Quality (Current Health)\n   * 4. Route Table Next Hop (Routing Memory - only if healthy)\n   */\n  getRankedPeersForTarget(targetId: string): Peer[] {\n    const peers = Array.from(this.peers.values());\n    const bestRoute = this.routes.get(targetId);\n\n    // Cache scores to sorting\n    const peerScores = new Map<string, number>();\n\n    for (const peer of peers) {\n      if (peer.state === PeerState.DISCONNECTED) {\n        peerScores.set(peer.id, -1);\n        continue;\n      }\n\n      let score = 0;\n\n      // 1. Connection Health \"NOW\" (0-100)\n      // If quality is poor, the node's value is low regardless of history.\n      score += peer.connectionQuality || 50;\n\n      // Penalize degraded state heavily ONLY if current quality is also lacking.\n      // \"If the node is good now, let's use it\" - User\n      // If a node is DEGRADED (historical failures) but currently has 100% Quality (Heartbeats/Latency good),\n      // we should NOT penalize it. We give it a fresh start.\n      // Penalty scales with quality defect: (100 - Quality) * 4\n      // Qual 100 -> Penalty 0. Qual 50 -> Penalty 200.\n      if (peer.state === PeerState.DEGRADED) {\n        const qualityDefect = 100 - (peer.connectionQuality || 50);\n        score -= Math.max(0, qualityDefect * 4);\n      }\n\n      // 2. Direct Connection (Perfect)\n      if (peer.id === targetId) {\n        score += 2000;\n      }\n\n      // 3. Topology / Kademlia Potential (Future Potential)\n      // Closer peers in XOR space are statistically more likely to find the target.\n      // We calculate bitwise affinity.\n\n      // 4. Known Route (Routing Memory)\n      // Only useful if the peer is currently healthy.\n      if (bestRoute && bestRoute.nextHop === peer.id) {\n        // Current Quality is the multiplier, not historical reliability.\n        const routeQualityMult = (peer.connectionQuality || 50) / 100;\n        score += 300 * routeQualityMult;\n      }\n\n      // 5. Bandwidth / Uplink Capacity (The \"Datacenter vs Tunnel\" Factor)\n      // High capacity nodes should be preferred for routing.\n\n      // Use metrics if available (proven throughput)\n      if (bestRoute && bestRoute.metrics.bandwidth) {\n        // Cap at 100 points for ~10 MB/s to avoid skewing too much\n        score += Math.min(100, bestRoute.metrics.bandwidth / 100000);\n      }\n\n      // Use advertised capability if available\n      if (peer.metadata.capabilities.maxBandwidth) {\n        score += Math.min(\n          50,\n          peer.metadata.capabilities.maxBandwidth / 1000000,\n        ); // 1 point per MBps?\n      }\n\n      // Heuristic based on Transport\n      // Local/Wired/WiFi > WebRTC (Internet) > Bluetooth\n      if (peer.transportType === \"local\") {\n        score += 50; // Likely high speed LAN\n      } else if (peer.transportType === \"bluetooth\") {\n        score -= 50; // Low bandwidth, keep for proximity/fallback\n      }\n\n      peerScores.set(peer.id, score);\n    }\n\n    return peers.sort((a, b) => {\n      const scoreA = peerScores.get(a.id) || 0;\n      const scoreB = peerScores.get(b.id) || 0;\n\n      // Primary: Heuristic Score (Health + Direct + Route + Bandwidth)\n      // \"Score for NOW\" means reacting to the immediate high-bandwidth potential.\n      if (Math.abs(scoreA - scoreB) > 10) {\n        return scoreB - scoreA;\n      }\n\n      // Secondary: Kademlia Distance (Tie-breaker for \"Potential\")\n      const distA = xorDistance(targetId, a.id);\n      const distB = xorDistance(targetId, b.id);\n\n      return distA < distB ? -1 : distA > distB ? 1 : 0;\n    });\n  }\n\n  /**\n   * Find closest peers to a target ID using XOR distance\n   * Used by DHT for iterative lookups\n   */\n  findClosestPeers(targetId: string, count: number = 20): Peer[] {\n    // If DHT is enabled, use the bucket structure for O(log N) lookup\n    if (this.dhtRoutingTable) {\n      try {\n        const targetKey = peerIdToDHTKey(targetId);\n        const contacts = this.dhtRoutingTable.getClosestContacts(\n          targetKey,\n          count,\n        );\n\n        // Convert DHT contacts back to Peers\n        // We prefer the live Peer object if we have it, otherwise reconstruct minimal Peer\n        return contacts.map((contact) => {\n          const existingPeer = this.peers.get(contact.peerId);\n          if (existingPeer) return existingPeer;\n\n          // Reconstruct minimal peer from contact info\n          let transport = (contact.endpoints?.[0]?.type as any) || \"webrtc\";\n          if (transport === \"manual\") transport = \"webrtc\";\n\n          return createPeer(\n            contact.peerId,\n            new Uint8Array(0), // PublicKey not always in contact\n            transport,\n          );\n        });\n      } catch (e) {\n        console.warn(\"DHT lookup failed, falling back to linear scan\", e);\n      }\n    }\n\n    // Fallback: Linear scan of all connected peers (O(N))\n    // Acceptable for small meshes (< 1000 nodes)\n    const peers = Array.from(this.peers.values());\n\n    // Filter valid peers\n    const validPeers = peers.filter((p) => !this.isPeerBlacklisted(p.id));\n\n    return validPeers\n      .sort((a, b) => {\n        const distA = xorDistance(targetId, a.id);\n        const distB = xorDistance(targetId, b.id);\n        return distA < distB ? -1 : distA > distB ? 1 : 0;\n      })\n      .slice(0, count);\n  }\n}\n\n/**\n * Message priority queue with starvation prevention\n */\nexport class MessageQueue {\n  private queues: Map<\n    MessageType,\n    Array<{ message: any; timestamp: number; originalPriority: MessageType }>\n  > = new Map();\n  private readonly priorities = [\n    MessageType.CONTROL_PING,\n    MessageType.CONTROL_PONG,\n    MessageType.CONTROL_ACK,\n    MessageType.VOICE,\n    MessageType.TEXT,\n    MessageType.FILE_CHUNK,\n    MessageType.FILE_METADATA,\n  ];\n  private readonly ESCALATION_THRESHOLD = 30000; // 30 seconds\n  private readonly STARVATION_CHECK_INTERVAL = 5000; // 5 seconds\n  private lastStarvationCheck = Date.now();\n\n  enqueue(messageType: MessageType, message: any): void {\n    if (!this.queues.has(messageType)) {\n      this.queues.set(messageType, []);\n    }\n    this.queues.get(messageType)!.push({\n      message,\n      timestamp: Date.now(),\n      originalPriority: messageType,\n    });\n  }\n\n  dequeue(): any | null {\n    // Check for starvation periodically\n    const now = Date.now();\n    if (now - this.lastStarvationCheck > this.STARVATION_CHECK_INTERVAL) {\n      this.preventStarvation();\n      this.lastStarvationCheck = now;\n    }\n\n    // Process queues in priority order\n    for (const priority of this.priorities) {\n      const queue = this.queues.get(priority);\n      if (queue && queue.length > 0) {\n        const item = queue.shift();\n        return item?.message || null;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Prevent starvation by escalating old low-priority messages\n   */\n  private preventStarvation(): void {\n    const now = Date.now();\n\n    // Check low-priority queues for old messages\n    for (let i = this.priorities.length - 1; i > 0; i--) {\n      const currentPriority = this.priorities[i];\n      const queue = this.queues.get(currentPriority);\n\n      if (!queue || queue.length === 0) continue;\n\n      const itemsToEscalate: Array<{\n        message: any;\n        timestamp: number;\n        originalPriority: MessageType;\n      }> = [];\n      const remainingItems: Array<{\n        message: any;\n        timestamp: number;\n        originalPriority: MessageType;\n      }> = [];\n\n      for (const item of queue) {\n        const age = now - item.timestamp;\n        if (age > this.ESCALATION_THRESHOLD) {\n          itemsToEscalate.push(item);\n        } else {\n          remainingItems.push(item);\n        }\n      }\n\n      // Update current queue\n      this.queues.set(currentPriority, remainingItems);\n\n      // Move escalated items to higher priority queue\n      if (itemsToEscalate.length > 0) {\n        const higherPriority = this.priorities[i - 1];\n        if (!this.queues.has(higherPriority)) {\n          this.queues.set(higherPriority, []);\n        }\n        this.queues.get(higherPriority)!.push(...itemsToEscalate);\n      }\n    }\n  }\n\n  size(): number {\n    let total = 0;\n    for (const queue of this.queues.values()) {\n      total += queue.length;\n    }\n    return total;\n  }\n\n  /**\n   * Get size by priority level\n   */\n  getSizeByPriority(): Map<MessageType, number> {\n    const sizes = new Map<MessageType, number>();\n    for (const [priority, queue] of this.queues.entries()) {\n      sizes.set(priority, queue.length);\n    }\n    return sizes;\n  }\n\n  /**\n   * Get oldest message age in queue\n   */\n  getOldestMessageAge(): number {\n    const now = Date.now();\n    let oldest = 0;\n\n    for (const queue of this.queues.values()) {\n      for (const item of queue) {\n        const age = now - item.timestamp;\n        if (age > oldest) {\n          oldest = age;\n        }\n      }\n    }\n\n    return oldest;\n  }\n\n  clear(): void {\n    this.queues.clear();\n  }\n}\n"],"version":3}