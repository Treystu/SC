{"file":"/Users/christymaxwell/Desktop/Luke_Stuff/GitHub/SC/core/src/mesh/dht/kademlia.ts","mappings":"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","names":[],"sources":["/Users/christymaxwell/Desktop/Luke_Stuff/GitHub/SC/core/src/mesh/dht/kademlia.ts"],"sourcesContent":["/**\n * Kademlia DHT Implementation\n *\n * Core distributed hash table with XOR-based routing,\n * k-bucket organization, and iterative lookup algorithms.\n */\n\nimport type {\n  NodeId,\n  DHTKey,\n  DHTValue,\n  DHTContact,\n  DHTStats,\n  KademliaConfig,\n  NodeLookupResult,\n  ValueLookupResult,\n  DHTRPCMessage,\n  DHTMessageType,\n  FindNodeRequest,\n  FindNodeResponse,\n  FindValueRequest,\n  FindValueResponse,\n  FindValueNodesResponse,\n  StoreRequest,\n  StoreResponse,\n  PingRequest,\n  PongResponse,\n} from \"./types.js\";\nimport { DEFAULT_KADEMLIA_CONFIG } from \"./types.js\";\nimport { KBucketManager } from \"./bucket.js\";\nimport {\n  getBucketIndex,\n  sortByDistance,\n  getClosestContacts,\n  nodeIdsEqual,\n  nodeIdToHex,\n  copyNodeId,\n  generateIdInBucket,\n  NODE_ID_BITS,\n  xorDistance,\n  isCloser,\n} from \"./node-id.js\";\n\n/**\n * Pending RPC request tracking\n */\ninterface PendingRequest {\n  resolve: (response: DHTRPCMessage) => void;\n  reject: (error: Error) => void;\n  timeout: ReturnType<typeof setTimeout>;\n  sentAt: number;\n}\n\n/**\n * Kademlia DHT Routing Table\n *\n * Provides XOR-based routing, value storage, and lookup operations.\n */\nexport class KademliaRoutingTable {\n  /** Local node ID */\n  readonly localNodeId: NodeId;\n\n  /** K-bucket manager */\n  private bucketManager: KBucketManager;\n\n  /** Local value storage */\n  private valueStore: Map<string, DHTValue> = new Map();\n\n  /** Pending RPC requests */\n  private pendingRequests: Map<string, PendingRequest> = new Map();\n\n  /** Message ID counter */\n  private messageIdCounter = 0;\n\n  /** Configuration */\n  private config: KademliaConfig;\n\n  /** Statistics */\n  private stats = {\n    totalLookups: 0,\n    successfulLookups: 0,\n    totalLookupTime: 0,\n  };\n\n  /** Callback for sending RPC messages */\n  private sendRpc?: (\n    contact: DHTContact,\n    message: DHTRPCMessage,\n  ) => Promise<void>;\n\n  /** Refresh interval handle */\n  private refreshIntervalHandle?: ReturnType<typeof setInterval>;\n\n  /** Republish interval handle */\n  private republishIntervalHandle?: ReturnType<typeof setInterval>;\n\n  /** Number of currently active findNode lookups */\n  private activeLookups = 0;\n\n  constructor(\n    localNodeId: NodeId,\n    config?: Partial<Omit<KademliaConfig, \"localNodeId\">>,\n  ) {\n    this.localNodeId = copyNodeId(localNodeId);\n    this.config = {\n      ...DEFAULT_KADEMLIA_CONFIG,\n      ...config,\n      localNodeId: this.localNodeId,\n    };\n\n    this.bucketManager = new KBucketManager(localNodeId, {\n      k: this.config.k,\n      pingTimeout: this.config.pingTimeout,\n      alpha: this.config.alpha,\n    });\n  }\n\n  /**\n   * Set the RPC send callback\n   */\n  setRpcSender(\n    sender: (contact: DHTContact, message: DHTRPCMessage) => Promise<void>,\n  ): void {\n    this.sendRpc = sender;\n  }\n\n  /**\n   * Start periodic maintenance tasks\n   */\n  start(): void {\n    // Start bucket refresh\n    this.refreshIntervalHandle = setInterval(\n      () => this.refreshBuckets(),\n      this.config.refreshInterval,\n    );\n    try {\n      if (this.refreshIntervalHandle && typeof (this.refreshIntervalHandle as any).unref === 'function') {\n        (this.refreshIntervalHandle as any).unref();\n      }\n    } catch (e) { /* no-op */ }\n\n    // Start value republishing\n    this.republishIntervalHandle = setInterval(\n      () => this.republishValues(),\n      this.config.republishInterval,\n    );\n    try {\n      if (this.republishIntervalHandle && typeof (this.republishIntervalHandle as any).unref === 'function') {\n        (this.republishIntervalHandle as any).unref();\n      }\n    } catch (e) { /* no-op */ }\n  }\n\n  /**\n   * Stop periodic maintenance tasks\n   */\n  stop(): void {\n    if (this.refreshIntervalHandle) {\n      clearInterval(this.refreshIntervalHandle);\n      this.refreshIntervalHandle = undefined;\n    }\n    if (this.republishIntervalHandle) {\n      clearInterval(this.republishIntervalHandle);\n      this.republishIntervalHandle = undefined;\n    }\n\n    // Clear pending requests\n    for (const [, pending] of this.pendingRequests) {\n      clearTimeout(pending.timeout);\n      pending.reject(new Error(\"DHT shutting down\"));\n    }\n    this.pendingRequests.clear();\n  }\n\n  /**\n   * Add or update a contact in the routing table\n   */\n  addContact(contact: DHTContact): { added: boolean; needsPing?: DHTContact } {\n    // Don't add ourselves\n    if (nodeIdsEqual(contact.nodeId, this.localNodeId)) {\n      return { added: false };\n    }\n\n    const bucketIndex = getBucketIndex(this.localNodeId, contact.nodeId);\n    if (bucketIndex < 0) {\n      return { added: false };\n    }\n\n    const bucket = this.bucketManager.getBucket(bucketIndex);\n    if (!bucket) {\n      return { added: false };\n    }\n\n    const result = bucket.addContact(contact);\n    return {\n      added: result.added || result.updated,\n      needsPing: result.needsPing,\n    };\n  }\n\n  /**\n   * Remove a contact from the routing table\n   */\n  removeContact(nodeId: NodeId): boolean {\n    const bucketIndex = getBucketIndex(this.localNodeId, nodeId);\n    if (bucketIndex < 0) return false;\n\n    const bucket = this.bucketManager.getBucket(bucketIndex);\n    return bucket?.removeContact(nodeId) !== undefined;\n  }\n\n  /**\n   * Get a contact by node ID\n   */\n  getContact(nodeId: NodeId): DHTContact | undefined {\n    const bucketIndex = getBucketIndex(this.localNodeId, nodeId);\n    if (bucketIndex < 0) return undefined;\n\n    const bucket = this.bucketManager.getBucket(bucketIndex);\n    return bucket?.getContact(nodeId);\n  }\n\n  /**\n   * Check if a bucket is empty\n   */\n  isBucketEmpty(bucketIndex: number): boolean {\n    const bucket = this.bucketManager.getBucket(bucketIndex);\n    return !bucket || bucket.size === 0;\n  }\n\n  /**\n   * Get all contacts in the routing table\n   */\n  getAllContacts(): DHTContact[] {\n    return this.bucketManager.getAllContacts();\n  }\n\n  /**\n   * Get the k closest contacts to a target\n   */\n  getClosestContacts(targetId: NodeId, count?: number): DHTContact[] {\n    const k = count ?? this.config.k;\n    const allContacts = this.bucketManager.getAllContacts();\n    return getClosestContacts(allContacts, targetId, k);\n  }\n\n  /**\n   * Find the k closest nodes to a target (iterative lookup)\n   * Enforces maxConcurrentLookups from config.\n   */\n  async findNode(targetId: NodeId): Promise<NodeLookupResult> {\n    if (this.activeLookups >= this.config.maxConcurrentLookups) {\n      throw new Error(\"Max concurrent lookups exceeded\");\n    }\n    this.activeLookups++;\n    const startTime = Date.now();\n    this.stats.totalLookups++;\n\n    try {\n      // Start with k closest nodes from local routing table\n      let closestNodes = this.getClosestContacts(targetId, this.config.k);\n      const queried = new Set<string>();\n      let queriesMade = 0;\n      let hasMoreToQuery = true;\n\n      // Iterative lookup\n      while (hasMoreToQuery) {\n        // Find alpha unqueried nodes closest to target\n        const toQuery = closestNodes\n          .filter((node) => !queried.has(nodeIdToHex(node.nodeId)))\n          .slice(0, this.config.alpha);\n\n        if (toQuery.length === 0) {\n          hasMoreToQuery = false;\n          continue;\n        }\n\n        // Query nodes in parallel\n        const responses = await Promise.allSettled(\n          toQuery.map(async (node) => {\n            queried.add(nodeIdToHex(node.nodeId));\n            queriesMade++;\n            return this.sendFindNode(node, targetId);\n          }),\n        );\n\n        // Process responses\n        let improved = false;\n        for (const response of responses) {\n          if (response.status === \"fulfilled\" && response.value) {\n            const newNodes = response.value;\n            for (const newNode of newNodes) {\n              // Add to routing table\n              this.addContact(newNode);\n\n              // Check if this improves our closest set\n              if (\n                !closestNodes.some((n) =>\n                  nodeIdsEqual(n.nodeId, newNode.nodeId),\n                )\n              ) {\n                closestNodes.push(newNode);\n                improved = true;\n              }\n            }\n          }\n        }\n\n        // Re-sort and trim\n        closestNodes = sortByDistance(closestNodes, targetId).slice(\n          0,\n          this.config.k,\n        );\n\n        // Stop if we're not making progress\n        if (!improved) {\n          hasMoreToQuery = false;\n        }\n      }\n\n      const duration = Date.now() - startTime;\n      const found = closestNodes.some((n) => nodeIdsEqual(n.nodeId, targetId));\n\n      if (found) {\n        this.stats.successfulLookups++;\n      }\n      this.stats.totalLookupTime += duration;\n\n      return {\n        closestNodes,\n        queriesMade,\n        duration,\n        found,\n      };\n    } finally {\n      this.activeLookups--;\n    }\n  }\n\n  /**\n   * Find a value in the DHT (iterative lookup)\n   */\n  async findValue(key: DHTKey): Promise<ValueLookupResult> {\n    const startTime = Date.now();\n    this.stats.totalLookups++;\n\n    // Check local store first\n    const keyHex = nodeIdToHex(key);\n    const localValue = this.valueStore.get(keyHex);\n    if (localValue) {\n      this.stats.successfulLookups++;\n      return {\n        value: localValue,\n        queriedNodes: [],\n        closestNodes: [],\n        duration: Date.now() - startTime,\n        found: true,\n      };\n    }\n\n    // Start with k closest nodes\n    let closestNodes = this.getClosestContacts(key, this.config.k);\n    const queriedNodes: DHTContact[] = [];\n    const queried = new Set<string>();\n    let hasMoreToQuery = true;\n\n    // Iterative lookup\n    while (hasMoreToQuery) {\n      const toQuery = closestNodes\n        .filter((node) => !queried.has(nodeIdToHex(node.nodeId)))\n        .slice(0, this.config.alpha);\n\n      if (toQuery.length === 0) {\n        hasMoreToQuery = false;\n        continue;\n      }\n\n      const responses = await Promise.allSettled(\n        toQuery.map(async (node) => {\n          queried.add(nodeIdToHex(node.nodeId));\n          queriedNodes.push(node);\n          return this.sendFindValue(node, key);\n        }),\n      );\n\n      let improved = false;\n      for (const response of responses) {\n        if (response.status === \"fulfilled\") {\n          const result = response.value;\n          if (result.value) {\n            // Found the value!\n            this.stats.successfulLookups++;\n            const duration = Date.now() - startTime;\n            this.stats.totalLookupTime += duration;\n\n            return {\n              value: result.value,\n              queriedNodes,\n              closestNodes,\n              duration,\n              found: true,\n            };\n          } else if (result.nodes) {\n            // Got closer nodes\n            for (const newNode of result.nodes) {\n              this.addContact(newNode);\n              if (\n                !closestNodes.some((n) =>\n                  nodeIdsEqual(n.nodeId, newNode.nodeId),\n                )\n              ) {\n                closestNodes.push(newNode);\n                improved = true;\n              }\n            }\n          }\n        }\n      }\n\n      closestNodes = sortByDistance(closestNodes, key).slice(0, this.config.k);\n      if (!improved) {\n        hasMoreToQuery = false;\n      }\n    }\n\n    const duration = Date.now() - startTime;\n    this.stats.totalLookupTime += duration;\n\n    return {\n      queriedNodes,\n      closestNodes,\n      duration,\n      found: false,\n    };\n  }\n\n  /**\n   * Store a value in the DHT\n   */\n  async store(key: DHTKey, value: DHTValue): Promise<number> {\n    // Find k closest nodes to the key\n    const result = await this.findNode(key);\n\n    // Store at each of the closest nodes\n    let stored = 0;\n    const storePromises = result.closestNodes.map(async (node) => {\n      try {\n        const success = await this.sendStore(node, key, value);\n        if (success) stored++;\n      } catch {\n        // Ignore failures\n      }\n    });\n\n    await Promise.allSettled(storePromises);\n\n    // Check if we should store locally (if we're among k closest nodes to the key)\n    // Since findNode excludes the local node, we need to check our distance separately\n    const localDistance = xorDistance(this.localNodeId, key);\n    let shouldStoreLocally = false;\n\n    if (result.closestNodes.length < this.config.k) {\n      // Not enough nodes, we should store locally\n      shouldStoreLocally = true;\n    } else {\n      // Check if we're closer than the furthest of the k closest\n      const furthestNode = result.closestNodes[result.closestNodes.length - 1];\n      const furthestDistance = xorDistance(furthestNode.nodeId, key);\n      shouldStoreLocally = isCloser(localDistance, furthestDistance);\n    }\n\n    if (shouldStoreLocally) {\n      const keyHex = nodeIdToHex(key);\n      this.valueStore.set(keyHex, value);\n      stored++;\n    }\n\n    return stored;\n  }\n\n  /**\n   * Store a value locally (for incoming STORE requests)\n   */\n  storeLocal(key: DHTKey, value: DHTValue): void {\n    const keyHex = nodeIdToHex(key);\n    this.valueStore.set(keyHex, value);\n  }\n\n  /**\n   * Get a value from local storage\n   */\n  getLocal(key: DHTKey): DHTValue | undefined {\n    const keyHex = nodeIdToHex(key);\n    return this.valueStore.get(keyHex);\n  }\n\n  /**\n   * Handle incoming FIND_NODE request\n   */\n  handleFindNode(request: FindNodeRequest): FindNodeResponse {\n    const closestNodes = this.getClosestContacts(\n      request.targetId,\n      this.config.k,\n    );\n\n    // Update sender's contact info\n    this.addContact({\n      nodeId: request.senderId,\n      peerId: nodeIdToHex(request.senderId),\n      lastSeen: Date.now(),\n      failureCount: 0,\n    });\n\n    return {\n      type: \"FIND_NODE_RESPONSE\" as DHTMessageType.FIND_NODE_RESPONSE,\n      senderId: this.localNodeId,\n      messageId: request.messageId,\n      timestamp: Date.now(),\n      nodes: closestNodes,\n    };\n  }\n\n  /**\n   * Handle incoming FIND_VALUE request\n   */\n  handleFindValue(\n    request: FindValueRequest,\n  ): FindValueResponse | FindValueNodesResponse {\n    // Update sender's contact info\n    this.addContact({\n      nodeId: request.senderId,\n      peerId: nodeIdToHex(request.senderId),\n      lastSeen: Date.now(),\n      failureCount: 0,\n    });\n\n    const keyHex = nodeIdToHex(request.key);\n    const value = this.valueStore.get(keyHex);\n\n    if (value) {\n      return {\n        type: \"FIND_VALUE_RESPONSE\" as DHTMessageType.FIND_VALUE_RESPONSE,\n        senderId: this.localNodeId,\n        messageId: request.messageId,\n        timestamp: Date.now(),\n        value,\n      };\n    }\n\n    // Value not found, return closest nodes\n    const closestNodes = this.getClosestContacts(request.key, this.config.k);\n    return {\n      type: \"FIND_VALUE_NODES\" as DHTMessageType.FIND_VALUE_NODES,\n      senderId: this.localNodeId,\n      messageId: request.messageId,\n      timestamp: Date.now(),\n      nodes: closestNodes,\n    };\n  }\n\n  /**\n   * Handle incoming STORE request\n   */\n  handleStore(request: StoreRequest): StoreResponse {\n    // Update sender's contact info\n    this.addContact({\n      nodeId: request.senderId,\n      peerId: nodeIdToHex(request.senderId),\n      lastSeen: Date.now(),\n      failureCount: 0,\n    });\n\n    this.storeLocal(request.key, request.value);\n\n    return {\n      type: \"STORE_RESPONSE\" as DHTMessageType.STORE_RESPONSE,\n      senderId: this.localNodeId,\n      messageId: request.messageId,\n      timestamp: Date.now(),\n      success: true,\n    };\n  }\n\n  /**\n   * Handle incoming PING request\n   */\n  handlePing(request: PingRequest): PongResponse {\n    // Update sender's contact info\n    this.addContact({\n      nodeId: request.senderId,\n      peerId: nodeIdToHex(request.senderId),\n      lastSeen: Date.now(),\n      failureCount: 0,\n    });\n\n    return {\n      type: \"PONG\" as DHTMessageType.PONG,\n      senderId: this.localNodeId,\n      messageId: request.messageId,\n      timestamp: Date.now(),\n    };\n  }\n\n  /**\n   * Ping a contact to check if it's alive\n   */\n  async ping(contact: DHTContact): Promise<boolean> {\n    if (!this.sendRpc) return false;\n\n    const messageId = this.generateMessageId();\n    const request: PingRequest = {\n      type: \"PING\" as DHTMessageType.PING,\n      senderId: this.localNodeId,\n      messageId,\n      timestamp: Date.now(),\n    };\n\n    try {\n      const response = await this.sendRpcWithTimeout(contact, request);\n      if (response.type === (\"PONG\" as DHTMessageType.PONG)) {\n        const bucket = this.bucketManager.getBucket(\n          getBucketIndex(this.localNodeId, contact.nodeId),\n        );\n        bucket?.resetFailures(contact.nodeId);\n        bucket?.updateLastSeen(contact.nodeId);\n        return true;\n      }\n    } catch {\n      const bucket = this.bucketManager.getBucket(\n        getBucketIndex(this.localNodeId, contact.nodeId),\n      );\n      bucket?.recordFailure(contact.nodeId);\n    }\n\n    return false;\n  }\n\n  /**\n   * Send FIND_NODE request\n   */\n  private async sendFindNode(\n    contact: DHTContact,\n    targetId: NodeId,\n  ): Promise<DHTContact[]> {\n    if (!this.sendRpc) return [];\n\n    const messageId = this.generateMessageId();\n    const request: FindNodeRequest = {\n      type: \"FIND_NODE\" as DHTMessageType.FIND_NODE,\n      senderId: this.localNodeId,\n      messageId,\n      timestamp: Date.now(),\n      targetId,\n    };\n\n    try {\n      const response = await this.sendRpcWithTimeout(contact, request);\n      if (\n        response.type ===\n        (\"FIND_NODE_RESPONSE\" as DHTMessageType.FIND_NODE_RESPONSE)\n      ) {\n        return (response as FindNodeResponse).nodes;\n      }\n    } catch {\n      const bucket = this.bucketManager.getBucket(\n        getBucketIndex(this.localNodeId, contact.nodeId),\n      );\n      bucket?.recordFailure(contact.nodeId);\n    }\n\n    return [];\n  }\n\n  /**\n   * Send FIND_VALUE request\n   */\n  private async sendFindValue(\n    contact: DHTContact,\n    key: DHTKey,\n  ): Promise<{ value?: DHTValue; nodes?: DHTContact[] }> {\n    if (!this.sendRpc) return {};\n\n    const messageId = this.generateMessageId();\n    const request: FindValueRequest = {\n      type: \"FIND_VALUE\" as DHTMessageType.FIND_VALUE,\n      senderId: this.localNodeId,\n      messageId,\n      timestamp: Date.now(),\n      key,\n    };\n\n    try {\n      const response = await this.sendRpcWithTimeout(contact, request);\n      if (\n        response.type ===\n        (\"FIND_VALUE_RESPONSE\" as DHTMessageType.FIND_VALUE_RESPONSE)\n      ) {\n        return { value: (response as FindValueResponse).value };\n      } else if (\n        response.type ===\n        (\"FIND_VALUE_NODES\" as DHTMessageType.FIND_VALUE_NODES)\n      ) {\n        return { nodes: (response as FindValueNodesResponse).nodes };\n      }\n    } catch {\n      const bucket = this.bucketManager.getBucket(\n        getBucketIndex(this.localNodeId, contact.nodeId),\n      );\n      bucket?.recordFailure(contact.nodeId);\n    }\n\n    return {};\n  }\n\n  /**\n   * Send STORE request\n   */\n  private async sendStore(\n    contact: DHTContact,\n    key: DHTKey,\n    value: DHTValue,\n  ): Promise<boolean> {\n    if (!this.sendRpc) return false;\n\n    const messageId = this.generateMessageId();\n    const request: StoreRequest = {\n      type: \"STORE\" as DHTMessageType.STORE,\n      senderId: this.localNodeId,\n      messageId,\n      timestamp: Date.now(),\n      key,\n      value,\n    };\n\n    try {\n      const response = await this.sendRpcWithTimeout(contact, request);\n      return (\n        response.type === (\"STORE_RESPONSE\" as DHTMessageType.STORE_RESPONSE) &&\n        (response as StoreResponse).success\n      );\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Send RPC with timeout\n   */\n  private async sendRpcWithTimeout(\n    contact: DHTContact,\n    request: DHTRPCMessage,\n  ): Promise<DHTRPCMessage> {\n    if (!this.sendRpc) {\n      throw new Error(\"RPC sender not configured\");\n    }\n\n    return new Promise<DHTRPCMessage>((resolve, reject) => {\n      const timeout = setTimeout(() => {\n        this.pendingRequests.delete(request.messageId);\n        reject(new Error(\"RPC timeout\"));\n      }, this.config.pingTimeout);\n\n      this.pendingRequests.set(request.messageId, {\n        resolve,\n        reject,\n        timeout,\n        sentAt: Date.now(),\n      });\n\n      this.sendRpc!(contact, request).catch((err) => {\n        this.pendingRequests.delete(request.messageId);\n        clearTimeout(timeout);\n        reject(err);\n      });\n    });\n  }\n\n  /**\n   * Handle incoming RPC response\n   */\n  handleResponse(response: DHTRPCMessage): void {\n    const pending = this.pendingRequests.get(response.messageId);\n    if (pending) {\n      clearTimeout(pending.timeout);\n      this.pendingRequests.delete(response.messageId);\n\n      // Update RTT for the responding contact via addContact to properly update LRU\n      const rtt = Date.now() - pending.sentAt;\n      const existingContact = this.getContact(response.senderId);\n      if (existingContact) {\n        // Re-add with updated info to trigger proper LRU update\n        this.addContact({\n          ...existingContact,\n          rtt,\n          lastSeen: Date.now(),\n        });\n      }\n\n      pending.resolve(response);\n    }\n  }\n\n  /**\n   * Generate unique message ID\n   */\n  private generateMessageId(): string {\n    return `${nodeIdToHex(this.localNodeId).slice(0, 8)}-${Date.now()}-${this.messageIdCounter++}`;\n  }\n\n  /**\n   * Refresh stale buckets\n   */\n  private async refreshBuckets(): Promise<void> {\n    const bucketsToRefresh = this.bucketManager.getBucketsNeedingRefresh(\n      this.config.refreshInterval,\n    );\n\n    for (const bucket of bucketsToRefresh) {\n      // Generate a random ID in this bucket's range and look it up\n      const randomId = generateIdInBucket(this.localNodeId, bucket.index);\n      try {\n        await this.findNode(randomId);\n        // Only mark as refreshed if lookup succeeded\n        bucket.markRefreshed();\n      } catch {\n        // Lookup failed, don't mark bucket as refreshed so it will be retried\n      }\n    }\n  }\n\n  /**\n   * Republish stored values\n   */\n  private async republishValues(): Promise<void> {\n    const now = Date.now();\n\n    for (const [keyHex, value] of this.valueStore.entries()) {\n      // Check if value is expired\n      if (now - value.storedAt > value.ttl) {\n        this.valueStore.delete(keyHex);\n        continue;\n      }\n\n      // Republish if we're the original publisher\n      if (nodeIdsEqual(value.publisherId, this.localNodeId)) {\n        // Validate hex string before parsing - must be non-empty and have valid hex chars\n        if (keyHex.length === 0 || keyHex.length % 2 !== 0) {\n          // Skip empty or odd-length hex strings\n          continue;\n        }\n        const hexMatch = keyHex.match(/^[0-9a-fA-F]+$/);\n        if (!hexMatch) {\n          // Skip strings with invalid hex characters\n          continue;\n        }\n        const byteArray = keyHex.match(/.{2}/g);\n        if (!byteArray) {\n          continue;\n        }\n        const key = new Uint8Array(byteArray.map((byte) => parseInt(byte, 16)));\n        await this.store(key, value);\n      }\n    }\n  }\n\n  /**\n   * Get routing table statistics\n   */\n  getStats(): DHTStats {\n    const bucketStats = this.bucketManager.getStats();\n\n    return {\n      nodeCount: bucketStats.totalContacts,\n      valueCount: this.valueStore.size,\n      activeBuckets: bucketStats.activeBuckets,\n      totalLookups: this.stats.totalLookups,\n      successfulLookups: this.stats.successfulLookups,\n      avgLookupTime:\n        this.stats.totalLookups > 0\n          ? this.stats.totalLookupTime / this.stats.totalLookups\n          : 0,\n      memoryUsage: this.estimateMemoryUsage(),\n    };\n  }\n\n  /**\n   * Estimate memory usage\n   */\n  private estimateMemoryUsage(): number {\n    // Rough estimate: 200 bytes per contact, 100 bytes per stored value key\n    const contactBytes = this.bucketManager.getTotalContacts() * 200;\n    const valueBytes = this.valueStore.size * 100;\n    // Add overhead for maps and other data structures\n    return (contactBytes + valueBytes) * 1.2;\n  }\n\n  /**\n   * Get bucket distribution (for network state awareness)\n   */\n  getBucketDistribution(): number[] {\n    return this.bucketManager.getStats().bucketDistribution;\n  }\n\n  /**\n   * Clear all data\n   */\n  clear(): void {\n    for (let i = 0; i < NODE_ID_BITS; i++) {\n      this.bucketManager.getBucket(i)?.clear();\n    }\n    this.valueStore.clear();\n    this.stats = {\n      totalLookups: 0,\n      successfulLookups: 0,\n      totalLookupTime: 0,\n    };\n  }\n}\n"],"version":3}