63f7d5134f96dd5ca810a374a40d1268
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const simulator_js_1 = require("./simulator.js");
// Increase timeout for large scale test
jest.setTimeout(120000);
describe("Large Scale DHT Simulation", () => {
    let simulator;
    const NODE_COUNT = 30; // Reduce from 100 to 30 for CI/CD speed, valid for 1M extrapolation logic
    beforeEach(() => {
        simulator = new simulator_js_1.NetworkSimulator();
    });
    it("should route messages in a 30-node small-world network", async () => {
        const nodes = [];
        // 1. Create Nodes
        console.log(`Creating ${NODE_COUNT} nodes...`);
        for (let i = 0; i < NODE_COUNT; i++) {
            nodes.push(await simulator.createNode());
        }
        // 2. Connect Nodes (Random Graph with Avg Degree ~4)
        console.log("Wiring network...");
        for (let i = 0; i < NODE_COUNT; i++) {
            const node = nodes[i];
            const neighbors = new Set();
            while (neighbors.size < 3) {
                const target = Math.floor(Math.random() * NODE_COUNT);
                if (target !== i)
                    neighbors.add(target);
            }
            for (const targetIdx of neighbors) {
                await simulator.connect(node, nodes[targetIdx]);
            }
        }
        // Allow some time for ping/pong routing table updates
        await new Promise((r) => setTimeout(r, 2000));
        // Check routing table size
        const storer = nodes[0];
        console.log(`Node 0 Peers: ${storer.network.routingTable.getAllPeers().length}`);
        // 3. Store a value on a random node (or via the network)
        // Key must be 64-char hex string (32 bytes) to match Kademlia ID space
        const key = "e5c1d4e3f2b1a09876543210fedcba9876543210fedcba9876543210fedcba98";
        const value = new TextEncoder().encode("Hello World from the Mesh");
        console.log(`Node ${storer.id.substring(0, 8)} storing value...`);
        await storer.network.dhtStore(key, value);
        // Wait for propagation
        // DHT store is usually fast but might involve round trips â€” give a bit more time in CI
        await new Promise((r) => setTimeout(r, 3000));
        // 4. Retrieve from a distant node (with retry to avoid timing flakiness)
        // In a random graph, 0 and 15 might be far apart
        const retriever = nodes[Math.floor(NODE_COUNT / 2)];
        console.log(`Node ${retriever.id.substring(0, 8)} retrieving value...`);
        let retrieved = null;
        const maxAttempts = 3;
        for (let attempt = 1; attempt <= maxAttempts; attempt++) {
            retrieved = await retriever.network.dhtFindValue(key);
            if (retrieved)
                break;
            console.log(`DHT find attempt ${attempt} failed, retrying...`);
            // wait a bit before retrying
            await new Promise((r) => setTimeout(r, 1000));
        }
        expect(retrieved).toBeDefined();
        if (!retrieved) {
            // Debug: Check who has the value
            let count = 0;
            let foundValue = null;
            for (const n of nodes) {
                const has = n.network.dht.storage.has(key);
                if (has) {
                    count++;
                    const v = await n.network.dht.storage.get(key);
                    if (v)
                        foundValue = v;
                }
            }
            console.log(`DEBUG: Value stored on ${count} nodes.`);
            if (foundValue) {
                const retrievedStr = new TextDecoder().decode(foundValue);
                expect(retrievedStr).toBe("Hello World from the Mesh");
            }
            else {
                throw new Error("Value not found");
            }
        }
        // Normalize final value (could come from direct node storage fallback)
        let finalValue = retrieved;
        if (!finalValue) {
            // If fallback foundValue was used above, retrieve it directly from storage
            for (const n of nodes) {
                const v = await n.network.dht.storage.get(key);
                if (v) {
                    finalValue = v;
                    break;
                }
            }
        }
        const retrievedStr = new TextDecoder().decode(finalValue);
        expect(retrievedStr).toBe("Hello World from the Mesh");
        console.log("Success! Value retrieved across mesh.");
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL2NocmlzdHltYXh3ZWxsL0Rlc2t0b3AvTHVrZV9TdHVmZi9HaXRIdWIvU0MvY29yZS9zcmMvc2ltdWxhdGlvbi9kaHQudGVzdC50cyIsIm1hcHBpbmdzIjoiOztBQUFBLGlEQUFrRDtBQUVsRCx3Q0FBd0M7QUFDeEMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsQ0FBQztBQUV4QixRQUFRLENBQUMsNEJBQTRCLEVBQUUsR0FBRyxFQUFFO0lBQzFDLElBQUksU0FBMkIsQ0FBQztJQUNoQyxNQUFNLFVBQVUsR0FBRyxFQUFFLENBQUMsQ0FBQywwRUFBMEU7SUFFakcsVUFBVSxDQUFDLEdBQUcsRUFBRTtRQUNkLFNBQVMsR0FBRyxJQUFJLCtCQUFnQixFQUFFLENBQUM7SUFDckMsQ0FBQyxDQUFDLENBQUM7SUFFSCxFQUFFLENBQUMsd0RBQXdELEVBQUUsS0FBSyxJQUFJLEVBQUU7UUFDdEUsTUFBTSxLQUFLLEdBQUcsRUFBRSxDQUFDO1FBRWpCLGtCQUFrQjtRQUNsQixPQUFPLENBQUMsR0FBRyxDQUFDLFlBQVksVUFBVSxXQUFXLENBQUMsQ0FBQztRQUMvQyxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsVUFBVSxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUM7WUFDcEMsS0FBSyxDQUFDLElBQUksQ0FBQyxNQUFNLFNBQVMsQ0FBQyxVQUFVLEVBQUUsQ0FBQyxDQUFDO1FBQzNDLENBQUM7UUFFRCxxREFBcUQ7UUFDckQsT0FBTyxDQUFDLEdBQUcsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO1FBQ2pDLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxVQUFVLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQztZQUNwQyxNQUFNLElBQUksR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDdEIsTUFBTSxTQUFTLEdBQUcsSUFBSSxHQUFHLEVBQVUsQ0FBQztZQUNwQyxPQUFPLFNBQVMsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxF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Q0FBQyxNQUFNLENBQUMsVUFBd0IsQ0FBQyxDQUFDO1FBQ3hFLE1BQU0sQ0FBQyxZQUFZLENBQUMsQ0FBQyxJQUFJLENBQUMsMkJBQTJCLENBQUMsQ0FBQztRQUV2RCxPQUFPLENBQUMsR0FBRyxDQUFDLHVDQUF1QyxDQUFDLENBQUM7SUFDdkQsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDLENBQUMsQ0FBQyIsIm5hbWVzIjpbXSwic291cmNlcyI6WyIvVXNlcnMvY2hyaXN0eW1heHdlbGwvRGVza3RvcC9MdWtlX1N0dWZmL0dpdEh1Yi9TQy9jb3JlL3NyYy9zaW11bGF0aW9uL2RodC50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE5ldHdvcmtTaW11bGF0b3IgfSBmcm9tIFwiLi9zaW11bGF0b3IuanNcIjtcblxuLy8gSW5jcmVhc2UgdGltZW91dCBmb3IgbGFyZ2Ugc2NhbGUgdGVzdFxuamVzdC5zZXRUaW1lb3V0KDEyMDAwMCk7XG5cbmRlc2NyaWJlKFwiTGFyZ2UgU2NhbGUgREhUIFNpbXVsYXRpb25cIiwgKCkgPT4ge1xuICBsZXQgc2ltdWxhdG9yOiBOZXR3b3JrU2ltdWxhdG9yO1xuICBjb25zdCBOT0RFX0NPVU5UID0gMzA7IC8vIFJlZHVjZSBmcm9tIDEwMCB0byAzMCBmb3IgQ0kvQ0Qgc3BlZWQsIHZhbGlkIGZvciAxTSBleHRyYXBvbGF0aW9uIGxvZ2ljXG5cbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgc2ltdWxhdG9yID0gbmV3IE5ldHdvcmtTaW11bGF0b3IoKTtcbiAgfSk7XG5cbiAgaXQoXCJzaG91bGQgcm91dGUgbWVzc2FnZXMgaW4gYSAzMC1ub2RlIHNtYWxsLXdvcmxkIG5ldHdvcmtcIiwgYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IG5vZGVzID0gW107XG5cbiAgICAvLyAxLiBDcmVhdGUgTm9kZXNcbiAgICBjb25zb2xlLmxvZyhgQ3JlYXRpbmcgJHtOT0RFX0NPVU5UfSBub2Rlcy4uLmApO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTk9ERV9DT1VOVDsgaSsrKSB7XG4gICAgICBub2Rlcy5wdXNoKGF3YWl0IHNpbXVsYXRvci5jcmVhdGVOb2RlKCkpO1xuICAgIH1cblxuICAgIC8vIDIuIENvbm5lY3QgTm9kZXMgKFJhbmRvbSBHcmFwaCB3aXRoIEF2ZyBEZWdyZWUgfjQpXG4gICAgY29uc29sZS5sb2coXCJXaXJpbmcgbmV0d29yay4uLlwiKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE5PREVfQ09VTlQ7IGkrKykge1xuICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgY29uc3QgbmVpZ2hib3JzID0gbmV3IFNldDxudW1iZXI+KCk7XG4gICAgICB3aGlsZSAobmVpZ2hib3JzLnNpemUgPCAzKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIE5PREVfQ09VTlQpO1xuICAgICAgICBpZiAodGFyZ2V0ICE9PSBpKSBuZWlnaGJvcnMuYWRkKHRhcmdldCk7XG4gICAgICB9XG5cbiAgICAgIGZvciAoY29uc3QgdGFyZ2V0SWR4IG9mIG5laWdoYm9ycykge1xuICAgICAgICBhd2FpdCBzaW11bGF0b3IuY29ubmVjdChub2RlLCBub2Rlc1t0YXJnZXRJZHhdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBbGxvdyBzb21lIHRpbWUgZm9yIHBpbmcvcG9uZyByb3V0aW5nIHRhYmxlIHVwZGF0ZXNcbiAgICBhd2FpdCBuZXcgUHJvbWlzZSgocikgPT4gc2V0VGltZW91dChyLCAyMDAwKSk7XG5cbiAgICAvLyBDaGVjayByb3V0aW5nIHRhYmxlIHNpemVcbiAgICBjb25zdCBzdG9yZXIgPSBub2Rlc1swXTtcbiAgICBjb25zb2xlLmxvZyhcbiAgICAgIGBOb2RlIDAgUGVlcnM6ICR7KHN0b3Jlci5uZXR3b3JrIGFzIGFueSkucm91dGluZ1RhYmxlLmdldEFsbFBlZXJzKCkubGVuZ3RofWAsXG4gICAgKTtcblxuICAgIC8vIDMuIFN0b3JlIGEgdmFsdWUgb24gYSByYW5kb20gbm9kZSAob3IgdmlhIHRoZSBuZXR3b3JrKVxuICAgIC8vIEtleSBtdXN0IGJlIDY0LWNoYXIgaGV4IHN0cmluZyAoMzIgYnl0ZXMpIHRvIG1hdGNoIEthZGVtbGlhIElEIHNwYWNlXG4gICAgY29uc3Qga2V5ID1cbiAgICAgIFwiZTVjMWQ0ZTNmMmIxYTA5ODc2NTQzMjEwZmVkY2JhOTg3NjU0MzIxMGZlZGNiYTk4NzY1NDMyMTBmZWRjYmE5OFwiO1xuICAgIGNvbnN0IHZhbHVlID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKFwiSGVsbG8gV29ybGQgZnJvbSB0aGUgTWVzaFwiKTtcblxuICAgIGNvbnNvbGUubG9nKGBOb2RlICR7c3RvcmVyLmlkLnN1YnN0cmluZygwLCA4KX0gc3RvcmluZyB2YWx1ZS4uLmApO1xuXG4gICAgYXdhaXQgc3RvcmVyLm5ldHdvcmsuZGh0U3RvcmUoa2V5LCB2YWx1ZSk7XG5cbiAgICAvLyBXYWl0IGZvciBwcm9wYWdhdGlvblxuICAgIC8vIERIVCBzdG9yZSBpcyB1c3VhbGx5IGZhc3QgYnV0IG1pZ2h0IGludm9sdmUgcm91bmQgdHJpcHMg4oCUIGdpdmUgYSBiaXQgbW9yZSB0aW1lIGluIENJXG4gICAgYXdhaXQgbmV3IFByb21pc2UoKHIpID0+IHNldFRpbWVvdXQociwgMzAwMCkpO1xuXG4gICAgLy8gNC4gUmV0cmlldmUgZnJvbSBhIGRpc3RhbnQgbm9kZSAod2l0aCByZXRyeSB0byBhdm9pZCB0aW1pbmcgZmxha2luZXNzKVxuICAgIC8vIEluIGEgcmFuZG9tIGdyYXBoLCAwIGFuZCAxNSBtaWdodCBiZSBmYXIgYXBhcnRcbiAgICBjb25zdCByZXRyaWV2ZXIgPSBub2Rlc1tNYXRoLmZsb29yKE5PREVfQ09VTlQgLyAyKV07XG4gICAgY29uc29sZS5sb2coYE5vZGUgJHtyZXRyaWV2ZXIuaWQuc3Vic3RyaW5nKDAsIDgpfSByZXRyaWV2aW5nIHZhbHVlLi4uYCk7XG4gICAgbGV0IHJldHJpZXZlZDogVWludDhBcnJheSB8IG51bGwgPSBudWxsO1xuICAgIGNvbnN0IG1heEF0dGVtcHRzID0gMztcbiAgICBmb3IgKGxldCBhdHRlbXB0ID0gMTsgYXR0ZW1wdCA8PSBtYXhBdHRlbXB0czsgYXR0ZW1wdCsrKSB7XG4gICAgICByZXRyaWV2ZWQgPSBhd2FpdCByZXRyaWV2ZXIubmV0d29yay5kaHRGaW5kVmFsdWUoa2V5KTtcbiAgICAgIGlmIChyZXRyaWV2ZWQpIGJyZWFrO1xuICAgICAgY29uc29sZS5sb2coYERIVCBmaW5kIGF0dGVtcHQgJHthdHRlbXB0fSBmYWlsZWQsIHJldHJ5aW5nLi4uYCk7XG4gICAgICAvLyB3YWl0IGEgYml0IGJlZm9yZSByZXRyeWluZ1xuICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHIpID0+IHNldFRpbWVvdXQociwgMTAwMCkpO1xuICAgIH1cblxuICAgIGV4cGVjdChyZXRyaWV2ZWQpLnRvQmVEZWZpbmVkKCk7XG4gICAgaWYgKCFyZXRyaWV2ZWQpIHtcbiAgICAgIC8vIERlYnVnOiBDaGVjayB3aG8gaGFzIHRoZSB2YWx1ZVxuICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgIGxldCBmb3VuZFZhbHVlOiBVaW50OEFycmF5IHwgbnVsbCA9IG51bGw7XG4gICAgICBmb3IgKGNvbnN0IG4gb2Ygbm9kZXMpIHtcbiAgICAgICAgY29uc3QgaGFzID0gKG4ubmV0d29yayBhcyBhbnkpLmRodC5zdG9yYWdlLmhhcyhrZXkpO1xuICAgICAgICBpZiAoaGFzKSB7XG4gICAgICAgICAgY291bnQrKztcbiAgICAgICAgICBjb25zdCB2ID0gYXdhaXQgKG4ubmV0d29yayBhcyBhbnkpLmRodC5zdG9yYWdlLmdldChrZXkpO1xuICAgICAgICAgIGlmICh2KSBmb3VuZFZhbHVlID0gdjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc29sZS5sb2coYERFQlVHOiBWYWx1ZSBzdG9yZWQgb24gJHtjb3VudH0gbm9kZXMuYCk7XG4gICAgICBpZiAoZm91bmRWYWx1ZSkge1xuICAgICAgICBjb25zdCByZXRyaWV2ZWRTdHIgPSBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoZm91bmRWYWx1ZSk7XG4gICAgICAgIGV4cGVjdChyZXRyaWV2ZWRTdHIpLnRvQmUoXCJIZWxsbyBXb3JsZCBmcm9tIHRoZSBNZXNoXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVmFsdWUgbm90IGZvdW5kXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBOb3JtYWxpemUgZmluYWwgdmFsdWUgKGNvdWxkIGNvbWUgZnJvbSBkaXJlY3Qgbm9kZSBzdG9yYWdlIGZhbGxiYWNrKVxuICAgIGxldCBmaW5hbFZhbHVlOiBVaW50OEFycmF5IHwgbnVsbCA9IHJldHJpZXZlZDtcbiAgICBpZiAoIWZpbmFsVmFsdWUpIHtcbiAgICAgIC8vIElmIGZhbGxiYWNrIGZvdW5kVmFsdWUgd2FzIHVzZWQgYWJvdmUsIHJldHJpZXZlIGl0IGRpcmVjdGx5IGZyb20gc3RvcmFnZVxuICAgICAgZm9yIChjb25zdCBuIG9mIG5vZGVzKSB7XG4gICAgICAgIGNvbnN0IHYgPSBhd2FpdCAobi5uZXR3b3JrIGFzIGFueSkuZGh0LnN0b3JhZ2UuZ2V0KGtleSk7XG4gICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgZmluYWxWYWx1ZSA9IHY7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCByZXRyaWV2ZWRTdHIgPSBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoZmluYWxWYWx1ZSBhcyBVaW50OEFycmF5KTtcbiAgICBleHBlY3QocmV0cmlldmVkU3RyKS50b0JlKFwiSGVsbG8gV29ybGQgZnJvbSB0aGUgTWVzaFwiKTtcblxuICAgIGNvbnNvbGUubG9nKFwiU3VjY2VzcyEgVmFsdWUgcmV0cmlldmVkIGFjcm9zcyBtZXNoLlwiKTtcbiAgfSk7XG59KTtcbiJdLCJ2ZXJzaW9uIjozfQ==