{"file":"/Users/christymaxwell/Desktop/Luke_Stuff/GitHub/SC/core/src/transport/Transport.ts","mappings":";AAAA;;;;;;;;;GASG;;;AA4RH;;GAEG;AACH,MAAa,wBAAwB;IAArC;QACU,cAAS,GAAkC,IAAI,GAAG,EAAE,CAAC;IAa/D,CAAC;IAXC,QAAQ,CAAC,IAAY,EAAE,OAAyB;QAC9C,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;IACpC,CAAC;IAED,GAAG,CAAC,IAAY;QACd,OAAO,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;IAClC,CAAC;IAED,QAAQ;QACN,OAAO,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,IAAI,EAAE,CAAC,CAAC;IAC3C,CAAC;CACF;AAdD,4DAcC;AAED;;GAEG;AACU,QAAA,iBAAiB,GAAG,IAAI,wBAAwB,EAAE,CAAC","names":[],"sources":["/Users/christymaxwell/Desktop/Luke_Stuff/GitHub/SC/core/src/transport/Transport.ts"],"sourcesContent":["/**\n * Transport Abstraction Layer\n *\n * Defines a platform-agnostic transport interface that all mesh/routing logic\n * depends on. Concrete implementations (WebRTC, BLE, Wi-Fi Direct, etc.) are\n * provided by platform-specific code.\n *\n * This abstraction ensures protocol and routing logic remain decoupled from\n * platform-specific APIs (browser WebRTC, Android BLE, iOS CoreBluetooth, etc.).\n */\n\n/**\n * Unique identifier for a peer in the transport layer.\n * Typically a hex-encoded public key or a UUID.\n */\nexport type TransportPeerId = string;\n\n/**\n * A message transported between peers.\n */\nexport interface TransportMessage {\n  /** The sender's peer ID */\n  from: TransportPeerId;\n  /** The recipient's peer ID (optional for broadcasts) */\n  to?: TransportPeerId;\n  /** Binary message payload */\n  payload: Uint8Array;\n  /** Optional timestamp for the message */\n  timestamp?: number;\n}\n\n/**\n * Connection state for a transport peer.\n */\nexport type TransportConnectionState =\n  | \"new\"\n  | \"connecting\"\n  | \"connected\"\n  | \"disconnected\"\n  | \"failed\"\n  | \"closed\";\n\n/**\n * Peer information provided by the transport layer.\n */\nexport interface TransportPeerInfo {\n  /** The peer's unique identifier */\n  peerId: TransportPeerId;\n  /** Current connection state */\n  state: TransportConnectionState;\n  /** Transport type (webrtc, bluetooth, local, etc.) */\n  transportType: string;\n  /** Connection quality metric (0-100) */\n  connectionQuality?: number;\n  /** Bytes sent to this peer */\n  bytesSent?: number;\n  /** Bytes received from this peer */\n  bytesReceived?: number;\n  /** Last seen timestamp */\n  lastSeen?: number;\n}\n\n/**\n * Event handlers for transport events.\n * Implementations call these callbacks when events occur.\n */\nexport interface TransportEvents {\n  /**\n   * Called when a message is received from a peer.\n   * @param msg The received message\n   */\n  onMessage(msg: TransportMessage): void;\n\n  /**\n   * Called when a peer successfully connects.\n   * @param peerId The connected peer's ID\n   * @param info Optional peer information\n   */\n  onPeerConnected?(peerId: TransportPeerId, info?: TransportPeerInfo): void;\n\n  /**\n   * Called when a peer disconnects.\n   * @param peerId The disconnected peer's ID\n   * @param reason Optional reason for disconnection\n   */\n  onPeerDisconnected?(peerId: TransportPeerId, reason?: string): void;\n\n  /**\n   * Called when connection state changes for a peer.\n   * @param peerId The peer's ID\n   * @param state The new connection state\n   */\n  onStateChange?(\n    peerId: TransportPeerId,\n    state: TransportConnectionState,\n  ): void;\n\n  /**\n   * Called when an error occurs.\n   * @param error The error that occurred\n   * @param peerId Optional peer ID if error is peer-specific\n   */\n  onError?(error: Error, peerId?: TransportPeerId): void;\n\n  /**\n   * Called when a media track is received (for WebRTC-style transports).\n   * @param peerId The peer's ID\n   * @param track The media track\n   * @param stream The media stream containing the track\n   */\n  onTrack?(peerId: TransportPeerId, track: unknown, stream: unknown): void;\n}\n\n/**\n * Configuration options for transport initialization.\n */\nexport interface TransportConfig {\n  /** Maximum number of concurrent connections */\n  maxPeers?: number;\n  /** Connection timeout in milliseconds */\n  connectionTimeout?: number;\n  /** Heartbeat interval in milliseconds */\n  heartbeatInterval?: number;\n  /** Custom transport-specific options */\n  options?: Record<string, unknown>;\n}\n\n/**\n * Signaling data for connection establishment.\n * Used for transports that require out-of-band signaling (like WebRTC).\n */\nexport interface SignalingData {\n  /** Type of signaling data */\n  type: \"offer\" | \"answer\" | \"candidate\" | \"custom\";\n  /** The signaling payload (SDP, ICE candidate, etc.) */\n  data: unknown;\n  /** Sender peer ID */\n  from?: TransportPeerId;\n  /** Recipient peer ID */\n  to?: TransportPeerId;\n}\n\n/**\n * Transport interface defining the contract all transport implementations must follow.\n *\n * This abstraction allows the mesh networking layer to work with any transport\n * mechanism (WebRTC, Bluetooth LE, Wi-Fi Direct, TCP, etc.) without coupling\n * to specific platform APIs.\n *\n * @example\n * ```typescript\n * const transport: Transport = new WebRTCTransport(config);\n * await transport.start({\n *   onMessage: (msg) => console.log('Received:', msg),\n *   onPeerConnected: (peerId) => console.log('Connected:', peerId),\n * });\n *\n * await transport.connect('peer-id-123');\n * await transport.send('peer-id-123', new Uint8Array([1, 2, 3]));\n * ```\n */\nexport interface Transport {\n  /**\n   * The local peer ID for this transport instance.\n   */\n  readonly localPeerId: TransportPeerId;\n\n  /**\n   * The name of this transport (e.g., 'webrtc', 'ble').\n   */\n  readonly name: string;\n\n  /**\n   * Start the transport and begin listening for connections.\n   * @param events Event handlers for transport events\n   * @returns Promise that resolves when transport is ready\n   */\n  start(events: TransportEvents): Promise<void>;\n\n  /**\n   * Stop the transport and close all connections.\n   * @returns Promise that resolves when transport is fully stopped\n   */\n  stop(): Promise<void>;\n\n  /**\n   * Initiate a connection to a peer.\n   * @param peerId The peer ID to connect to\n   * @param signalingData Optional signaling data for connection establishment\n   * @returns Promise that resolves when connection is established\n   */\n  connect(\n    peerId: TransportPeerId,\n    signalingData?: SignalingData,\n  ): Promise<void>;\n\n  /**\n   * Disconnect from a specific peer.\n   * @param peerId The peer ID to disconnect from\n   * @returns Promise that resolves when disconnection is complete\n   */\n  disconnect(peerId: TransportPeerId): Promise<void>;\n\n  /**\n   * Send a message to a specific peer.\n   * @param peerId The recipient peer ID\n   * @param payload The binary message payload\n   * @returns Promise that resolves when message is sent (not necessarily delivered)\n   */\n  send(peerId: TransportPeerId, payload: Uint8Array): Promise<void>;\n\n  /**\n   * Broadcast a message to all connected peers.\n   * @param payload The binary message payload\n   * @param excludePeerId Optional peer ID to exclude from broadcast\n   * @returns Promise that resolves when broadcast is complete\n   */\n  broadcast(\n    payload: Uint8Array,\n    excludePeerId?: TransportPeerId,\n  ): Promise<void>;\n\n  /**\n   * Get the list of currently connected peer IDs.\n   * @returns Array of connected peer IDs\n   */\n  getConnectedPeers(): TransportPeerId[];\n\n  /**\n   * Get information about a specific peer.\n   * @param peerId The peer ID to query\n   * @returns Peer information or undefined if not connected\n   */\n  getPeerInfo(peerId: TransportPeerId): TransportPeerInfo | undefined;\n\n  /**\n   * Get the current connection state for a peer.\n   * @param peerId The peer ID to query\n   * @returns Connection state or undefined if peer is unknown\n   */\n  getConnectionState(\n    peerId: TransportPeerId,\n  ): TransportConnectionState | undefined;\n\n  /**\n   * Handle incoming signaling data (for transports that require signaling).\n   * @param signalingData The signaling data to process\n   * @returns Promise that resolves with optional response signaling data\n   */\n  handleSignaling?(\n    signalingData: SignalingData,\n  ): Promise<SignalingData | undefined>;\n\n  /**\n   * Generate signaling data to initiate a connection (for transports that require signaling).\n   * @param peerId The target peer ID\n   * @returns Promise that resolves with signaling data to send to the peer\n   */\n  createSignalingOffer?(peerId: TransportPeerId): Promise<SignalingData>;\n}\n\n/**\n * Factory function type for creating transport instances.\n * Useful for dependency injection and testing.\n */\nexport type TransportFactory = (config?: TransportConfig) => Transport;\n\n/**\n * Registry for transport implementations.\n * Allows dynamic registration and lookup of transport types.\n */\nexport interface TransportRegistry {\n  /**\n   * Register a transport factory.\n   * @param type Transport type identifier (e.g., 'webrtc', 'bluetooth')\n   * @param factory Factory function to create transport instances\n   */\n  register(type: string, factory: TransportFactory): void;\n\n  /**\n   * Get a transport factory by type.\n   * @param type Transport type identifier\n   * @returns Factory function or undefined if not registered\n   */\n  get(type: string): TransportFactory | undefined;\n\n  /**\n   * Get all registered transport types.\n   * @returns Array of transport type identifiers\n   */\n  getTypes(): string[];\n}\n\n/**\n * Default transport registry implementation.\n */\nexport class DefaultTransportRegistry implements TransportRegistry {\n  private factories: Map<string, TransportFactory> = new Map();\n\n  register(type: string, factory: TransportFactory): void {\n    this.factories.set(type, factory);\n  }\n\n  get(type: string): TransportFactory | undefined {\n    return this.factories.get(type);\n  }\n\n  getTypes(): string[] {\n    return Array.from(this.factories.keys());\n  }\n}\n\n/**\n * Global transport registry instance.\n */\nexport const transportRegistry = new DefaultTransportRegistry();\n"],"version":3}