{"file":"/Users/christymaxwell/Desktop/Luke_Stuff/GitHub/SC/core/src/mesh/dht/node-id.ts","mappings":"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","names":[],"sources":["/Users/christymaxwell/Desktop/Luke_Stuff/GitHub/SC/core/src/mesh/dht/node-id.ts"],"sourcesContent":["/**\n * Node ID Utilities for Kademlia DHT\n * \n * Provides 160-bit node ID generation, XOR distance calculation,\n * and related utilities for the DHT implementation.\n */\n\nimport { sha256 } from '@noble/hashes/sha2.js';\nimport type { NodeId, DHTKey } from './types.js';\n\n/** Node ID size in bytes (160 bits) */\nexport const NODE_ID_BYTES = 20;\n\n/** Node ID size in bits */\nexport const NODE_ID_BITS = NODE_ID_BYTES * 8;\n\n/**\n * Generate a random node ID\n * @returns A new random 160-bit node ID\n */\nexport function generateNodeId(): NodeId {\n  const nodeId = new Uint8Array(NODE_ID_BYTES);\n  if (typeof crypto !== 'undefined' && crypto.getRandomValues) {\n    crypto.getRandomValues(nodeId);\n  } else {\n    // Fallback for environments without crypto API\n    for (let i = 0; i < NODE_ID_BYTES; i++) {\n      nodeId[i] = Math.floor(Math.random() * 256);\n    }\n  }\n  return nodeId;\n}\n\n/**\n * Generate a node ID from a public key\n * Uses SHA-256 truncated to 160 bits for consistent ID generation\n * \n * @param publicKey - Ed25519 public key (32 bytes)\n * @returns 160-bit node ID derived from the public key\n */\nexport function nodeIdFromPublicKey(publicKey: Uint8Array): NodeId {\n  const hash = sha256(publicKey);\n  return hash.slice(0, NODE_ID_BYTES);\n}\n\n/**\n * Generate a DHT key from arbitrary data\n * Uses SHA-256 truncated to 160 bits\n * \n * @param data - Arbitrary data to hash\n * @returns 160-bit DHT key\n */\nexport function generateDHTKey(data: Uint8Array | string): DHTKey {\n  const input = typeof data === 'string' ? new TextEncoder().encode(data) : data;\n  const hash = sha256(input);\n  return hash.slice(0, NODE_ID_BYTES);\n}\n\n/**\n * Calculate XOR distance between two node IDs\n * \n * @param a - First node ID\n * @param b - Second node ID\n * @returns XOR distance as Uint8Array (same size as input)\n */\nexport function xorDistance(a: NodeId, b: NodeId): Uint8Array {\n  if (a.length !== b.length) {\n    throw new Error(`Node ID length mismatch: ${a.length} vs ${b.length}`);\n  }\n  \n  const result = new Uint8Array(a.length);\n  for (let i = 0; i < a.length; i++) {\n    result[i] = a[i] ^ b[i];\n  }\n  return result;\n}\n\n/**\n * Compare two XOR distances\n * \n * @param a - First distance\n * @param b - Second distance\n * @returns -1 if a < b, 0 if equal, 1 if a > b\n */\nexport function compareDistance(a: Uint8Array, b: Uint8Array): number {\n  const len = Math.max(a.length, b.length);\n  for (let i = 0; i < len; i++) {\n    const aVal = i < a.length ? a[i] : 0;\n    const bVal = i < b.length ? b[i] : 0;\n    if (aVal < bVal) return -1;\n    if (aVal > bVal) return 1;\n  }\n  return 0;\n}\n\n/**\n * Check if distance a is less than distance b\n */\nexport function isCloser(a: Uint8Array, b: Uint8Array): boolean {\n  return compareDistance(a, b) < 0;\n}\n\n/**\n * Find the bucket index for a given XOR distance\n * The bucket index is the position of the first set bit (0-indexed from MSB)\n * \n * @param distance - XOR distance between two node IDs\n * @returns Bucket index (0 to NODE_ID_BITS - 1), or -1 if distance is zero\n */\nexport function bucketIndexFromDistance(distance: Uint8Array): number {\n  for (let i = 0; i < distance.length; i++) {\n    if (distance[i] !== 0) {\n      // Find position of highest set bit in this byte\n      const byte = distance[i];\n      const bitPos = 7 - Math.floor(Math.log2(byte));\n      return i * 8 + bitPos;\n    }\n  }\n  return -1; // Distance is zero (same node ID)\n}\n\n/**\n * Calculate bucket index for a target node relative to local node\n * \n * @param localId - Local node's ID\n * @param targetId - Target node's ID\n * @returns Bucket index (0 to NODE_ID_BITS - 1)\n */\nexport function getBucketIndex(localId: NodeId, targetId: NodeId): number {\n  const distance = xorDistance(localId, targetId);\n  return bucketIndexFromDistance(distance);\n}\n\n/**\n * Convert node ID to hexadecimal string\n */\nexport function nodeIdToHex(nodeId: NodeId): string {\n  return Array.from(nodeId)\n    .map(b => b.toString(16).padStart(2, '0'))\n    .join('');\n}\n\n/**\n * Convert hexadecimal string to node ID\n */\nexport function hexToNodeId(hex: string): NodeId {\n  if (hex.length !== NODE_ID_BYTES * 2) {\n    throw new Error(`Invalid hex string length: expected ${NODE_ID_BYTES * 2}, got ${hex.length}`);\n  }\n  \n  const nodeId = new Uint8Array(NODE_ID_BYTES);\n  for (let i = 0; i < NODE_ID_BYTES; i++) {\n    nodeId[i] = parseInt(hex.substring(i * 2, i * 2 + 2), 16);\n  }\n  return nodeId;\n}\n\n/**\n * Check if two node IDs are equal\n */\nexport function nodeIdsEqual(a: NodeId, b: NodeId): boolean {\n  if (a.length !== b.length) return false;\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) return false;\n  }\n  return true;\n}\n\n/**\n * Validate a node ID\n */\nexport function isValidNodeId(nodeId: unknown): nodeId is NodeId {\n  return (\n    nodeId instanceof Uint8Array &&\n    nodeId.length === NODE_ID_BYTES\n  );\n}\n\n/**\n * Create a copy of a node ID\n */\nexport function copyNodeId(nodeId: NodeId): NodeId {\n  return new Uint8Array(nodeId);\n}\n\n/**\n * Sort contacts by distance to a target node ID\n * \n * @param contacts - Array of objects with nodeId property\n * @param targetId - Target node ID to measure distance from\n * @returns New array sorted by distance (closest first)\n */\nexport function sortByDistance<T extends { nodeId: NodeId }>(\n  contacts: T[],\n  targetId: NodeId\n): T[] {\n  return [...contacts].sort((a, b) => {\n    const distA = xorDistance(a.nodeId, targetId);\n    const distB = xorDistance(b.nodeId, targetId);\n    return compareDistance(distA, distB);\n  });\n}\n\n/**\n * Get the n closest contacts to a target\n * \n * @param contacts - Array of contacts\n * @param targetId - Target node ID\n * @param n - Maximum number of contacts to return\n * @returns Array of up to n closest contacts\n */\nexport function getClosestContacts<T extends { nodeId: NodeId }>(\n  contacts: T[],\n  targetId: NodeId,\n  n: number\n): T[] {\n  const sorted = sortByDistance(contacts, targetId);\n  return sorted.slice(0, n);\n}\n\n/**\n * Generate a random node ID within a specific bucket's range\n * Useful for bucket refresh operations\n * \n * In Kademlia, a node ID falls into bucket i if the XOR distance between\n * the local ID and the target has its highest set bit at position i.\n * \n * To generate an ID in bucket i, we need:\n * 1. All bits before position i to match the local ID (so XOR gives 0)\n * 2. The bit at position i to differ from local ID (so XOR gives 1)\n * 3. Bits after position i can be random (won't affect bucket assignment)\n * \n * @param localId - Local node's ID\n * @param bucketIndex - Target bucket index (0 = furthest, 159 = closest)\n * @returns Random node ID that would fall into the specified bucket\n */\nexport function generateIdInBucket(localId: NodeId, bucketIndex: number): NodeId {\n  if (bucketIndex < 0 || bucketIndex >= NODE_ID_BITS) {\n    throw new Error(`Invalid bucket index: ${bucketIndex}`);\n  }\n\n  // Start with a random ID (provides randomness for suffix bits)\n  const result = generateNodeId();\n  \n  // Calculate which byte and bit position we're targeting\n  // bucketIndex 0 = bit 0 of byte 0 (MSB), bucketIndex 8 = bit 0 of byte 1, etc.\n  const byteIndex = Math.floor(bucketIndex / 8);\n  const bitIndex = bucketIndex % 8;\n  \n  // Copy all bytes before the target byte from local ID\n  // These bits must match local ID so XOR produces 0\n  for (let i = 0; i < byteIndex; i++) {\n    result[i] = localId[i];\n  }\n  \n  // Handle the target byte with bit manipulation:\n  // - mask: isolates the target bit (e.g., bitIndex=0 -> 0x80, bitIndex=7 -> 0x01)\n  // - prefixMask: covers bits before the target (e.g., bitIndex=3 -> 0xE0 = 11100000)\n  const mask = 0x80 >> bitIndex;\n  const prefixMask = (0xFF << (8 - bitIndex)) & 0xFF;\n  \n  // Construct the target byte:\n  // 1. Keep prefix bits same as local (localId[byteIndex] & prefixMask)\n  // 2. Flip the target bit (XOR: mask ^ (localId[byteIndex] & mask))\n  // 3. Keep random suffix bits from generated ID (result[byteIndex] & ~prefixMask & ~mask)\n  result[byteIndex] = (localId[byteIndex] & prefixMask) |\n                      (mask ^ (localId[byteIndex] & mask)) |\n                      (result[byteIndex] & (~prefixMask & ~mask & 0xFF));\n  \n  return result;\n}\n"],"version":3}