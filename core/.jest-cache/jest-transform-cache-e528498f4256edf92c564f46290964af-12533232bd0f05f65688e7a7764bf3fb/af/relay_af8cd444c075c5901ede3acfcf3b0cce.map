{"file":"/Users/christymaxwell/Desktop/Luke_Stuff/GitHub/SC/core/src/mesh/relay.ts","mappings":"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","names":[],"sources":["/Users/christymaxwell/Desktop/Luke_Stuff/GitHub/SC/core/src/mesh/relay.ts"],"sourcesContent":["/**\n * Message Relay and Flood Routing Implementation\n */\n\nimport type { Message } from \"../protocol/message\";\nimport { MessageType, decodeMessage, messageHash } from \"../protocol/message\";\nimport { RoutingTable } from \"./routing.js\";\n\nexport interface RelayStats {\n  messagesReceived: number;\n  messagesForwarded: number;\n  messagesDuplicate: number;\n  messagesExpired: number;\n  messagesForSelf: number;\n  messagesStored: number;\n  relayFailures: number;\n  loopsDetected: number;\n}\n\nexport interface StoredMessage {\n  message: Message;\n  destinationPeerId: string;\n  attempts: number;\n  lastAttempt: number;\n  expiresAt: number;\n  priority: 'high' | 'normal' | 'low';\n  routeAttempts: string[];\n}\n\nexport interface RelayConfig {\n  maxStoredMessages?: number;\n  storeTimeout?: number;\n  maxRetries?: number;\n  retryBackoff?: number;\n  floodRateLimit?: number; // messages per second per peer\n  selectiveFlooding?: boolean;\n  retryInterval?: number; // Auto-retry interval in milliseconds\n}\n\n/**\n * Persistence Adapter Interface\n * Allows plugging in different storage backends (Memory, IndexedDB, SQLite, etc.)\n */\nexport interface PersistenceAdapter {\n  saveMessage(id: string, message: StoredMessage): Promise<void>;\n  getMessage(id: string): Promise<StoredMessage | null>;\n  removeMessage(id: string): Promise<void>;\n  getAllMessages(): Promise<Map<string, StoredMessage>>;\n  pruneExpired(now: number): Promise<void>;\n  size(): Promise<number>;\n}\n\n/**\n * Default In-Memory Persistence Adapter\n */\nexport class MemoryPersistenceAdapter implements PersistenceAdapter {\n  private storage: Map<string, StoredMessage> = new Map();\n\n  async saveMessage(id: string, message: StoredMessage): Promise<void> {\n    this.storage.set(id, message);\n  }\n\n  async getMessage(id: string): Promise<StoredMessage | null> {\n    return this.storage.get(id) || null;\n  }\n\n  async removeMessage(id: string): Promise<void> {\n    this.storage.delete(id);\n  }\n\n  async getAllMessages(): Promise<Map<string, StoredMessage>> {\n    return new Map(this.storage);\n  }\n\n  async pruneExpired(now: number): Promise<void> {\n    for (const [id, msg] of this.storage.entries()) {\n      if (msg.expiresAt < now) {\n        this.storage.delete(id);\n      }\n    }\n  }\n\n  async size(): Promise<number> {\n    return this.storage.size;\n  }\n}\n\n/**\n * Message Relay Engine\n * Implements flood routing with TTL, deduplication, and store-and-forward\n */\nexport class MessageRelay {\n  private routingTable: RoutingTable;\n  private localPeerId: string;\n  private stats: RelayStats = {\n    messagesReceived: 0,\n    messagesForwarded: 0,\n    messagesDuplicate: 0,\n    messagesExpired: 0,\n    messagesForSelf: 0,\n    messagesStored: 0,\n    relayFailures: 0,\n    loopsDetected: 0,\n  };\n\n  private persistence: PersistenceAdapter;\n  private messageRoutes: Map<string, string[]> = new Map(); // messageHash -> path of peer IDs\n  private peerFloodCounter: Map<string, number[]> = new Map(); // peerId -> timestamps\n  private config: RelayConfig;\n  private retryInterval?: NodeJS.Timeout;\n\n  // Callbacks\n  private onMessageForSelfCallback?: (message: Message) => void;\n  private onForwardMessageCallback?: (\n    message: Message,\n    excludePeerId: string,\n  ) => void;\n\n  constructor(\n    localPeerId: string,\n    routingTable: RoutingTable,\n    config: RelayConfig = {},\n    persistence?: PersistenceAdapter,\n  ) {\n    this.localPeerId = localPeerId;\n    this.routingTable = routingTable;\n    this.config = {\n      maxStoredMessages: config.maxStoredMessages || 1000,\n      storeTimeout: config.storeTimeout || 300000, // 5 minutes\n      maxRetries: config.maxRetries || 3,\n      retryBackoff: config.retryBackoff || 5000, // 5 seconds\n      floodRateLimit: config.floodRateLimit || 100, // 100 msg/sec per peer\n      selectiveFlooding: config.selectiveFlooding !== false,\n      retryInterval: config.retryInterval || 10000, // 10 seconds\n    };\n    this.persistence = persistence || new MemoryPersistenceAdapter();\n  }\n\n  /**\n   * Process incoming message and decide whether to forward, deliver, or drop\n   */\n  async processMessage(\n    messageData: Uint8Array,\n    fromPeerId: string,\n  ): Promise<void> {\n    this.stats.messagesReceived++;\n\n    let message: Message;\n    try {\n      message = decodeMessage(messageData);\n    } catch (error) {\n      console.error(\"Failed to decode message:\", error);\n      return;\n    }\n\n    // Step 1: Check if we've seen this message before (deduplication)\n    const hash = messageHash(message);\n    console.log(`[MessageRelay] Processing message from ${fromPeerId}, type=${message.header.type}, hash=${hash.substring(0, 8)}`);\n    \n    if (this.routingTable.hasSeenMessage(hash)) {\n      this.stats.messagesDuplicate++;\n      console.log(`[MessageRelay] Dropping duplicate message ${hash.substring(0, 8)}`);\n      return; // Drop duplicate\n    }\n\n    // Step 2: Check for routing loops\n    if (this.detectLoop(hash, fromPeerId)) {\n      this.stats.loopsDetected++;\n      console.log(`[MessageRelay] Dropping looped message ${hash.substring(0, 8)}`);\n      return; // Drop looped message\n    }\n\n    // Mark as seen\n    this.routingTable.markMessageSeen(hash);\n\n    // Step 3: Check TTL\n    if (message.header.ttl === 0) {\n      this.stats.messagesExpired++;\n      console.log(`[MessageRelay] Dropping expired message (TTL=0)`);\n      return; // Drop expired message\n    }\n\n    // Step 4: Check flood rate limit\n    if (!this.checkFloodRateLimit(fromPeerId)) {\n      console.log(`[MessageRelay] Dropping message due to flood rate limit`);\n      return; // Drop if flooding too fast\n    }\n\n    // Step 5: Determine message relevance and forwarding policy\n    const isBroadcast = this.isBroadcastMessage(message.header.type);\n    const isTarget = this.isMessageForSelf(message);\n    \n    console.log(`[MessageRelay] Message analysis: isBroadcast=${isBroadcast}, isTarget=${isTarget}, localPeerId=${this.localPeerId}`);\n\n    // Deliver to self if we are target or it's a broadcast\n    if (isTarget || isBroadcast) {\n      if (isTarget) this.stats.messagesForSelf++;\n      console.log(`[MessageRelay] ========== DELIVERING MESSAGE TO SELF ==========`);\n      this.onMessageForSelfCallback?.(message);\n    } else {\n      console.log(`[MessageRelay] Message NOT for self, will forward`);\n    }\n\n    // Determine if we should stop forwarding (Unicast to us)\n    // If it's Unicast to us, we stop.\n    // If it's Broadcast, we continue forwarding.\n    // If it's Unicast to someone else, we continue forwarding.\n    if (isTarget && !isBroadcast) {\n      return; // Stop forwarding Unicast addressed to us\n    }\n\n    // Step 6: Decrement TTL for forwarding\n    const forwardMessage: Message = {\n      header: {\n        ...message.header,\n        ttl: message.header.ttl - 1,\n      },\n      payload: message.payload,\n    };\n\n    // Step 7: Forward to all peers except sender (Smart/Flood routing)\n    if (forwardMessage.header.ttl > 0) {\n      if (this.shouldForwardMessage(forwardMessage)) {\n        this.stats.messagesForwarded++;\n        this.onForwardMessageCallback?.(forwardMessage, fromPeerId);\n      }\n    }\n  }\n\n  /**\n   * Detect routing loops based on message path\n   */\n  private detectLoop(messageHash: string, fromPeerId: string): boolean {\n    if (!this.messageRoutes.has(messageHash)) {\n      this.messageRoutes.set(messageHash, []);\n    }\n\n    const path = this.messageRoutes.get(messageHash)!;\n\n    // Check if we've seen this peer in the path\n    if (path.includes(fromPeerId)) {\n      return true; // Loop detected\n    }\n\n    // Add to path\n    path.push(fromPeerId);\n\n    // Limit path tracking (cleanup old entries)\n    if (this.messageRoutes.size > 10000) {\n      const keys = Array.from(this.messageRoutes.keys());\n      for (let i = 0; i < 1000; i++) {\n        this.messageRoutes.delete(keys[i]);\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Check flood rate limit for a peer\n   */\n  private checkFloodRateLimit(peerId: string): boolean {\n    const now = Date.now();\n\n    if (!this.peerFloodCounter.has(peerId)) {\n      this.peerFloodCounter.set(peerId, []);\n    }\n\n    const timestamps = this.peerFloodCounter.get(peerId)!;\n\n    // Remove timestamps older than 1 second\n    const recentTimestamps = timestamps.filter((t) => now - t < 1000);\n\n    // Check rate limit\n    if (recentTimestamps.length >= this.config.floodRateLimit!) {\n      return false; // Rate limit exceeded\n    }\n\n    // Add current timestamp\n    recentTimestamps.push(now);\n    this.peerFloodCounter.set(peerId, recentTimestamps);\n\n    return true;\n  }\n\n  /**\n   * Determine if message should be forwarded (selective flooding)\n   */\n  private shouldForwardMessage(message: Message): boolean {\n    if (!this.config.selectiveFlooding) {\n      return true; // Forward all messages\n    }\n\n    // Always forward control messages\n    if (this.isControlMessage(message.header.type)) {\n      return true;\n    }\n\n    // For other messages, use selective criteria\n    // (Can be extended with topic-based filtering, etc.)\n    return true;\n  }\n\n  /**\n   * Check if message type is control\n   */\n  private isControlMessage(type: MessageType): boolean {\n    return (\n      type === MessageType.CONTROL_PING ||\n      type === MessageType.CONTROL_PONG ||\n      type === MessageType.CONTROL_ACK\n    );\n  }\n\n  /**\n   * Check if message is addressed to this peer\n   */\n  private isMessageForSelf(message: Message): boolean {\n    // For broadcast messages (PEER_DISCOVERY, etc.), everyone processes them\n    if (this.isBroadcastMessage(message.header.type)) {\n      return true;\n    }\n\n    // DHT Messages are point-to-point RPCs, so they are always \"for self\" (the next hop)\n    // The DHT logic itself handles further recursion if needed (e.g. iterative lookup)\n    if (\n      message.header.type >= MessageType.DHT_FIND_NODE &&\n      message.header.type <= MessageType.DHT_FOUND_VALUE\n    ) {\n      return true;\n    }\n\n    // Payload Inspection for Recipient ID (since Header doesn't have it yet)\n    try {\n      // Decode payload to JSON\n      const payloadStr = new TextDecoder().decode(message.payload);\n      const data = JSON.parse(payloadStr);\n\n      if (data.recipient) {\n        // Normalize both IDs to uppercase for comparison\n        const normalizedRecipient = data.recipient.replace(/\\s/g, \"\").toUpperCase();\n        const normalizedLocalId = this.localPeerId.replace(/\\s/g, \"\").toUpperCase();\n        \n        console.log(`[MessageRelay] Checking recipient: ${normalizedRecipient} vs localPeerId: ${normalizedLocalId}`);\n        \n        if (normalizedRecipient === normalizedLocalId) {\n          return true;\n        }\n      }\n    } catch (e) {\n      // Ignore parsing errors, assume not for us if we can't read it\n    }\n\n    return false;\n  }\n\n  /**\n   * Check if message type is broadcast\n   */\n  private isBroadcastMessage(type: MessageType): boolean {\n    return (\n      type === MessageType.PEER_DISCOVERY ||\n      type === MessageType.PEER_INTRODUCTION ||\n      type === MessageType.CONTROL_PING ||\n      type === MessageType.CONTROL_PONG\n    );\n  }\n\n  /**\n   * Store message for offline peer (store-and-forward)\n   */\n  async storeMessage(\n    message: Message,\n    destinationPeerId: string,\n  ): Promise<void> {\n    const currentSize = await this.persistence.size();\n    if (currentSize >= this.config.maxStoredMessages!) {\n      // Remove oldest message\n      // Note: This is less efficient with async persistence, might need optimization\n      const allMessages = await this.persistence.getAllMessages();\n      const oldest = Array.from(allMessages.entries()).sort(\n        (a, b) => a[1].lastAttempt - b[1].lastAttempt,\n      )[0];\n      if (oldest) {\n        await this.persistence.removeMessage(oldest[0]);\n      }\n    }\n\n    const hash = messageHash(message);\n    await this.persistence.saveMessage(hash, {\n      message,\n      destinationPeerId,\n      attempts: 0,\n      lastAttempt: Date.now(),\n      expiresAt: Date.now() + this.config.storeTimeout!,\n      priority: 'normal',\n      routeAttempts: [],\n    });\n\n    this.stats.messagesStored++;\n  }\n\n  /**\n   * Retry forwarding stored messages with sneakernet approach\n   */\n  async retryStoredMessages(): Promise<void> {\n    const now = Date.now();\n    const toDelete: string[] = [];\n    const allMessages = await this.persistence.getAllMessages();\n\n    // Get all connected peers for potential relay\n    const connectedPeers = this.routingTable.getAllPeers().filter(p => p.state === 'connected');\n    \n    for (const [hash, stored] of allMessages.entries()) {\n      // Check expiry\n      if (stored.expiresAt < now) {\n        toDelete.push(hash);\n        this.stats.messagesExpired++;\n        continue;\n      }\n\n      // Check retry backoff\n      const timeSinceLastAttempt = now - stored.lastAttempt;\n      const backoffTime = this.config.retryBackoff! * Math.pow(2, stored.attempts);\n\n      if (timeSinceLastAttempt < backoffTime) {\n        continue; // Not time to retry yet\n      }\n\n      // SNEAKERNET APPROACH: Try multiple routing strategies\n      let deliveryAttempted = false;\n      \n      // Strategy 1: Direct delivery if target peer is connected\n      const targetPeer = this.routingTable.getPeer(stored.destinationPeerId);\n      if (targetPeer && targetPeer.state === 'connected') {\n        console.log(`[MessageRelay] ðŸŽ¯ Direct delivery to ${stored.destinationPeerId}`);\n        this.onForwardMessageCallback?.(stored.message, \"\");\n        deliveryAttempted = true;\n      }\n      // Strategy 2: Relay through any connected peer (sneakernet)\n      else if (connectedPeers.length > 0) {\n        // Try each connected peer as a potential relay\n        for (const relayPeer of connectedPeers) {\n          // Don't try the same relay peer twice for the same message\n          if (stored.routeAttempts.includes(relayPeer.id)) {\n            continue;\n          }\n          \n          console.log(`[MessageRelay] ðŸš¸ Sneakernet relay via ${relayPeer.id} to reach ${stored.destinationPeerId}`);\n          \n          // Mark this peer as attempted for routing\n          stored.routeAttempts.push(relayPeer.id);\n          \n          // Forward message through this peer\n          this.onForwardMessageCallback?.(stored.message, relayPeer.id);\n          deliveryAttempted = true;\n          break; // Try one peer per retry cycle\n        }\n      }\n\n      // Update attempt tracking\n      stored.attempts++;\n      stored.lastAttempt = now;\n\n      if (!deliveryAttempted) {\n        console.log(`[MessageRelay] âŒ No delivery path available for ${stored.destinationPeerId}`);\n      }\n\n      // Check if we've exceeded max retries\n      if (stored.attempts > this.config.maxRetries!) {\n        console.log(`[MessageRelay] ðŸ’€ Giving up on message to ${stored.destinationPeerId} after ${stored.attempts} attempts`);\n        toDelete.push(hash);\n        this.stats.relayFailures++;\n      } else {\n        // Update stored state with new route attempts\n        await this.persistence.saveMessage(hash, stored);\n        this.stats.messagesForwarded++;\n      }\n    }\n\n    // Clean up expired/failed messages\n    for (const hash of toDelete) {\n      await this.persistence.removeMessage(hash);\n    }\n\n    // Log statistics\n    if (allMessages.size > 0) {\n      console.log(`[MessageRelay] ðŸ“Š Retry cycle complete: ${allMessages.size - toDelete.length} messages retained, ${toDelete.length} cleaned up`);\n    }\n  }\n\n  /**\n   * Get stored messages statistics\n   */\n  async getStoredMessagesStats() {\n    const allMessages = await this.persistence.getAllMessages();\n    return {\n      total: allMessages.size,\n      byDestination: Array.from(allMessages.values()).reduce(\n        (acc, msg) => {\n          acc[msg.destinationPeerId] = (acc[msg.destinationPeerId] || 0) + 1;\n          return acc;\n        },\n        {} as Record<string, number>,\n      ),\n    };\n  }\n\n  /**\n   * Register callback for messages addressed to this peer\n   */\n  onMessageForSelf(callback: (message: Message) => void): void {\n    this.onMessageForSelfCallback = callback;\n  }\n\n  /**\n   * Register callback for forwarding messages\n   */\n  onForwardMessage(\n    callback: (message: Message, excludePeerId: string) => void,\n  ): void {\n    this.onForwardMessageCallback = callback;\n  }\n\n  /**\n   * Start automatic retry process\n   */\n  start(): void {\n    if (this.retryInterval) {\n      clearInterval(this.retryInterval);\n    }\n    \n    console.log(`[MessageRelay] ðŸš€ Starting automatic retry every ${this.config.retryInterval}ms`);\n    this.retryInterval = setInterval(() => {\n      this.retryStoredMessages().catch(error => {\n        console.error('[MessageRelay] Error in automatic retry:', error);\n      });\n    }, this.config.retryInterval!);\n  }\n\n  /**\n   * Stop automatic retry process\n   */\n  stop(): void {\n    if (this.retryInterval) {\n      clearInterval(this.retryInterval);\n      this.retryInterval = undefined;\n      console.log('[MessageRelay] ðŸ›‘ Stopped automatic retry');\n    }\n  }\n\n  /**\n   * Get relay statistics\n   */\n  getStats(): RelayStats {\n    return { ...this.stats };\n  }\n\n  /**\n   * Reset statistics\n   */\n  resetStats(): void {\n    this.stats = {\n      messagesReceived: 0,\n      messagesForwarded: 0,\n      messagesDuplicate: 0,\n      messagesExpired: 0,\n      messagesForSelf: 0,\n      messagesStored: 0,\n      relayFailures: 0,\n      loopsDetected: 0,\n    };\n  }\n}\n\n/**\n * Message Fragmentation for Large Messages\n */\nexport interface MessageFragment {\n  messageId: string;\n  fragmentIndex: number;\n  totalFragments: number;\n  data: Uint8Array;\n  timestamp: number;\n}\n\nexport const MAX_FRAGMENT_SIZE = 16384; // 16KB per fragment\nexport const MIN_FRAGMENT_SIZE = 512; // 512 bytes minimum\n\n/**\n * Calculate optimal fragment size based on MTU and network conditions\n */\nexport function calculateFragmentSize(\n  mtu: number = 1500,\n  overhead: number = 100,\n): number {\n  const optimalSize = mtu - overhead;\n  return Math.max(MIN_FRAGMENT_SIZE, Math.min(MAX_FRAGMENT_SIZE, optimalSize));\n}\n\n/**\n * Fragment a large message into smaller chunks\n */\nexport function fragmentMessage(\n  message: Uint8Array,\n  messageId: string,\n  fragmentSize: number = MAX_FRAGMENT_SIZE,\n): MessageFragment[] {\n  const fragments: MessageFragment[] = [];\n  const totalFragments = Math.ceil(message.length / fragmentSize);\n\n  for (let i = 0; i < totalFragments; i++) {\n    const start = i * fragmentSize;\n    const end = Math.min(start + fragmentSize, message.length);\n    const data = message.slice(start, end);\n\n    fragments.push({\n      messageId,\n      fragmentIndex: i,\n      totalFragments,\n      data,\n      timestamp: Date.now(),\n    });\n  }\n\n  return fragments;\n}\n\n/**\n * Calculate fragmentation overhead\n */\nexport function calculateFragmentationOverhead(\n  messageSize: number,\n  fragmentSize: number = MAX_FRAGMENT_SIZE,\n): number {\n  const totalFragments = Math.ceil(messageSize / fragmentSize);\n  const headerOverhead = 50; // Approximate header size per fragment\n  return totalFragments * headerOverhead;\n}\n\n/**\n * Message Reassembly Engine with timeout and memory limits\n */\nexport class MessageReassembler {\n  private fragments: Map<string, Map<number, Uint8Array>> = new Map();\n  private totalFragments: Map<string, number> = new Map();\n  private fragmentTimestamps: Map<string, number> = new Map();\n  private onCompleteCallback?: (messageId: string, message: Uint8Array) => void;\n  private readonly REASSEMBLY_TIMEOUT = 60000; // 60 seconds\n  private readonly MAX_REASSEMBLY_BUFFER = 100 * 1024 * 1024; // 100 MB\n  private currentBufferSize = 0;\n\n  /**\n   * Add a fragment to the reassembly buffer\n   */\n  addFragment(fragment: MessageFragment): boolean {\n    const { messageId, fragmentIndex, totalFragments, data } = fragment;\n\n    // Check for duplicate fragments\n    if (this.fragments.has(messageId)) {\n      const messageFragments = this.fragments.get(messageId)!;\n      if (messageFragments.has(fragmentIndex)) {\n        return false; // Duplicate fragment\n      }\n    }\n\n    // Initialize fragment map for this message if needed\n    if (!this.fragments.has(messageId)) {\n      this.fragments.set(messageId, new Map());\n      this.totalFragments.set(messageId, totalFragments);\n      this.fragmentTimestamps.set(messageId, Date.now());\n    }\n\n    // Check memory limits\n    if (this.currentBufferSize + data.length > this.MAX_REASSEMBLY_BUFFER) {\n      this.cleanupOldest();\n    }\n\n    // Add fragment\n    const messageFragments = this.fragments.get(messageId)!;\n    messageFragments.set(fragmentIndex, data);\n    this.currentBufferSize += data.length;\n\n    // Check if we have all fragments\n    if (messageFragments.size === totalFragments) {\n      this.reassembleMessage(messageId);\n      return true; // Message complete\n    }\n\n    return false; // Still waiting for more fragments\n  }\n\n  /**\n   * Reassemble complete message from fragments (handles out-of-order)\n   */\n  private reassembleMessage(messageId: string): void {\n    const messageFragments = this.fragments.get(messageId);\n    const totalFragments = this.totalFragments.get(messageId);\n\n    if (!messageFragments || !totalFragments) {\n      return;\n    }\n\n    // Calculate total size\n    let totalSize = 0;\n    for (let i = 0; i < totalFragments; i++) {\n      const fragment = messageFragments.get(i);\n      if (!fragment) {\n        console.error(`Missing fragment ${i} for message ${messageId}`);\n        return;\n      }\n      totalSize += fragment.length;\n    }\n\n    // Reassemble in correct order\n    const completeMessage = new Uint8Array(totalSize);\n    let offset = 0;\n\n    for (let i = 0; i < totalFragments; i++) {\n      const fragment = messageFragments.get(i)!;\n      completeMessage.set(fragment, offset);\n      offset += fragment.length;\n    }\n\n    // Update buffer size\n    this.currentBufferSize -= totalSize;\n\n    // Clean up\n    this.fragments.delete(messageId);\n    this.totalFragments.delete(messageId);\n    this.fragmentTimestamps.delete(messageId);\n\n    // Notify completion\n    this.onCompleteCallback?.(messageId, completeMessage);\n  }\n\n  /**\n   * Register callback for completed messages\n   */\n  onComplete(callback: (messageId: string, message: Uint8Array) => void): void {\n    this.onCompleteCallback = callback;\n  }\n\n  /**\n   * Clean up expired incomplete messages\n   */\n  cleanup(maxAgeMs: number = this.REASSEMBLY_TIMEOUT): number {\n    const now = Date.now();\n    const toDelete: string[] = [];\n\n    for (const [messageId, timestamp] of this.fragmentTimestamps.entries()) {\n      if (now - timestamp > maxAgeMs) {\n        toDelete.push(messageId);\n      }\n    }\n\n    let freedBytes = 0;\n    for (const messageId of toDelete) {\n      const messageFragments = this.fragments.get(messageId);\n      if (messageFragments) {\n        for (const fragment of messageFragments.values()) {\n          freedBytes += fragment.length;\n        }\n      }\n      this.fragments.delete(messageId);\n      this.totalFragments.delete(messageId);\n      this.fragmentTimestamps.delete(messageId);\n    }\n\n    this.currentBufferSize -= freedBytes;\n    return toDelete.length;\n  }\n\n  /**\n   * Clean up oldest incomplete message to free memory\n   */\n  private cleanupOldest(): void {\n    if (this.fragmentTimestamps.size === 0) return;\n\n    const oldest = Array.from(this.fragmentTimestamps.entries()).sort(\n      (a, b) => a[1] - b[1],\n    )[0];\n\n    if (oldest) {\n      const [messageId] = oldest;\n      const messageFragments = this.fragments.get(messageId);\n\n      if (messageFragments) {\n        for (const fragment of messageFragments.values()) {\n          this.currentBufferSize -= fragment.length;\n        }\n      }\n\n      this.fragments.delete(messageId);\n      this.totalFragments.delete(messageId);\n      this.fragmentTimestamps.delete(messageId);\n    }\n  }\n\n  /**\n   * Get reassembly statistics\n   */\n  getStats() {\n    return {\n      incompleteMessages: this.fragments.size,\n      fragmentsWaiting: Array.from(this.fragments.values()).reduce(\n        (sum, map) => sum + map.size,\n        0,\n      ),\n      bufferUsage: this.currentBufferSize,\n      bufferLimit: this.MAX_REASSEMBLY_BUFFER,\n    };\n  }\n}\n"],"version":3}