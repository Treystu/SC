{"file":"/Users/christymaxwell/Desktop/Luke_Stuff/GitHub/SC/core/src/mesh/dht/types.ts","mappings":";AAAA;;;GAGG;;;AAqGH;;GAEG;AACU,QAAA,uBAAuB,GAAwC;IAC1E,CAAC,EAAE,EAAE,EAAE,gCAAgC;IACvC,KAAK,EAAE,CAAC,EAAE,4BAA4B;IACtC,WAAW,EAAE,IAAI,EAAE,YAAY;IAC/B,eAAe,EAAE,OAAO,EAAE,SAAS;IACnC,iBAAiB,EAAE,EAAE,EAAE,2BAA2B;IAClD,oBAAoB,EAAE,EAAE;IACxB,iBAAiB,EAAE,OAAO,EAAE,SAAS;CACtC,CAAC;AAgCF;;GAEG;AACH,IAAY,cAmBX;AAnBD,WAAY,cAAc;IACxB,6BAA6B;IAC7B,yCAAuB,CAAA;IACvB,4BAA4B;IAC5B,2DAAyC,CAAA;IACzC,8BAA8B;IAC9B,2CAAyB,CAAA;IACzB,wCAAwC;IACxC,6DAA2C,CAAA;IAC3C,0DAA0D;IAC1D,uDAAqC,CAAA;IACrC,+BAA+B;IAC/B,iCAAe,CAAA;IACf,wBAAwB;IACxB,mDAAiC,CAAA;IACjC,mBAAmB;IACnB,+BAAa,CAAA;IACb,oBAAoB;IACpB,+BAAa,CAAA;AACf,CAAC,EAnBW,cAAc,8BAAd,cAAc,QAmBzB;AAiID;;GAEG;AACH,IAAY,YASX;AATD,WAAY,YAAY;IACtB,iCAAiC;IACjC,6CAA6B,CAAA;IAC7B,kDAAkD;IAClD,+CAA+B,CAAA;IAC/B,qDAAqD;IACrD,qCAAqB,CAAA;IACrB,wBAAwB;IACxB,uCAAuB,CAAA;AACzB,CAAC,EATW,YAAY,4BAAZ,YAAY,QASvB;AAkDD;;GAEG;AACU,QAAA,wBAAwB,GAA4C;IAC/E,gBAAgB,EAAE,KAAK,EAAE,aAAa;IACtC,iBAAiB,EAAE,CAAC;IACpB,kBAAkB,EAAE,CAAC;CACtB,CAAC","names":[],"sources":["/Users/christymaxwell/Desktop/Luke_Stuff/GitHub/SC/core/src/mesh/dht/types.ts"],"sourcesContent":["/**\n * Kademlia DHT Type Definitions\n * Core types for the distributed hash table implementation\n */\n\n/**\n * Node ID - 160-bit (20-byte) identifier for DHT nodes\n * Represented as Uint8Array for efficient XOR operations\n */\nexport type NodeId = Uint8Array;\n\n/**\n * DHT Key - 160-bit key used for lookups\n * Same format as NodeId for consistent XOR distance calculations\n */\nexport type DHTKey = Uint8Array;\n\n/**\n * DHT Value - arbitrary data stored in the DHT\n */\nexport interface DHTValue {\n  /** Raw data bytes */\n  data: Uint8Array;\n  /** Timestamp when the value was stored */\n  storedAt: number;\n  /** Time-to-live in milliseconds */\n  ttl: number;\n  /** Publisher's node ID */\n  publisherId: NodeId;\n}\n\n/**\n * Contact information for a DHT node\n */\nexport interface DHTContact {\n  /** Node's unique identifier */\n  nodeId: NodeId;\n  /** Hex-encoded peer ID for mesh network integration */\n  peerId: string;\n  /** Last time this contact was seen */\n  lastSeen: number;\n  /** Round-trip time in milliseconds */\n  rtt?: number;\n  /** Number of failed requests */\n  failureCount: number;\n  /** Endpoint information */\n  endpoints?: DHTEndpoint[];\n}\n\n/**\n * Endpoint for DHT communication\n */\nexport interface DHTEndpoint {\n  type: 'webrtc' | 'bluetooth' | 'local' | 'manual';\n  address?: string;\n}\n\n/**\n * K-Bucket configuration\n * \n * These parameters control individual bucket behavior. They are inherited\n * by KademliaConfig to ensure consistent behavior across the routing table.\n */\nexport interface KBucketConfig {\n  /** \n   * Maximum number of contacts per bucket (k parameter).\n   * Standard Kademlia uses k=20. Higher values increase redundancy but use more memory.\n   */\n  k: number;\n  /** \n   * Ping timeout in milliseconds.\n   * How long to wait for a ping response before considering a node unresponsive.\n   */\n  pingTimeout: number;\n  /** \n   * Number of nodes to query in parallel (alpha parameter).\n   * Standard Kademlia uses alpha=3. Higher values speed up lookups but increase load.\n   */\n  alpha: number;\n}\n\n/**\n * Kademlia routing table configuration\n * \n * Extends KBucketConfig to inherit k, alpha, and pingTimeout parameters.\n * These inherited parameters are used consistently across bucket management\n * and routing table operations:\n * - k: Used for both bucket size and number of closest nodes to return\n * - alpha: Used for parallel queries in both findNode and findValue\n * - pingTimeout: Used for RPC timeout in bucket eviction and liveness checks\n */\nexport interface KademliaConfig extends KBucketConfig {\n  /** Local node ID */\n  localNodeId: NodeId;\n  /** Bucket refresh interval in milliseconds */\n  refreshInterval: number;\n  /** Value replication factor (typically same as k) */\n  replicationFactor: number;\n  /** Maximum concurrent lookups to prevent resource exhaustion */\n  maxConcurrentLookups: number;\n  /** Republish interval in milliseconds for stored values */\n  republishInterval: number;\n}\n\n/**\n * Default Kademlia configuration values\n */\nexport const DEFAULT_KADEMLIA_CONFIG: Omit<KademliaConfig, 'localNodeId'> = {\n  k: 20, // Number of contacts per bucket\n  alpha: 3, // Parallel lookup parameter\n  pingTimeout: 5000, // 5 seconds\n  refreshInterval: 3600000, // 1 hour\n  replicationFactor: 20, // Store at k closest nodes\n  maxConcurrentLookups: 10,\n  republishInterval: 3600000, // 1 hour\n};\n\n/**\n * Result of a node lookup operation\n */\nexport interface NodeLookupResult {\n  /** Closest nodes found */\n  closestNodes: DHTContact[];\n  /** Number of queries made */\n  queriesMade: number;\n  /** Time taken in milliseconds */\n  duration: number;\n  /** Whether the exact node was found */\n  found: boolean;\n}\n\n/**\n * Result of a value lookup operation\n */\nexport interface ValueLookupResult {\n  /** The found value, or undefined if not found */\n  value?: DHTValue;\n  /** Nodes queried during lookup */\n  queriedNodes: DHTContact[];\n  /** Closest nodes that might have the value */\n  closestNodes: DHTContact[];\n  /** Time taken in milliseconds */\n  duration: number;\n  /** Whether the value was found */\n  found: boolean;\n}\n\n/**\n * DHT RPC message types\n */\nexport enum DHTMessageType {\n  /** Request to find a node */\n  FIND_NODE = 'FIND_NODE',\n  /** Response to FIND_NODE */\n  FIND_NODE_RESPONSE = 'FIND_NODE_RESPONSE',\n  /** Request to find a value */\n  FIND_VALUE = 'FIND_VALUE',\n  /** Response to FIND_VALUE with value */\n  FIND_VALUE_RESPONSE = 'FIND_VALUE_RESPONSE',\n  /** Response to FIND_VALUE with nodes (value not found) */\n  FIND_VALUE_NODES = 'FIND_VALUE_NODES',\n  /** Request to store a value */\n  STORE = 'STORE',\n  /** Response to STORE */\n  STORE_RESPONSE = 'STORE_RESPONSE',\n  /** Ping request */\n  PING = 'PING',\n  /** Pong response */\n  PONG = 'PONG',\n}\n\n/**\n * Base DHT message structure\n */\nexport interface DHTMessage {\n  /** Message type */\n  type: DHTMessageType;\n  /** Sender's node ID */\n  senderId: NodeId;\n  /** Message ID for request/response correlation */\n  messageId: string;\n  /** Timestamp */\n  timestamp: number;\n}\n\n/**\n * FIND_NODE request\n */\nexport interface FindNodeRequest extends DHTMessage {\n  type: DHTMessageType.FIND_NODE;\n  /** Target node ID to find */\n  targetId: NodeId;\n}\n\n/**\n * FIND_NODE response\n */\nexport interface FindNodeResponse extends DHTMessage {\n  type: DHTMessageType.FIND_NODE_RESPONSE;\n  /** Closest known nodes to the target */\n  nodes: DHTContact[];\n}\n\n/**\n * FIND_VALUE request\n */\nexport interface FindValueRequest extends DHTMessage {\n  type: DHTMessageType.FIND_VALUE;\n  /** Key to look up */\n  key: DHTKey;\n}\n\n/**\n * FIND_VALUE response with value\n */\nexport interface FindValueResponse extends DHTMessage {\n  type: DHTMessageType.FIND_VALUE_RESPONSE;\n  /** The stored value */\n  value: DHTValue;\n}\n\n/**\n * FIND_VALUE response with nodes (value not found locally)\n */\nexport interface FindValueNodesResponse extends DHTMessage {\n  type: DHTMessageType.FIND_VALUE_NODES;\n  /** Closest known nodes to the key */\n  nodes: DHTContact[];\n}\n\n/**\n * STORE request\n */\nexport interface StoreRequest extends DHTMessage {\n  type: DHTMessageType.STORE;\n  /** Key to store */\n  key: DHTKey;\n  /** Value to store */\n  value: DHTValue;\n}\n\n/**\n * STORE response\n */\nexport interface StoreResponse extends DHTMessage {\n  type: DHTMessageType.STORE_RESPONSE;\n  /** Whether the store was successful */\n  success: boolean;\n}\n\n/**\n * PING request\n */\nexport interface PingRequest extends DHTMessage {\n  type: DHTMessageType.PING;\n}\n\n/**\n * PONG response\n */\nexport interface PongResponse extends DHTMessage {\n  type: DHTMessageType.PONG;\n}\n\n/**\n * Union type for all DHT messages\n */\nexport type DHTRPCMessage =\n  | FindNodeRequest\n  | FindNodeResponse\n  | FindValueRequest\n  | FindValueResponse\n  | FindValueNodesResponse\n  | StoreRequest\n  | StoreResponse\n  | PingRequest\n  | PongResponse;\n\n/**\n * DHT statistics\n */\nexport interface DHTStats {\n  /** Number of nodes in routing table */\n  nodeCount: number;\n  /** Number of stored values */\n  valueCount: number;\n  /** Number of buckets with at least one node */\n  activeBuckets: number;\n  /** Total lookups performed */\n  totalLookups: number;\n  /** Successful lookups */\n  successfulLookups: number;\n  /** Average lookup time in milliseconds */\n  avgLookupTime: number;\n  /** Memory usage estimate in bytes */\n  memoryUsage: number;\n}\n\n/**\n * Network state types\n */\nexport enum NetworkState {\n  /** Not connected to any peers */\n  DISCONNECTED = 'DISCONNECTED',\n  /** Bootstrapping - connecting to initial nodes */\n  BOOTSTRAPPING = 'BOOTSTRAPPING',\n  /** Partially connected - fewer nodes than desired */\n  DEGRADED = 'DEGRADED',\n  /** Fully operational */\n  CONNECTED = 'CONNECTED',\n}\n\n/**\n * Network topology information\n */\nexport interface NetworkTopology {\n  /** Current network state */\n  state: NetworkState;\n  /** Total number of known nodes */\n  totalNodes: number;\n  /** Number of directly connected peers */\n  directPeers: number;\n  /** Estimated network size */\n  estimatedNetworkSize: number;\n  /** Distribution of nodes across buckets */\n  bucketDistribution: number[];\n  /** Average node latency */\n  avgLatency: number;\n  /** Network health score (0-100) */\n  healthScore: number;\n}\n\n/**\n * Bootstrap node information\n */\nexport interface BootstrapNode {\n  /** Node ID */\n  nodeId: NodeId;\n  /** Peer ID for mesh integration */\n  peerId: string;\n  /** Endpoints */\n  endpoints: DHTEndpoint[];\n  /** Whether this is a trusted bootstrap node */\n  trusted: boolean;\n}\n\n/**\n * Bootstrap configuration\n */\nexport interface BootstrapConfig {\n  /** List of initial bootstrap nodes */\n  bootstrapNodes: BootstrapNode[];\n  /** Maximum time to wait for bootstrap in milliseconds */\n  bootstrapTimeout: number;\n  /** Minimum nodes required for successful bootstrap */\n  minBootstrapNodes: number;\n  /** Number of parallel bootstrap attempts */\n  parallelBootstraps: number;\n}\n\n/**\n * Default bootstrap configuration\n */\nexport const DEFAULT_BOOTSTRAP_CONFIG: Omit<BootstrapConfig, 'bootstrapNodes'> = {\n  bootstrapTimeout: 30000, // 30 seconds\n  minBootstrapNodes: 1,\n  parallelBootstraps: 3,\n};\n"],"version":3}