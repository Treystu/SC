{"file":"/Users/christymaxwell/Desktop/Luke_Stuff/GitHub/SC/core/src/mesh/gossip.ts","mappings":"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","names":[],"sources":["/Users/christymaxwell/Desktop/Luke_Stuff/GitHub/SC/core/src/mesh/gossip.ts"],"sourcesContent":["/**\n * Gossip Protocol Implementation for Scalable Mesh Routing\n * Addresses V1.0 Audit Critical Gap #3: Unscalable Routing\n * \n * Implements a hybrid push-pull gossip protocol with epidemic spreading\n * to replace pure flood routing for better scalability\n */\n\nimport { Message, messageHash } from '../protocol/message.js';\n\nexport interface GossipConfig {\n  fanout: number; // Number of peers to gossip to (default: 3-5)\n  gossipInterval: number; // Milliseconds between gossip rounds (default: 1000)\n  maxMessageAge: number; // Max age of messages to gossip (default: 60000)\n  pruneInterval: number; // How often to prune old messages (default: 30000)\n  pushPullRatio: number; // Ratio of push vs pull (0-1, default: 0.7)\n  maxDigestSize: number; // Maximum number of message hashes in digest (default: 50)\n}\n\ninterface GossipMessage {\n  hash: string;\n  timestamp: number;\n  message: Message;\n  received: number;\n  hops: number;\n}\n\ninterface GossipPeer {\n  id: string;\n  lastSeen: number;\n  messagesExchanged: number;\n}\n\n/**\n * Gossip Protocol Manager\n * Implements epidemic-style message dissemination with:\n * - Push gossip: Proactively push new messages to random peers\n * - Pull gossip: Request messages we haven't seen\n * - Anti-entropy: Periodic synchronization to catch missed messages\n */\nexport class GossipProtocol {\n  private config: Required<GossipConfig>;\n  private messages: Map<string, GossipMessage> = new Map();\n  private peers: Map<string, GossipPeer> = new Map();\n  private messagesSeen: Set<string> = new Set();\n  private gossipInterval: NodeJS.Timeout | null = null;\n  private pruneInterval: NodeJS.Timeout | null = null;\n  \n  // Callbacks\n  private onMessageReceived: ((message: Message, fromPeer: string) => void) | null = null;\n  private onMessageForward: ((message: Message, toPeers: string[]) => Promise<void>) | null = null;\n  private onDigestRequest: ((peerId: string, digest: string[]) => Promise<string[]>) | null = null;\n  private onDigestResponse: ((peerId: string, missingHashes: string[]) => Promise<Message[]>) | null = null;\n\n  constructor(config?: Partial<GossipConfig>) {\n    this.config = {\n      fanout: config?.fanout ?? 4, // Gossip to 4 random peers\n      gossipInterval: config?.gossipInterval ?? 1000, // Every second\n      maxMessageAge: config?.maxMessageAge ?? 60000, // 1 minute\n      pruneInterval: config?.pruneInterval ?? 30000, // 30 seconds\n      pushPullRatio: config?.pushPullRatio ?? 0.7, // 70% push, 30% pull\n      maxDigestSize: config?.maxDigestSize ?? 50, // Limit digest to 50 messages\n    };\n  }\n\n  /**\n   * Start the gossip protocol\n   */\n  start(): void {\n    if (this.gossipInterval) return; // Already started\n\n    this.gossipInterval = setInterval(() => {\n      this.performGossipRound();\n    }, this.config.gossipInterval);\n\n    try {\n      if (this.gossipInterval && typeof (this.gossipInterval as any).unref === 'function') {\n        (this.gossipInterval as any).unref();\n      }\n    } catch (e) { /* no-op */ }\n\n    this.pruneInterval = setInterval(() => {\n      this.pruneOldMessages();\n    }, this.config.pruneInterval);\n    try {\n      if (this.pruneInterval && typeof (this.pruneInterval as any).unref === 'function') {\n        (this.pruneInterval as any).unref();\n      }\n    } catch (e) { /* no-op */ }\n  }\n\n  /**\n   * Stop the gossip protocol\n   */\n  stop(): void {\n    if (this.gossipInterval) {\n      clearInterval(this.gossipInterval);\n      this.gossipInterval = null;\n    }\n    if (this.pruneInterval) {\n      clearInterval(this.pruneInterval);\n      this.pruneInterval = null;\n    }\n  }\n\n  /**\n   * Register a callback for when new messages are received\n   */\n  onMessage(callback: (message: Message, fromPeer: string) => void): void {\n    this.onMessageReceived = callback;\n  }\n\n  /**\n   * Register a callback for forwarding messages to specific peers\n   */\n  onForward(callback: (message: Message, toPeers: string[]) => Promise<void>): void {\n    this.onMessageForward = callback;\n  }\n\n  /**\n   * Register a callback for digest exchange (pull gossip)\n   * The callback should return message hashes that the peer is missing\n   */\n  onDigestExchange(\n    requestCallback: (peerId: string, digest: string[]) => Promise<string[]>,\n    responseCallback: (peerId: string, missingHashes: string[]) => Promise<Message[]>,\n  ): void {\n    this.onDigestRequest = requestCallback;\n    this.onDigestResponse = responseCallback;\n  }\n\n  /**\n   * Add a peer to the gossip network\n   */\n  addPeer(peerId: string): void {\n    if (!this.peers.has(peerId)) {\n      this.peers.set(peerId, {\n        id: peerId,\n        lastSeen: Date.now(),\n        messagesExchanged: 0,\n      });\n    }\n  }\n\n  /**\n   * Remove a peer from the gossip network\n   */\n  removePeer(peerId: string): void {\n    this.peers.delete(peerId);\n  }\n\n  /**\n   * Receive a message from the network\n   * Returns true if this is a new message, false if duplicate\n   */\n  receiveMessage(message: Message, fromPeer: string): boolean {\n    const hash = messageHash(message);\n\n    // Check if we've seen this message before\n    if (this.messagesSeen.has(hash)) {\n      return false; // Duplicate\n    }\n\n    // Mark as seen\n    this.messagesSeen.add(hash);\n\n    // Store the message\n    const gossipMsg: GossipMessage = {\n      hash,\n      timestamp: message.header.timestamp,\n      message,\n      received: Date.now(),\n      hops: 0, // We'll track this in the message metadata\n    };\n\n    this.messages.set(hash, gossipMsg);\n\n    // Update peer stats\n    const peer = this.peers.get(fromPeer);\n    if (peer) {\n      peer.lastSeen = Date.now();\n      peer.messagesExchanged++;\n    }\n\n    // Notify callback\n    if (this.onMessageReceived) {\n      this.onMessageReceived(message, fromPeer);\n    }\n\n    return true; // New message\n  }\n\n  /**\n   * Perform a gossip round: push/pull messages with random peers\n   */\n  private async performGossipRound(): Promise<void> {\n    if (this.peers.size === 0) return;\n\n    const now = Date.now();\n    const activePeers = Array.from(this.peers.values()).filter(\n      (p) => now - p.lastSeen < 30000 // Only gossip with active peers (seen in last 30s)\n    );\n\n    if (activePeers.length === 0) return;\n\n    // Select random peers for this round (fanout)\n    const selectedPeers = this.selectRandomPeers(activePeers, this.config.fanout);\n\n    // Hybrid push-pull: Use ratio to determine which operation to perform\n    // Push gossip is good for fast dissemination of new messages\n    // Pull gossip is good for anti-entropy (recovering missed messages)\n    if (Math.random() < this.config.pushPullRatio) {\n      await this.pushGossip(selectedPeers);\n    } else {\n      await this.pullGossip(selectedPeers);\n    }\n  }\n\n  /**\n   * Push gossip: Send recent messages to selected peers\n   */\n  private async pushGossip(peers: GossipPeer[]): Promise<void> {\n    const now = Date.now();\n    const recentMessages: Message[] = [];\n\n    // Select recent messages to gossip\n    for (const gossipMsg of this.messages.values()) {\n      if (now - gossipMsg.received < this.config.maxMessageAge) {\n        recentMessages.push(gossipMsg.message);\n      }\n    }\n\n    if (recentMessages.length === 0 || !this.onMessageForward) return;\n\n    // Forward messages to selected peers\n    const peerIds = peers.map((p) => p.id);\n    \n    // Send a subset of recent messages to avoid overwhelming the network\n    const messagesToSend = this.selectRandomMessages(recentMessages, 10);\n    \n    for (const message of messagesToSend) {\n      await this.onMessageForward(message, peerIds);\n    }\n  }\n\n  /**\n   * Create a digest of our recent messages (list of hashes)\n   * Used for pull gossip to determine what messages we're missing\n   */\n  private createDigest(): string[] {\n    const now = Date.now();\n    const digest: string[] = [];\n\n    for (const [hash, gossipMsg] of this.messages.entries()) {\n      // Only include recent messages in digest\n      if (now - gossipMsg.received < this.config.maxMessageAge) {\n        digest.push(hash);\n      }\n    }\n\n    return digest;\n  }\n\n  /**\n   * Handle digest from peer and return hashes we're missing\n   * Used in pull gossip to identify messages to request\n   */\n  handleDigest(peerDigest: string[]): string[] {\n    const missing: string[] = [];\n\n    for (const hash of peerDigest) {\n      if (!this.messagesSeen.has(hash)) {\n        missing.push(hash);\n      }\n    }\n\n    // Limit number of missing messages to request (configurable to prevent overwhelming)\n    return missing.slice(0, this.config.maxDigestSize);\n  }\n\n  /**\n   * Get messages by their hashes\n   * Used to respond to pull gossip requests\n   */\n  getMessagesByHashes(hashes: string[]): Message[] {\n    const messages: Message[] = [];\n\n    for (const hash of hashes) {\n      const gossipMsg = this.messages.get(hash);\n      if (gossipMsg) {\n        messages.push(gossipMsg.message);\n      }\n    }\n\n    return messages;\n  }\n\n  /**\n   * Pull gossip: Request messages we might have missed\n   * Uses digest exchange to sync with peers\n   */\n  private async pullGossip(peers: GossipPeer[]): Promise<void> {\n    if (!this.onDigestRequest || !this.onDigestResponse) {\n      // Callbacks not registered, skip pull gossip\n      return;\n    }\n\n    // Create digest of our current messages\n    const ourDigest = this.createDigest();\n\n    // For each selected peer, exchange digests\n    for (const peer of peers) {\n      try {\n        // Send our digest and get missing hashes from peer\n        const missingHashes = await this.onDigestRequest(peer.id, ourDigest);\n\n        if (missingHashes.length > 0) {\n          // Request the missing messages\n          const missingMessages = await this.onDigestResponse(peer.id, missingHashes);\n\n          // Add the received messages to our store\n          for (const message of missingMessages) {\n            try {\n              this.receiveMessage(message, peer.id);\n            } catch (error) {\n              console.error(`Failed to process gossip message from peer ${peer.id}:`, error);\n              // Continue processing remaining messages even if one fails\n            }\n          }\n        }\n      } catch (error) {\n        console.error(`Pull gossip failed with peer ${peer.id}:`, error);\n      }\n    }\n  }\n\n  /**\n   * Select N random peers from the active peer list\n   * Optimized to only shuffle the first N positions\n   */\n  private selectRandomPeers(peers: GossipPeer[], count: number): GossipPeer[] {\n    if (peers.length <= count) return peers;\n\n    const shuffled = [...peers];\n    // Only shuffle first 'count' positions for better performance\n    for (let i = 0; i < count; i++) {\n      const j = i + Math.floor(Math.random() * (shuffled.length - i));\n      [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];\n    }\n\n    return shuffled.slice(0, count);\n  }\n\n  /**\n   * Select N random messages from the message list\n   * Optimized to only shuffle the first N positions\n   */\n  private selectRandomMessages(messages: Message[], count: number): Message[] {\n    if (messages.length <= count) return messages;\n\n    const shuffled = [...messages];\n    // Only shuffle first 'count' positions for better performance\n    for (let i = 0; i < count; i++) {\n      const j = i + Math.floor(Math.random() * (shuffled.length - i));\n      [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];\n    }\n\n    return shuffled.slice(0, count);\n  }\n\n  /**\n   * Remove old messages from memory\n   */\n  private pruneOldMessages(): void {\n    const now = Date.now();\n    const toDelete: string[] = [];\n\n    for (const [hash, gossipMsg] of this.messages.entries()) {\n      if (now - gossipMsg.received > this.config.maxMessageAge) {\n        toDelete.push(hash);\n      }\n    }\n\n    for (const hash of toDelete) {\n      this.messages.delete(hash);\n      this.messagesSeen.delete(hash);\n    }\n  }\n\n  /**\n   * Get statistics about the gossip protocol\n   */\n  getStats(): {\n    messageCount: number;\n    seenCount: number;\n    peerCount: number;\n    activePeerCount: number;\n  } {\n    const now = Date.now();\n    const activePeerCount = Array.from(this.peers.values()).filter(\n      (p) => now - p.lastSeen < 30000\n    ).length;\n\n    return {\n      messageCount: this.messages.size,\n      seenCount: this.messagesSeen.size,\n      peerCount: this.peers.size,\n      activePeerCount,\n    };\n  }\n\n  /**\n   * Clear all state (useful for testing)\n   */\n  clear(): void {\n    this.messages.clear();\n    this.messagesSeen.clear();\n    this.peers.clear();\n  }\n}\n"],"version":3}