{
  "version": 3,
  "sources": ["../core/dist/mobile.js", "../node_modules/@noble/hashes/src/utils.ts", "../node_modules/@noble/hashes/src/_md.ts", "../node_modules/@noble/hashes/src/_u64.ts", "../node_modules/@noble/hashes/src/sha2.ts", "../node_modules/@noble/curves/src/utils.ts", "../node_modules/@noble/curves/src/abstract/modular.ts", "../node_modules/@noble/curves/src/abstract/curve.ts", "../node_modules/@noble/curves/src/abstract/edwards.ts", "../node_modules/@noble/curves/src/abstract/montgomery.ts", "../node_modules/@noble/curves/src/ed25519.ts", "../node_modules/@noble/ciphers/src/utils.ts", "../node_modules/@noble/ciphers/src/_arx.ts", "../node_modules/@noble/ciphers/src/_poly1305.ts", "../node_modules/@noble/ciphers/src/chacha.ts", "../node_modules/@noble/hashes/src/hmac.ts", "../node_modules/@noble/hashes/src/hkdf.ts", "../core/dist/crypto/primitives.js", "../core/dist/protocol/message.js", "../core/dist/mesh/routing.js", "../core/dist/crypto/envelope.js", "../core/dist/transport/Transport.js", "../core/dist/utils/fingerprint.js", "../core/dist/mesh/relay.js"],
  "sourcesContent": ["/**\n * Mobile-safe exports for core library\n *\n * This module exports only the essential cryptography, protocol, and mesh\n * functionality that can run in embedded JavaScript engines (JavaScriptCore,\n * QuickJS, etc.) without browser-specific or Node.js-specific dependencies.\n */\n// Core cryptographic primitives (uses @noble/* libraries which are platform-agnostic)\nexport { generateIdentity, signMessage, verifySignature, deriveSharedSecret, generateSessionKey, encryptMessage, decryptMessage, generateNonce, generateFingerprint, } from \"./crypto/primitives.js\";\n// Protocol\nexport { encodeMessage, decodeMessage, MessageType, } from \"./protocol/message.js\";\n// Mesh routing (platform-agnostic)\nexport { RoutingTable, createPeer, PeerState, MessageQueue, } from \"./mesh/routing.js\";\n// Envelope encryption\nexport { encryptEnvelope, decryptEnvelope, signEnvelope, verifyEnvelope, serializeEncryptedEnvelope, deserializeEncryptedEnvelope, serializeSignedEnvelope, deserializeSignedEnvelope, } from \"./crypto/envelope.js\";\n// Transport abstraction\nexport { DefaultTransportRegistry, } from \"./transport/Transport.js\";\n// Fingerprint utilities\nexport { generateFullFingerprint, formatFingerprint, isValidPublicKey, publicKeyToBase64, base64ToPublicKey, compareFingerprints, } from \"./utils/fingerprint.js\";\n// Relay (deduplication, message forwarding)\nexport { MessageRelay, } from \"./mesh/relay.js\";\n// Version\nexport const VERSION = \"0.1.0\";\nexport const MOBILE_BUNDLE = true;\n", "/**\n * Utilities for hex, bytes, CSPRNG.\n * @module\n */\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */\nexport function isBytes(a: unknown): a is Uint8Array {\n  return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n\n/** Asserts something is positive integer. */\nexport function anumber(n: number, title: string = ''): void {\n  if (!Number.isSafeInteger(n) || n < 0) {\n    const prefix = title && `\"${title}\" `;\n    throw new Error(`${prefix}expected integer >= 0, got ${n}`);\n  }\n}\n\n/** Asserts something is Uint8Array. */\nexport function abytes(value: Uint8Array, length?: number, title: string = ''): Uint8Array {\n  const bytes = isBytes(value);\n  const len = value?.length;\n  const needsLen = length !== undefined;\n  if (!bytes || (needsLen && len !== length)) {\n    const prefix = title && `\"${title}\" `;\n    const ofLen = needsLen ? ` of length ${length}` : '';\n    const got = bytes ? `length=${len}` : `type=${typeof value}`;\n    throw new Error(prefix + 'expected Uint8Array' + ofLen + ', got ' + got);\n  }\n  return value;\n}\n\n/** Asserts something is hash */\nexport function ahash(h: CHash): void {\n  if (typeof h !== 'function' || typeof h.create !== 'function')\n    throw new Error('Hash must wrapped by utils.createHasher');\n  anumber(h.outputLen);\n  anumber(h.blockLen);\n}\n\n/** Asserts a hash instance has not been destroyed / finished */\nexport function aexists(instance: any, checkFinished = true): void {\n  if (instance.destroyed) throw new Error('Hash instance has been destroyed');\n  if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');\n}\n\n/** Asserts output is properly-sized byte array */\nexport function aoutput(out: any, instance: any): void {\n  abytes(out, undefined, 'digestInto() output');\n  const min = instance.outputLen;\n  if (out.length < min) {\n    throw new Error('\"digestInto() output\" expected to be of length >=' + min);\n  }\n}\n\n/** Generic type encompassing 8/16/32-byte arrays - but not 64-byte. */\n// prettier-ignore\nexport type TypedArray = Int8Array | Uint8ClampedArray | Uint8Array |\n  Uint16Array | Int16Array | Uint32Array | Int32Array;\n\n/** Cast u8 / u16 / u32 to u8. */\nexport function u8(arr: TypedArray): Uint8Array {\n  return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n\n/** Cast u8 / u16 / u32 to u32. */\nexport function u32(arr: TypedArray): Uint32Array {\n  return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n}\n\n/** Zeroize a byte array. Warning: JS provides no guarantees. */\nexport function clean(...arrays: TypedArray[]): void {\n  for (let i = 0; i < arrays.length; i++) {\n    arrays[i].fill(0);\n  }\n}\n\n/** Create DataView of an array for easy byte-level manipulation. */\nexport function createView(arr: TypedArray): DataView {\n  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n\n/** The rotate right (circular right shift) operation for uint32 */\nexport function rotr(word: number, shift: number): number {\n  return (word << (32 - shift)) | (word >>> shift);\n}\n\n/** The rotate left (circular left shift) operation for uint32 */\nexport function rotl(word: number, shift: number): number {\n  return (word << shift) | ((word >>> (32 - shift)) >>> 0);\n}\n\n/** Is current platform little-endian? Most are. Big-Endian platform: IBM */\nexport const isLE: boolean = /* @__PURE__ */ (() =>\n  new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();\n\n/** The byte swap operation for uint32 */\nexport function byteSwap(word: number): number {\n  return (\n    ((word << 24) & 0xff000000) |\n    ((word << 8) & 0xff0000) |\n    ((word >>> 8) & 0xff00) |\n    ((word >>> 24) & 0xff)\n  );\n}\n/** Conditionally byte swap if on a big-endian platform */\nexport const swap8IfBE: (n: number) => number = isLE\n  ? (n: number) => n\n  : (n: number) => byteSwap(n);\n\n/** In place byte swap for Uint32Array */\nexport function byteSwap32(arr: Uint32Array): Uint32Array {\n  for (let i = 0; i < arr.length; i++) {\n    arr[i] = byteSwap(arr[i]);\n  }\n  return arr;\n}\n\nexport const swap32IfBE: (u: Uint32Array) => Uint32Array = isLE\n  ? (u: Uint32Array) => u\n  : byteSwap32;\n\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\nconst hasHexBuiltin: boolean = /* @__PURE__ */ (() =>\n  // @ts-ignore\n  typeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function')();\n\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) =>\n  i.toString(16).padStart(2, '0')\n);\n\n/**\n * Convert byte array to hex string. Uses built-in function, when available.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes: Uint8Array): string {\n  abytes(bytes);\n  // @ts-ignore\n  if (hasHexBuiltin) return bytes.toHex();\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\n\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 } as const;\nfunction asciiToBase16(ch: number): number | undefined {\n  if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0; // '2' => 50-48\n  if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n  if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n  return;\n}\n\n/**\n * Convert hex string to byte array. Uses built-in function, when available.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  // @ts-ignore\n  if (hasHexBuiltin) return Uint8Array.fromHex(hex);\n  const hl = hex.length;\n  const al = hl / 2;\n  if (hl % 2) throw new Error('hex string expected, got unpadded hex of length ' + hl);\n  const array = new Uint8Array(al);\n  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n    const n1 = asciiToBase16(hex.charCodeAt(hi));\n    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n    if (n1 === undefined || n2 === undefined) {\n      const char = hex[hi] + hex[hi + 1];\n      throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n    }\n    array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n  }\n  return array;\n}\n\n/**\n * There is no setImmediate in browser and setTimeout is slow.\n * Call of async fn will return Promise, which will be fullfiled only on\n * next scheduler queue processing step and this is exactly what we need.\n */\nexport const nextTick = async (): Promise<void> => {};\n\n/** Returns control to thread each 'tick' ms to avoid blocking. */\nexport async function asyncLoop(\n  iters: number,\n  tick: number,\n  cb: (i: number) => void\n): Promise<void> {\n  let ts = Date.now();\n  for (let i = 0; i < iters; i++) {\n    cb(i);\n    // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n    const diff = Date.now() - ts;\n    if (diff >= 0 && diff < tick) continue;\n    await nextTick();\n    ts += diff;\n  }\n}\n\n// Global symbols, but ts doesn't see them: https://github.com/microsoft/TypeScript/issues/31535\ndeclare const TextEncoder: any;\n\n/**\n * Converts string to bytes using UTF8 encoding.\n * Built-in doesn't validate input to be string: we do the check.\n * @example utf8ToBytes('abc') // Uint8Array.from([97, 98, 99])\n */\nexport function utf8ToBytes(str: string): Uint8Array {\n  if (typeof str !== 'string') throw new Error('string expected');\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n\n/** KDFs can accept string or Uint8Array for user convenience. */\nexport type KDFInput = string | Uint8Array;\n\n/**\n * Helper for KDFs: consumes uint8array or string.\n * When string is passed, does utf8 decoding, using TextDecoder.\n */\nexport function kdfInputToBytes(data: KDFInput, errorTitle = ''): Uint8Array {\n  if (typeof data === 'string') return utf8ToBytes(data);\n  return abytes(data, undefined, errorTitle);\n}\n\n/** Copies several Uint8Arrays into one. */\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  let sum = 0;\n  for (let i = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    abytes(a);\n    sum += a.length;\n  }\n  const res = new Uint8Array(sum);\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    res.set(a, pad);\n    pad += a.length;\n  }\n  return res;\n}\n\ntype EmptyObj = {};\n/** Merges default options and passed options. */\nexport function checkOpts<T1 extends EmptyObj, T2 extends EmptyObj>(\n  defaults: T1,\n  opts?: T2\n): T1 & T2 {\n  if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')\n    throw new Error('options must be object or undefined');\n  const merged = Object.assign(defaults, opts);\n  return merged as T1 & T2;\n}\n\n/** Common interface for all hashes. */\nexport interface Hash<T> {\n  blockLen: number; // Bytes per block\n  outputLen: number; // Bytes in output\n  update(buf: Uint8Array): this;\n  digestInto(buf: Uint8Array): void;\n  digest(): Uint8Array;\n  destroy(): void;\n  _cloneInto(to?: T): T;\n  clone(): T;\n}\n\n/** PseudoRandom (number) Generator */\nexport interface PRG {\n  addEntropy(seed: Uint8Array): void;\n  randomBytes(length: number): Uint8Array;\n  clean(): void;\n}\n\n/**\n * XOF: streaming API to read digest in chunks.\n * Same as 'squeeze' in keccak/k12 and 'seek' in blake3, but more generic name.\n * When hash used in XOF mode it is up to user to call '.destroy' afterwards, since we cannot\n * destroy state, next call can require more bytes.\n */\nexport type HashXOF<T extends Hash<T>> = Hash<T> & {\n  xof(bytes: number): Uint8Array; // Read 'bytes' bytes from digest stream\n  xofInto(buf: Uint8Array): Uint8Array; // read buf.length bytes from digest stream into buf\n};\n\n/** Hash constructor */\nexport type HasherCons<T, Opts = undefined> = Opts extends undefined ? () => T : (opts?: Opts) => T;\n/** Optional hash params. */\nexport type HashInfo = {\n  oid?: Uint8Array; // DER encoded OID in bytes\n};\n/** Hash function */\nexport type CHash<T extends Hash<T> = Hash<any>, Opts = undefined> = {\n  outputLen: number;\n  blockLen: number;\n} & HashInfo &\n  (Opts extends undefined\n    ? {\n        (msg: Uint8Array): Uint8Array;\n        create(): T;\n      }\n    : {\n        (msg: Uint8Array, opts?: Opts): Uint8Array;\n        create(opts?: Opts): T;\n      });\n/** XOF with output */\nexport type CHashXOF<T extends HashXOF<T> = HashXOF<any>, Opts = undefined> = CHash<T, Opts>;\n\n/** Creates function with outputLen, blockLen, create properties from a class constructor. */\nexport function createHasher<T extends Hash<T>, Opts = undefined>(\n  hashCons: HasherCons<T, Opts>,\n  info: HashInfo = {}\n): CHash<T, Opts> {\n  const hashC: any = (msg: Uint8Array, opts?: Opts) => hashCons(opts).update(msg).digest();\n  const tmp = hashCons(undefined);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts?: Opts) => hashCons(opts);\n  Object.assign(hashC, info);\n  return Object.freeze(hashC);\n}\n\n/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */\nexport function randomBytes(bytesLength = 32): Uint8Array {\n  const cr = typeof globalThis === 'object' ? (globalThis as any).crypto : null;\n  if (typeof cr?.getRandomValues !== 'function')\n    throw new Error('crypto.getRandomValues must be defined');\n  return cr.getRandomValues(new Uint8Array(bytesLength));\n}\n\n/** Creates OID opts for NIST hashes, with prefix 06 09 60 86 48 01 65 03 04 02. */\nexport const oidNist = (suffix: number): Required<HashInfo> => ({\n  oid: Uint8Array.from([0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, suffix]),\n});\n", "/**\n * Internal Merkle-Damgard hash utils.\n * @module\n */\nimport { abytes, aexists, aoutput, clean, createView, type Hash } from './utils.ts';\n\n/** Choice: a ? b : c */\nexport function Chi(a: number, b: number, c: number): number {\n  return (a & b) ^ (~a & c);\n}\n\n/** Majority function, true if any two inputs is true. */\nexport function Maj(a: number, b: number, c: number): number {\n  return (a & b) ^ (a & c) ^ (b & c);\n}\n\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */\nexport abstract class HashMD<T extends HashMD<T>> implements Hash<T> {\n  protected abstract process(buf: DataView, offset: number): void;\n  protected abstract get(): number[];\n  protected abstract set(...args: number[]): void;\n  abstract destroy(): void;\n  protected abstract roundClean(): void;\n\n  readonly blockLen: number;\n  readonly outputLen: number;\n  readonly padOffset: number;\n  readonly isLE: boolean;\n\n  // For partial updates less than block size\n  protected buffer: Uint8Array;\n  protected view: DataView;\n  protected finished = false;\n  protected length = 0;\n  protected pos = 0;\n  protected destroyed = false;\n\n  constructor(blockLen: number, outputLen: number, padOffset: number, isLE: boolean) {\n    this.blockLen = blockLen;\n    this.outputLen = outputLen;\n    this.padOffset = padOffset;\n    this.isLE = isLE;\n    this.buffer = new Uint8Array(blockLen);\n    this.view = createView(this.buffer);\n  }\n  update(data: Uint8Array): this {\n    aexists(this);\n    abytes(data);\n    const { view, buffer, blockLen } = this;\n    const len = data.length;\n    for (let pos = 0; pos < len; ) {\n      const take = Math.min(blockLen - this.pos, len - pos);\n      // Fast path: we have at least one block in input, cast it to view and process\n      if (take === blockLen) {\n        const dataView = createView(data);\n        for (; blockLen <= len - pos; pos += blockLen) this.process(dataView, pos);\n        continue;\n      }\n      buffer.set(data.subarray(pos, pos + take), this.pos);\n      this.pos += take;\n      pos += take;\n      if (this.pos === blockLen) {\n        this.process(view, 0);\n        this.pos = 0;\n      }\n    }\n    this.length += data.length;\n    this.roundClean();\n    return this;\n  }\n  digestInto(out: Uint8Array): void {\n    aexists(this);\n    aoutput(out, this);\n    this.finished = true;\n    // Padding\n    // We can avoid allocation of buffer for padding completely if it\n    // was previously not allocated here. But it won't change performance.\n    const { buffer, view, blockLen, isLE } = this;\n    let { pos } = this;\n    // append the bit '1' to the message\n    buffer[pos++] = 0b10000000;\n    clean(this.buffer.subarray(pos));\n    // we have less than padOffset left in buffer, so we cannot put length in\n    // current block, need process it and pad again\n    if (this.padOffset > blockLen - pos) {\n      this.process(view, 0);\n      pos = 0;\n    }\n    // Pad until full block byte with zeros\n    for (let i = pos; i < blockLen; i++) buffer[i] = 0;\n    // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n    // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n    // So we just write lowest 64 bits of that value.\n    view.setBigUint64(blockLen - 8, BigInt(this.length * 8), isLE);\n    this.process(view, 0);\n    const oview = createView(out);\n    const len = this.outputLen;\n    // NOTE: we do division by 4 later, which must be fused in single op with modulo by JIT\n    if (len % 4) throw new Error('_sha2: outputLen must be aligned to 32bit');\n    const outLen = len / 4;\n    const state = this.get();\n    if (outLen > state.length) throw new Error('_sha2: outputLen bigger than state');\n    for (let i = 0; i < outLen; i++) oview.setUint32(4 * i, state[i], isLE);\n  }\n  digest(): Uint8Array {\n    const { buffer, outputLen } = this;\n    this.digestInto(buffer);\n    const res = buffer.slice(0, outputLen);\n    this.destroy();\n    return res;\n  }\n  _cloneInto(to?: T): T {\n    to ||= new (this.constructor as any)() as T;\n    to.set(...this.get());\n    const { blockLen, buffer, length, finished, destroyed, pos } = this;\n    to.destroyed = destroyed;\n    to.finished = finished;\n    to.length = length;\n    to.pos = pos;\n    if (length % blockLen) to.buffer.set(buffer);\n    return to as unknown as any;\n  }\n  clone(): T {\n    return this._cloneInto();\n  }\n}\n\n/**\n * Initial SHA-2 state: fractional parts of square roots of first 16 primes 2..53.\n * Check out `test/misc/sha2-gen-iv.js` for recomputation guide.\n */\n\n/** Initial SHA256 state. Bits 0..32 of frac part of sqrt of primes 2..19 */\nexport const SHA256_IV: Uint32Array = /* @__PURE__ */ Uint32Array.from([\n  0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19,\n]);\n\n/** Initial SHA224 state. Bits 32..64 of frac part of sqrt of primes 23..53 */\nexport const SHA224_IV: Uint32Array = /* @__PURE__ */ Uint32Array.from([\n  0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939, 0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4,\n]);\n\n/** Initial SHA384 state. Bits 0..64 of frac part of sqrt of primes 23..53 */\nexport const SHA384_IV: Uint32Array = /* @__PURE__ */ Uint32Array.from([\n  0xcbbb9d5d, 0xc1059ed8, 0x629a292a, 0x367cd507, 0x9159015a, 0x3070dd17, 0x152fecd8, 0xf70e5939,\n  0x67332667, 0xffc00b31, 0x8eb44a87, 0x68581511, 0xdb0c2e0d, 0x64f98fa7, 0x47b5481d, 0xbefa4fa4,\n]);\n\n/** Initial SHA512 state. Bits 0..64 of frac part of sqrt of primes 2..19 */\nexport const SHA512_IV: Uint32Array = /* @__PURE__ */ Uint32Array.from([\n  0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b, 0x3c6ef372, 0xfe94f82b, 0xa54ff53a, 0x5f1d36f1,\n  0x510e527f, 0xade682d1, 0x9b05688c, 0x2b3e6c1f, 0x1f83d9ab, 0xfb41bd6b, 0x5be0cd19, 0x137e2179,\n]);\n", "/**\n * Internal helpers for u64. BigUint64Array is too slow as per 2025, so we implement it using Uint32Array.\n * @todo re-check https://issues.chromium.org/issues/42212588\n * @module\n */\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\n\nfunction fromBig(\n  n: bigint,\n  le = false\n): {\n  h: number;\n  l: number;\n} {\n  if (le) return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n  return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\n\nfunction split(lst: bigint[], le = false): Uint32Array[] {\n  const len = lst.length;\n  let Ah = new Uint32Array(len);\n  let Al = new Uint32Array(len);\n  for (let i = 0; i < len; i++) {\n    const { h, l } = fromBig(lst[i], le);\n    [Ah[i], Al[i]] = [h, l];\n  }\n  return [Ah, Al];\n}\n\nconst toBig = (h: number, l: number): bigint => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h: number, _l: number, s: number): number => h >>> s;\nconst shrSL = (h: number, l: number, s: number): number => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h: number, l: number, s: number): number => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h: number, l: number, s: number): number => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h: number, l: number, s: number): number => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h: number, l: number, s: number): number => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h: number, l: number): number => l;\nconst rotr32L = (h: number, _l: number): number => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h: number, l: number, s: number): number => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h: number, l: number, s: number): number => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h: number, l: number, s: number): number => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h: number, l: number, s: number): number => (h << (s - 32)) | (l >>> (64 - s));\n\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(\n  Ah: number,\n  Al: number,\n  Bh: number,\n  Bl: number\n): {\n  h: number;\n  l: number;\n} {\n  const l = (Al >>> 0) + (Bl >>> 0);\n  return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al: number, Bl: number, Cl: number): number => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low: number, Ah: number, Bh: number, Ch: number): number =>\n  (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al: number, Bl: number, Cl: number, Dl: number): number =>\n  (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low: number, Ah: number, Bh: number, Ch: number, Dh: number): number =>\n  (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al: number, Bl: number, Cl: number, Dl: number, El: number): number =>\n  (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low: number, Ah: number, Bh: number, Ch: number, Dh: number, Eh: number): number =>\n  (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n\n// prettier-ignore\nexport {\n  add, add3H, add3L, add4H, add4L, add5H, add5L, fromBig, rotlBH, rotlBL, rotlSH, rotlSL, rotr32H, rotr32L, rotrBH, rotrBL, rotrSH, rotrSL, shrSH, shrSL, split, toBig\n};\n// prettier-ignore\nconst u64: { fromBig: typeof fromBig; split: typeof split; toBig: (h: number, l: number) => bigint; shrSH: (h: number, _l: number, s: number) => number; shrSL: (h: number, l: number, s: number) => number; rotrSH: (h: number, l: number, s: number) => number; rotrSL: (h: number, l: number, s: number) => number; rotrBH: (h: number, l: number, s: number) => number; rotrBL: (h: number, l: number, s: number) => number; rotr32H: (_h: number, l: number) => number; rotr32L: (h: number, _l: number) => number; rotlSH: (h: number, l: number, s: number) => number; rotlSL: (h: number, l: number, s: number) => number; rotlBH: (h: number, l: number, s: number) => number; rotlBL: (h: number, l: number, s: number) => number; add: typeof add; add3L: (Al: number, Bl: number, Cl: number) => number; add3H: (low: number, Ah: number, Bh: number, Ch: number) => number; add4L: (Al: number, Bl: number, Cl: number, Dl: number) => number; add4H: (low: number, Ah: number, Bh: number, Ch: number, Dh: number) => number; add5H: (low: number, Ah: number, Bh: number, Ch: number, Dh: number, Eh: number) => number; add5L: (Al: number, Bl: number, Cl: number, Dl: number, El: number) => number; } = {\n  fromBig, split, toBig,\n  shrSH, shrSL,\n  rotrSH, rotrSL, rotrBH, rotrBL,\n  rotr32H, rotr32L,\n  rotlSH, rotlSL, rotlBH, rotlBL,\n  add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nexport default u64;\n", "/**\n * SHA2 hash function. A.k.a. sha256, sha384, sha512, sha512_224, sha512_256.\n * SHA256 is the fastest hash implementable in JS, even faster than Blake3.\n * Check out [RFC 4634](https://www.rfc-editor.org/rfc/rfc4634) and\n * [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).\n * @module\n */\nimport { Chi, HashMD, Maj, SHA224_IV, SHA256_IV, SHA384_IV, SHA512_IV } from './_md.ts';\nimport * as u64 from './_u64.ts';\nimport { type CHash, clean, createHasher, oidNist, rotr } from './utils.ts';\n\n/**\n * Round constants:\n * First 32 bits of fractional parts of the cube roots of the first 64 primes 2..311)\n */\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ Uint32Array.from([\n  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n\n/** Reusable temporary buffer. \"W\" comes straight from spec. */\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\n\n/** Internal 32-byte base SHA2 hash class. */\nabstract class SHA2_32B<T extends SHA2_32B<T>> extends HashMD<T> {\n  // We cannot use array here since array allows indexing by variable\n  // which means optimizer/compiler cannot use registers.\n  protected abstract A: number;\n  protected abstract B: number;\n  protected abstract C: number;\n  protected abstract D: number;\n  protected abstract E: number;\n  protected abstract F: number;\n  protected abstract G: number;\n  protected abstract H: number;\n\n  constructor(outputLen: number) {\n    super(64, outputLen, 8, false);\n  }\n  protected get(): [number, number, number, number, number, number, number, number] {\n    const { A, B, C, D, E, F, G, H } = this;\n    return [A, B, C, D, E, F, G, H];\n  }\n  // prettier-ignore\n  protected set(\n    A: number, B: number, C: number, D: number, E: number, F: number, G: number, H: number\n  ): void {\n    this.A = A | 0;\n    this.B = B | 0;\n    this.C = C | 0;\n    this.D = D | 0;\n    this.E = E | 0;\n    this.F = F | 0;\n    this.G = G | 0;\n    this.H = H | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n    for (let i = 0; i < 16; i++, offset += 4) SHA256_W[i] = view.getUint32(offset, false);\n    for (let i = 16; i < 64; i++) {\n      const W15 = SHA256_W[i - 15];\n      const W2 = SHA256_W[i - 2];\n      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ (W15 >>> 3);\n      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ (W2 >>> 10);\n      SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n    }\n    // Compression function main loop, 64 rounds\n    let { A, B, C, D, E, F, G, H } = this;\n    for (let i = 0; i < 64; i++) {\n      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);\n      const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);\n      const T2 = (sigma0 + Maj(A, B, C)) | 0;\n      H = G;\n      G = F;\n      F = E;\n      E = (D + T1) | 0;\n      D = C;\n      C = B;\n      B = A;\n      A = (T1 + T2) | 0;\n    }\n    // Add the compressed chunk to the current hash value\n    A = (A + this.A) | 0;\n    B = (B + this.B) | 0;\n    C = (C + this.C) | 0;\n    D = (D + this.D) | 0;\n    E = (E + this.E) | 0;\n    F = (F + this.F) | 0;\n    G = (G + this.G) | 0;\n    H = (H + this.H) | 0;\n    this.set(A, B, C, D, E, F, G, H);\n  }\n  protected roundClean(): void {\n    clean(SHA256_W);\n  }\n  destroy(): void {\n    this.set(0, 0, 0, 0, 0, 0, 0, 0);\n    clean(this.buffer);\n  }\n}\n\n/** Internal SHA2-256 hash class. */\nexport class _SHA256 extends SHA2_32B<_SHA256> {\n  // We cannot use array here since array allows indexing by variable\n  // which means optimizer/compiler cannot use registers.\n  protected A: number = SHA256_IV[0] | 0;\n  protected B: number = SHA256_IV[1] | 0;\n  protected C: number = SHA256_IV[2] | 0;\n  protected D: number = SHA256_IV[3] | 0;\n  protected E: number = SHA256_IV[4] | 0;\n  protected F: number = SHA256_IV[5] | 0;\n  protected G: number = SHA256_IV[6] | 0;\n  protected H: number = SHA256_IV[7] | 0;\n  constructor() {\n    super(32);\n  }\n}\n\n/** Internal SHA2-224 hash class. */\nexport class _SHA224 extends SHA2_32B<_SHA224> {\n  protected A: number = SHA224_IV[0] | 0;\n  protected B: number = SHA224_IV[1] | 0;\n  protected C: number = SHA224_IV[2] | 0;\n  protected D: number = SHA224_IV[3] | 0;\n  protected E: number = SHA224_IV[4] | 0;\n  protected F: number = SHA224_IV[5] | 0;\n  protected G: number = SHA224_IV[6] | 0;\n  protected H: number = SHA224_IV[7] | 0;\n  constructor() {\n    super(28);\n  }\n}\n\n// SHA2-512 is slower than sha256 in js because u64 operations are slow.\n\n// Round contants\n// First 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409\n// prettier-ignore\nconst K512 = /* @__PURE__ */ (() => u64.split([\n  '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',\n  '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',\n  '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',\n  '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',\n  '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',\n  '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',\n  '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',\n  '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',\n  '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',\n  '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',\n  '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',\n  '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',\n  '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',\n  '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',\n  '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',\n  '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',\n  '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',\n  '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',\n  '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',\n  '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'\n].map(n => BigInt(n))))();\nconst SHA512_Kh = /* @__PURE__ */ (() => K512[0])();\nconst SHA512_Kl = /* @__PURE__ */ (() => K512[1])();\n\n// Reusable temporary buffers\nconst SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);\nconst SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);\n\n/** Internal 64-byte base SHA2 hash class. */\nabstract class SHA2_64B<T extends SHA2_64B<T>> extends HashMD<T> {\n  // We cannot use array here since array allows indexing by variable\n  // which means optimizer/compiler cannot use registers.\n  // h -- high 32 bits, l -- low 32 bits\n  protected abstract Ah: number;\n  protected abstract Al: number;\n  protected abstract Bh: number;\n  protected abstract Bl: number;\n  protected abstract Ch: number;\n  protected abstract Cl: number;\n  protected abstract Dh: number;\n  protected abstract Dl: number;\n  protected abstract Eh: number;\n  protected abstract El: number;\n  protected abstract Fh: number;\n  protected abstract Fl: number;\n  protected abstract Gh: number;\n  protected abstract Gl: number;\n  protected abstract Hh: number;\n  protected abstract Hl: number;\n\n  constructor(outputLen: number) {\n    super(128, outputLen, 16, false);\n  }\n  // prettier-ignore\n  protected get(): [\n    number, number, number, number, number, number, number, number,\n    number, number, number, number, number, number, number, number\n  ] {\n    const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n    return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\n  }\n  // prettier-ignore\n  protected set(\n    Ah: number, Al: number, Bh: number, Bl: number, Ch: number, Cl: number, Dh: number, Dl: number,\n    Eh: number, El: number, Fh: number, Fl: number, Gh: number, Gl: number, Hh: number, Hl: number\n  ): void {\n    this.Ah = Ah | 0;\n    this.Al = Al | 0;\n    this.Bh = Bh | 0;\n    this.Bl = Bl | 0;\n    this.Ch = Ch | 0;\n    this.Cl = Cl | 0;\n    this.Dh = Dh | 0;\n    this.Dl = Dl | 0;\n    this.Eh = Eh | 0;\n    this.El = El | 0;\n    this.Fh = Fh | 0;\n    this.Fl = Fl | 0;\n    this.Gh = Gh | 0;\n    this.Gl = Gl | 0;\n    this.Hh = Hh | 0;\n    this.Hl = Hl | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n    for (let i = 0; i < 16; i++, offset += 4) {\n      SHA512_W_H[i] = view.getUint32(offset);\n      SHA512_W_L[i] = view.getUint32((offset += 4));\n    }\n    for (let i = 16; i < 80; i++) {\n      // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n      const W15h = SHA512_W_H[i - 15] | 0;\n      const W15l = SHA512_W_L[i - 15] | 0;\n      const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);\n      const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);\n      // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n      const W2h = SHA512_W_H[i - 2] | 0;\n      const W2l = SHA512_W_L[i - 2] | 0;\n      const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);\n      const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);\n      // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n      const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n      const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n      SHA512_W_H[i] = SUMh | 0;\n      SHA512_W_L[i] = SUMl | 0;\n    }\n    let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n    // Compression function main loop, 80 rounds\n    for (let i = 0; i < 80; i++) {\n      // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n      const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);\n      const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);\n      //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n      const CHIh = (Eh & Fh) ^ (~Eh & Gh);\n      const CHIl = (El & Fl) ^ (~El & Gl);\n      // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n      // prettier-ignore\n      const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n      const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n      const T1l = T1ll | 0;\n      // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n      const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);\n      const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);\n      const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);\n      const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);\n      Hh = Gh | 0;\n      Hl = Gl | 0;\n      Gh = Fh | 0;\n      Gl = Fl | 0;\n      Fh = Eh | 0;\n      Fl = El | 0;\n      ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n      Dh = Ch | 0;\n      Dl = Cl | 0;\n      Ch = Bh | 0;\n      Cl = Bl | 0;\n      Bh = Ah | 0;\n      Bl = Al | 0;\n      const All = u64.add3L(T1l, sigma0l, MAJl);\n      Ah = u64.add3H(All, T1h, sigma0h, MAJh);\n      Al = All | 0;\n    }\n    // Add the compressed chunk to the current hash value\n    ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n    ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n    ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n    ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n    ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n    ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n    ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n    ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n    this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n  }\n  protected roundClean(): void {\n    clean(SHA512_W_H, SHA512_W_L);\n  }\n  destroy(): void {\n    clean(this.buffer);\n    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n  }\n}\n\n/** Internal SHA2-512 hash class. */\nexport class _SHA512 extends SHA2_64B<_SHA512> {\n  protected Ah: number = SHA512_IV[0] | 0;\n  protected Al: number = SHA512_IV[1] | 0;\n  protected Bh: number = SHA512_IV[2] | 0;\n  protected Bl: number = SHA512_IV[3] | 0;\n  protected Ch: number = SHA512_IV[4] | 0;\n  protected Cl: number = SHA512_IV[5] | 0;\n  protected Dh: number = SHA512_IV[6] | 0;\n  protected Dl: number = SHA512_IV[7] | 0;\n  protected Eh: number = SHA512_IV[8] | 0;\n  protected El: number = SHA512_IV[9] | 0;\n  protected Fh: number = SHA512_IV[10] | 0;\n  protected Fl: number = SHA512_IV[11] | 0;\n  protected Gh: number = SHA512_IV[12] | 0;\n  protected Gl: number = SHA512_IV[13] | 0;\n  protected Hh: number = SHA512_IV[14] | 0;\n  protected Hl: number = SHA512_IV[15] | 0;\n\n  constructor() {\n    super(64);\n  }\n}\n\n/** Internal SHA2-384 hash class. */\nexport class _SHA384 extends SHA2_64B<_SHA384> {\n  protected Ah: number = SHA384_IV[0] | 0;\n  protected Al: number = SHA384_IV[1] | 0;\n  protected Bh: number = SHA384_IV[2] | 0;\n  protected Bl: number = SHA384_IV[3] | 0;\n  protected Ch: number = SHA384_IV[4] | 0;\n  protected Cl: number = SHA384_IV[5] | 0;\n  protected Dh: number = SHA384_IV[6] | 0;\n  protected Dl: number = SHA384_IV[7] | 0;\n  protected Eh: number = SHA384_IV[8] | 0;\n  protected El: number = SHA384_IV[9] | 0;\n  protected Fh: number = SHA384_IV[10] | 0;\n  protected Fl: number = SHA384_IV[11] | 0;\n  protected Gh: number = SHA384_IV[12] | 0;\n  protected Gl: number = SHA384_IV[13] | 0;\n  protected Hh: number = SHA384_IV[14] | 0;\n  protected Hl: number = SHA384_IV[15] | 0;\n\n  constructor() {\n    super(48);\n  }\n}\n\n/**\n * Truncated SHA512/256 and SHA512/224.\n * SHA512_IV is XORed with 0xa5a5a5a5a5a5a5a5, then used as \"intermediary\" IV of SHA512/t.\n * Then t hashes string to produce result IV.\n * See `test/misc/sha2-gen-iv.js`.\n */\n\n/** SHA512/224 IV */\nconst T224_IV = /* @__PURE__ */ Uint32Array.from([\n  0x8c3d37c8, 0x19544da2, 0x73e19966, 0x89dcd4d6, 0x1dfab7ae, 0x32ff9c82, 0x679dd514, 0x582f9fcf,\n  0x0f6d2b69, 0x7bd44da8, 0x77e36f73, 0x04c48942, 0x3f9d85a8, 0x6a1d36c8, 0x1112e6ad, 0x91d692a1,\n]);\n\n/** SHA512/256 IV */\nconst T256_IV = /* @__PURE__ */ Uint32Array.from([\n  0x22312194, 0xfc2bf72c, 0x9f555fa3, 0xc84c64c2, 0x2393b86b, 0x6f53b151, 0x96387719, 0x5940eabd,\n  0x96283ee2, 0xa88effe3, 0xbe5e1e25, 0x53863992, 0x2b0199fc, 0x2c85b8aa, 0x0eb72ddc, 0x81c52ca2,\n]);\n\n/** Internal SHA2-512/224 hash class. */\nexport class _SHA512_224 extends SHA2_64B<_SHA512_224> {\n  protected Ah: number = T224_IV[0] | 0;\n  protected Al: number = T224_IV[1] | 0;\n  protected Bh: number = T224_IV[2] | 0;\n  protected Bl: number = T224_IV[3] | 0;\n  protected Ch: number = T224_IV[4] | 0;\n  protected Cl: number = T224_IV[5] | 0;\n  protected Dh: number = T224_IV[6] | 0;\n  protected Dl: number = T224_IV[7] | 0;\n  protected Eh: number = T224_IV[8] | 0;\n  protected El: number = T224_IV[9] | 0;\n  protected Fh: number = T224_IV[10] | 0;\n  protected Fl: number = T224_IV[11] | 0;\n  protected Gh: number = T224_IV[12] | 0;\n  protected Gl: number = T224_IV[13] | 0;\n  protected Hh: number = T224_IV[14] | 0;\n  protected Hl: number = T224_IV[15] | 0;\n\n  constructor() {\n    super(28);\n  }\n}\n\n/** Internal SHA2-512/256 hash class. */\nexport class _SHA512_256 extends SHA2_64B<_SHA512_256> {\n  protected Ah: number = T256_IV[0] | 0;\n  protected Al: number = T256_IV[1] | 0;\n  protected Bh: number = T256_IV[2] | 0;\n  protected Bl: number = T256_IV[3] | 0;\n  protected Ch: number = T256_IV[4] | 0;\n  protected Cl: number = T256_IV[5] | 0;\n  protected Dh: number = T256_IV[6] | 0;\n  protected Dl: number = T256_IV[7] | 0;\n  protected Eh: number = T256_IV[8] | 0;\n  protected El: number = T256_IV[9] | 0;\n  protected Fh: number = T256_IV[10] | 0;\n  protected Fl: number = T256_IV[11] | 0;\n  protected Gh: number = T256_IV[12] | 0;\n  protected Gl: number = T256_IV[13] | 0;\n  protected Hh: number = T256_IV[14] | 0;\n  protected Hl: number = T256_IV[15] | 0;\n\n  constructor() {\n    super(32);\n  }\n}\n\n/**\n * SHA2-256 hash function from RFC 4634. In JS it's the fastest: even faster than Blake3. Some info:\n *\n * - Trying 2^128 hashes would get 50% chance of collision, using birthday attack.\n * - BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.\n * - Each sha256 hash is executing 2^18 bit operations.\n * - Good 2024 ASICs can do 200Th/sec with 3500 watts of power, corresponding to 2^36 hashes/joule.\n */\nexport const sha256: CHash<_SHA256> = /* @__PURE__ */ createHasher(\n  () => new _SHA256(),\n  /* @__PURE__ */ oidNist(0x01)\n);\n/** SHA2-224 hash function from RFC 4634 */\nexport const sha224: CHash<_SHA224> = /* @__PURE__ */ createHasher(\n  () => new _SHA224(),\n  /* @__PURE__ */ oidNist(0x04)\n);\n\n/** SHA2-512 hash function from RFC 4634. */\nexport const sha512: CHash<_SHA512> = /* @__PURE__ */ createHasher(\n  () => new _SHA512(),\n  /* @__PURE__ */ oidNist(0x03)\n);\n/** SHA2-384 hash function from RFC 4634. */\nexport const sha384: CHash<_SHA384> = /* @__PURE__ */ createHasher(\n  () => new _SHA384(),\n  /* @__PURE__ */ oidNist(0x02)\n);\n\n/**\n * SHA2-512/256 \"truncated\" hash function, with improved resistance to length extension attacks.\n * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).\n */\nexport const sha512_256: CHash<_SHA512_256> = /* @__PURE__ */ createHasher(\n  () => new _SHA512_256(),\n  /* @__PURE__ */ oidNist(0x06)\n);\n/**\n * SHA2-512/224 \"truncated\" hash function, with improved resistance to length extension attacks.\n * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).\n */\nexport const sha512_224: CHash<_SHA512_224> = /* @__PURE__ */ createHasher(\n  () => new _SHA512_224(),\n  /* @__PURE__ */ oidNist(0x05)\n);\n", "/**\n * Hex, bytes and number utilities.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport {\n  abytes as abytes_,\n  anumber,\n  bytesToHex as bytesToHex_,\n  concatBytes as concatBytes_,\n  hexToBytes as hexToBytes_,\n} from '@noble/hashes/utils.js';\nexport {\n  abytes,\n  anumber,\n  bytesToHex,\n  concatBytes,\n  hexToBytes,\n  isBytes,\n  randomBytes,\n} from '@noble/hashes/utils.js';\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\n\nexport type CHash = {\n  (message: Uint8Array): Uint8Array;\n  blockLen: number;\n  outputLen: number;\n  create(opts?: { dkLen?: number }): any; // For shake\n};\nexport type FHash = (message: Uint8Array) => Uint8Array;\nexport function abool(value: boolean, title: string = ''): boolean {\n  if (typeof value !== 'boolean') {\n    const prefix = title && `\"${title}\" `;\n    throw new Error(prefix + 'expected boolean, got type=' + typeof value);\n  }\n  return value;\n}\n\n// Used in weierstrass, der\nfunction abignumber(n: number | bigint) {\n  if (typeof n === 'bigint') {\n    if (!isPosBig(n)) throw new Error('positive bigint expected, got ' + n);\n  } else anumber(n);\n  return n;\n}\n\nexport function asafenumber(value: number, title: string = ''): void {\n  if (!Number.isSafeInteger(value)) {\n    const prefix = title && `\"${title}\" `;\n    throw new Error(prefix + 'expected safe integer, got type=' + typeof value);\n  }\n}\n\nexport function numberToHexUnpadded(num: number | bigint): string {\n  const hex = abignumber(num).toString(16);\n  return hex.length & 1 ? '0' + hex : hex;\n}\n\nexport function hexToNumber(hex: string): bigint {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  return hex === '' ? _0n : BigInt('0x' + hex); // Big Endian\n}\n\n// BE: Big Endian, LE: Little Endian\nexport function bytesToNumberBE(bytes: Uint8Array): bigint {\n  return hexToNumber(bytesToHex_(bytes));\n}\nexport function bytesToNumberLE(bytes: Uint8Array): bigint {\n  return hexToNumber(bytesToHex_(copyBytes(abytes_(bytes)).reverse()));\n}\n\nexport function numberToBytesBE(n: number | bigint, len: number): Uint8Array {\n  anumber(len);\n  n = abignumber(n);\n  const res = hexToBytes_(n.toString(16).padStart(len * 2, '0'));\n  if (res.length !== len) throw new Error('number too large');\n  return res;\n}\nexport function numberToBytesLE(n: number | bigint, len: number): Uint8Array {\n  return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nexport function numberToVarBytesBE(n: number | bigint): Uint8Array {\n  return hexToBytes_(numberToHexUnpadded(abignumber(n)));\n}\n\n// Compares 2 u8a-s in kinda constant time\nexport function equalBytes(a: Uint8Array, b: Uint8Array): boolean {\n  if (a.length !== b.length) return false;\n  let diff = 0;\n  for (let i = 0; i < a.length; i++) diff |= a[i] ^ b[i];\n  return diff === 0;\n}\n\n/**\n * Copies Uint8Array. We can't use u8a.slice(), because u8a can be Buffer,\n * and Buffer#slice creates mutable copy. Never use Buffers!\n */\nexport function copyBytes(bytes: Uint8Array): Uint8Array {\n  return Uint8Array.from(bytes);\n}\n\n/**\n * Decodes 7-bit ASCII string to Uint8Array, throws on non-ascii symbols\n * Should be safe to use for things expected to be ASCII.\n * Returns exact same result as `TextEncoder` for ASCII or throws.\n */\nexport function asciiToBytes(ascii: string): Uint8Array {\n  return Uint8Array.from(ascii, (c, i) => {\n    const charCode = c.charCodeAt(0);\n    if (c.length !== 1 || charCode > 127) {\n      throw new Error(\n        `string contains non-ASCII character \"${ascii[i]}\" with code ${charCode} at position ${i}`\n      );\n    }\n    return charCode;\n  });\n}\n\n// Is positive bigint\nconst isPosBig = (n: bigint) => typeof n === 'bigint' && _0n <= n;\n\nexport function inRange(n: bigint, min: bigint, max: bigint): boolean {\n  return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;\n}\n\n/**\n * Asserts min <= n < max. NOTE: It's < max and not <= max.\n * @example\n * aInRange('x', x, 1n, 256n); // would assume x is in (1n..255n)\n */\nexport function aInRange(title: string, n: bigint, min: bigint, max: bigint): void {\n  // Why min <= n < max and not a (min < n < max) OR b (min <= n <= max)?\n  // consider P=256n, min=0n, max=P\n  // - a for min=0 would require -1:          `inRange('x', x, -1n, P)`\n  // - b would commonly require subtraction:  `inRange('x', x, 0n, P - 1n)`\n  // - our way is the cleanest:               `inRange('x', x, 0n, P)\n  if (!inRange(n, min, max))\n    throw new Error('expected valid ' + title + ': ' + min + ' <= n < ' + max + ', got ' + n);\n}\n\n// Bit operations\n\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n * TODO: merge with nLength in modular\n */\nexport function bitLen(n: bigint): number {\n  let len;\n  for (len = 0; n > _0n; n >>= _1n, len += 1);\n  return len;\n}\n\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */\nexport function bitGet(n: bigint, pos: number): bigint {\n  return (n >> BigInt(pos)) & _1n;\n}\n\n/**\n * Sets single bit at position.\n */\nexport function bitSet(n: bigint, pos: number, value: boolean): bigint {\n  return n | ((value ? _1n : _0n) << BigInt(pos));\n}\n\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */\nexport const bitMask = (n: number): bigint => (_1n << BigInt(n)) - _1n;\n\n// DRBG\n\ntype Pred<T> = (v: Uint8Array) => T | undefined;\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nexport function createHmacDrbg<T>(\n  hashLen: number,\n  qByteLen: number,\n  hmacFn: (key: Uint8Array, message: Uint8Array) => Uint8Array\n): (seed: Uint8Array, predicate: Pred<T>) => T {\n  anumber(hashLen, 'hashLen');\n  anumber(qByteLen, 'qByteLen');\n  if (typeof hmacFn !== 'function') throw new Error('hmacFn must be a function');\n  const u8n = (len: number): Uint8Array => new Uint8Array(len); // creates Uint8Array\n  const NULL = Uint8Array.of();\n  const byte0 = Uint8Array.of(0x00);\n  const byte1 = Uint8Array.of(0x01);\n  const _maxDrbgIters = 1000;\n\n  // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n  let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n  let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n  let i = 0; // Iterations counter, will throw when over 1000\n  const reset = () => {\n    v.fill(1);\n    k.fill(0);\n    i = 0;\n  };\n  const h = (...msgs: Uint8Array[]) => hmacFn(k, concatBytes_(v, ...msgs)); // hmac(k)(v, ...values)\n  const reseed = (seed: Uint8Array = NULL) => {\n    // HMAC-DRBG reseed() function. Steps D-G\n    k = h(byte0, seed); // k = hmac(k || v || 0x00 || seed)\n    v = h(); // v = hmac(k || v)\n    if (seed.length === 0) return;\n    k = h(byte1, seed); // k = hmac(k || v || 0x01 || seed)\n    v = h(); // v = hmac(k || v)\n  };\n  const gen = () => {\n    // HMAC-DRBG generate() function\n    if (i++ >= _maxDrbgIters) throw new Error('drbg: tried max amount of iterations');\n    let len = 0;\n    const out: Uint8Array[] = [];\n    while (len < qByteLen) {\n      v = h();\n      const sl = v.slice();\n      out.push(sl);\n      len += v.length;\n    }\n    return concatBytes_(...out);\n  };\n  const genUntil = (seed: Uint8Array, pred: Pred<T>): T => {\n    reset();\n    reseed(seed); // Steps D-G\n    let res: T | undefined = undefined; // Step H: grind until k is in [1..n-1]\n    while (!(res = pred(gen()))) reseed();\n    reset();\n    return res;\n  };\n  return genUntil;\n}\n\nexport function validateObject(\n  object: Record<string, any>,\n  fields: Record<string, string> = {},\n  optFields: Record<string, string> = {}\n): void {\n  if (!object || typeof object !== 'object') throw new Error('expected valid options object');\n  type Item = keyof typeof object;\n  function checkField(fieldName: Item, expectedType: string, isOpt: boolean) {\n    const val = object[fieldName];\n    if (isOpt && val === undefined) return;\n    const current = typeof val;\n    if (current !== expectedType || val === null)\n      throw new Error(`param \"${fieldName}\" is invalid: expected ${expectedType}, got ${current}`);\n  }\n  const iter = (f: typeof fields, isOpt: boolean) =>\n    Object.entries(f).forEach(([k, v]) => checkField(k, v, isOpt));\n  iter(fields, false);\n  iter(optFields, true);\n}\n\n/**\n * throws not implemented error\n */\nexport const notImplemented = (): never => {\n  throw new Error('not implemented');\n};\n\n/**\n * Memoizes (caches) computation result.\n * Uses WeakMap: the value is going auto-cleaned by GC after last reference is removed.\n */\nexport function memoized<T extends object, R, O extends any[]>(\n  fn: (arg: T, ...args: O) => R\n): (arg: T, ...args: O) => R {\n  const map = new WeakMap<T, R>();\n  return (arg: T, ...args: O): R => {\n    const val = map.get(arg);\n    if (val !== undefined) return val;\n    const computed = fn(arg, ...args);\n    map.set(arg, computed);\n    return computed;\n  };\n}\n\nexport interface CryptoKeys {\n  lengths: { seed?: number; public?: number; secret?: number };\n  keygen: (seed?: Uint8Array) => { secretKey: Uint8Array; publicKey: Uint8Array };\n  getPublicKey: (secretKey: Uint8Array) => Uint8Array;\n}\n\n/** Generic interface for signatures. Has keygen, sign and verify. */\nexport interface Signer extends CryptoKeys {\n  // Interfaces are fun. We cannot just add new fields without copying old ones.\n  lengths: {\n    seed?: number;\n    public?: number;\n    secret?: number;\n    signRand?: number;\n    signature?: number;\n  };\n  sign: (msg: Uint8Array, secretKey: Uint8Array) => Uint8Array;\n  verify: (sig: Uint8Array, msg: Uint8Array, publicKey: Uint8Array) => boolean;\n}\n", "/**\n * Utils for modular division and fields.\n * Field over 11 is a finite (Galois) field is integer number operations `mod 11`.\n * There is no division: it is replaced by modular multiplicative inverse.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport {\n  abytes,\n  anumber,\n  bytesToNumberBE,\n  bytesToNumberLE,\n  numberToBytesBE,\n  numberToBytesLE,\n  validateObject,\n} from '../utils.ts';\n\n// Numbers aren't used in x25519 / x448 builds\n// prettier-ignore\nconst _0n = /* @__PURE__ */ BigInt(0), _1n = /* @__PURE__ */ BigInt(1), _2n = /* @__PURE__ */ BigInt(2);\n// prettier-ignore\nconst _3n = /* @__PURE__ */ BigInt(3), _4n = /* @__PURE__ */ BigInt(4), _5n = /* @__PURE__ */ BigInt(5);\n// prettier-ignore\nconst _7n = /* @__PURE__ */ BigInt(7), _8n = /* @__PURE__ */ BigInt(8), _9n = /* @__PURE__ */ BigInt(9);\nconst _16n = /* @__PURE__ */ BigInt(16);\n\n// Calculates a modulo b\nexport function mod(a: bigint, b: bigint): bigint {\n  const result = a % b;\n  return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */\nexport function pow(num: bigint, power: bigint, modulo: bigint): bigint {\n  return FpPow(Field(modulo), num, power);\n}\n\n/** Does `x^(2^power)` mod p. `pow2(30, 4)` == `30^(2^4)` */\nexport function pow2(x: bigint, power: bigint, modulo: bigint): bigint {\n  let res = x;\n  while (power-- > _0n) {\n    res *= res;\n    res %= modulo;\n  }\n  return res;\n}\n\n/**\n * Inverses number over modulo.\n * Implemented using [Euclidean GCD](https://brilliant.org/wiki/extended-euclidean-algorithm/).\n */\nexport function invert(number: bigint, modulo: bigint): bigint {\n  if (number === _0n) throw new Error('invert: expected non-zero number');\n  if (modulo <= _0n) throw new Error('invert: expected positive modulus, got ' + modulo);\n  // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n  let a = mod(number, modulo);\n  let b = modulo;\n  // prettier-ignore\n  let x = _0n, y = _1n, u = _1n, v = _0n;\n  while (a !== _0n) {\n    // JIT applies optimization if those two lines follow each other\n    const q = b / a;\n    const r = b % a;\n    const m = x - u * q;\n    const n = y - v * q;\n    // prettier-ignore\n    b = a, a = r, x = u, y = v, u = m, v = n;\n  }\n  const gcd = b;\n  if (gcd !== _1n) throw new Error('invert: does not exist');\n  return mod(x, modulo);\n}\n\nfunction assertIsSquare<T>(Fp: IField<T>, root: T, n: T): void {\n  if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');\n}\n\n// Not all roots are possible! Example which will throw:\n// const NUM =\n// n = 72057594037927816n;\n// Fp = Field(BigInt('0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab'));\nfunction sqrt3mod4<T>(Fp: IField<T>, n: T) {\n  const p1div4 = (Fp.ORDER + _1n) / _4n;\n  const root = Fp.pow(n, p1div4);\n  assertIsSquare(Fp, root, n);\n  return root;\n}\n\nfunction sqrt5mod8<T>(Fp: IField<T>, n: T) {\n  const p5div8 = (Fp.ORDER - _5n) / _8n;\n  const n2 = Fp.mul(n, _2n);\n  const v = Fp.pow(n2, p5div8);\n  const nv = Fp.mul(n, v);\n  const i = Fp.mul(Fp.mul(nv, _2n), v);\n  const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n  assertIsSquare(Fp, root, n);\n  return root;\n}\n\n// Based on RFC9380, Kong algorithm\n// prettier-ignore\nfunction sqrt9mod16(P: bigint): <T>(Fp: IField<T>, n: T) => T {\n  const Fp_ = Field(P);\n  const tn = tonelliShanks(P);\n  const c1 = tn(Fp_, Fp_.neg(Fp_.ONE));//  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n  const c2 = tn(Fp_, c1);              //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n  const c3 = tn(Fp_, Fp_.neg(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n  const c4 = (P + _7n) / _16n;         //  4. c4 = (q + 7) / 16        # Integer arithmetic\n  return <T>(Fp: IField<T>, n: T) => {\n    let tv1 = Fp.pow(n, c4);           //  1. tv1 = x^c4\n    let tv2 = Fp.mul(tv1, c1);         //  2. tv2 = c1 * tv1\n    const tv3 = Fp.mul(tv1, c2);       //  3. tv3 = c2 * tv1\n    const tv4 = Fp.mul(tv1, c3);       //  4. tv4 = c3 * tv1\n    const e1 = Fp.eql(Fp.sqr(tv2), n); //  5.  e1 = (tv2^2) == x\n    const e2 = Fp.eql(Fp.sqr(tv3), n); //  6.  e2 = (tv3^2) == x\n    tv1 = Fp.cmov(tv1, tv2, e1);       //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n    tv2 = Fp.cmov(tv4, tv3, e2);       //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n    const e3 = Fp.eql(Fp.sqr(tv2), n); //  9.  e3 = (tv2^2) == x\n    const root = Fp.cmov(tv1, tv2, e3);// 10.  z = CMOV(tv1, tv2, e3)   # Select sqrt from tv1 & tv2\n    assertIsSquare(Fp, root, n);\n    return root;\n  };\n}\n\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */\nexport function tonelliShanks(P: bigint): <T>(Fp: IField<T>, n: T) => T {\n  // Initialization (precomputation).\n  // Caching initialization could boost perf by 7%.\n  if (P < _3n) throw new Error('sqrt is not defined for small field');\n  // Factor P - 1 = Q * 2^S, where Q is odd\n  let Q = P - _1n;\n  let S = 0;\n  while (Q % _2n === _0n) {\n    Q /= _2n;\n    S++;\n  }\n\n  // Find the first quadratic non-residue Z >= 2\n  let Z = _2n;\n  const _Fp = Field(P);\n  while (FpLegendre(_Fp, Z) === 1) {\n    // Basic primality test for P. After x iterations, chance of\n    // not finding quadratic non-residue is 2^x, so 2^1000.\n    if (Z++ > 1000) throw new Error('Cannot find square root: probably non-prime P');\n  }\n  // Fast-path; usually done before Z, but we do \"primality test\".\n  if (S === 1) return sqrt3mod4;\n\n  // Slow-path\n  // TODO: test on Fp2 and others\n  let cc = _Fp.pow(Z, Q); // c = z^Q\n  const Q1div2 = (Q + _1n) / _2n;\n  return function tonelliSlow<T>(Fp: IField<T>, n: T): T {\n    if (Fp.is0(n)) return n;\n    // Check if n is a quadratic residue using Legendre symbol\n    if (FpLegendre(Fp, n) !== 1) throw new Error('Cannot find square root');\n\n    // Initialize variables for the main loop\n    let M = S;\n    let c = Fp.mul(Fp.ONE, cc); // c = z^Q, move cc from field _Fp into field Fp\n    let t = Fp.pow(n, Q); // t = n^Q, first guess at the fudge factor\n    let R = Fp.pow(n, Q1div2); // R = n^((Q+1)/2), first guess at the square root\n\n    // Main loop\n    // while t != 1\n    while (!Fp.eql(t, Fp.ONE)) {\n      if (Fp.is0(t)) return Fp.ZERO; // if t=0 return R=0\n      let i = 1;\n\n      // Find the smallest i >= 1 such that t^(2^i) \u2261 1 (mod P)\n      let t_tmp = Fp.sqr(t); // t^(2^1)\n      while (!Fp.eql(t_tmp, Fp.ONE)) {\n        i++;\n        t_tmp = Fp.sqr(t_tmp); // t^(2^2)...\n        if (i === M) throw new Error('Cannot find square root');\n      }\n\n      // Calculate the exponent for b: 2^(M - i - 1)\n      const exponent = _1n << BigInt(M - i - 1); // bigint is important\n      const b = Fp.pow(c, exponent); // b = 2^(M - i - 1)\n\n      // Update variables\n      M = i;\n      c = Fp.sqr(b); // c = b^2\n      t = Fp.mul(t, c); // t = (t * b^2)\n      R = Fp.mul(R, b); // R = R*b\n    }\n    return R;\n  };\n}\n\n/**\n * Square root for a finite field. Will try optimized versions first:\n *\n * 1. P \u2261 3 (mod 4)\n * 2. P \u2261 5 (mod 8)\n * 3. P \u2261 9 (mod 16)\n * 4. Tonelli-Shanks algorithm\n *\n * Different algorithms can give different roots, it is up to user to decide which one they want.\n * For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n */\nexport function FpSqrt(P: bigint): <T>(Fp: IField<T>, n: T) => T {\n  // P \u2261 3 (mod 4) => \u221An = n^((P+1)/4)\n  if (P % _4n === _3n) return sqrt3mod4;\n  // P \u2261 5 (mod 8) => Atkin algorithm, page 10 of https://eprint.iacr.org/2012/685.pdf\n  if (P % _8n === _5n) return sqrt5mod8;\n  // P \u2261 9 (mod 16) => Kong algorithm, page 11 of https://eprint.iacr.org/2012/685.pdf (algorithm 4)\n  if (P % _16n === _9n) return sqrt9mod16(P);\n  // Tonelli-Shanks algorithm\n  return tonelliShanks(P);\n}\n\n// Little-endian check for first LE bit (last BE bit);\nexport const isNegativeLE = (num: bigint, modulo: bigint): boolean =>\n  (mod(num, modulo) & _1n) === _1n;\n\n/** Field is not always over prime: for example, Fp2 has ORDER(q)=p^m. */\nexport interface IField<T> {\n  ORDER: bigint;\n  BYTES: number;\n  BITS: number;\n  isLE: boolean;\n  ZERO: T;\n  ONE: T;\n  // 1-arg\n  create: (num: T) => T;\n  isValid: (num: T) => boolean;\n  is0: (num: T) => boolean;\n  isValidNot0: (num: T) => boolean;\n  neg(num: T): T;\n  inv(num: T): T;\n  sqrt(num: T): T;\n  sqr(num: T): T;\n  // 2-args\n  eql(lhs: T, rhs: T): boolean;\n  add(lhs: T, rhs: T): T;\n  sub(lhs: T, rhs: T): T;\n  mul(lhs: T, rhs: T | bigint): T;\n  pow(lhs: T, power: bigint): T;\n  div(lhs: T, rhs: T | bigint): T;\n  // N for NonNormalized (for now)\n  addN(lhs: T, rhs: T): T;\n  subN(lhs: T, rhs: T): T;\n  mulN(lhs: T, rhs: T | bigint): T;\n  sqrN(num: T): T;\n\n  // Optional\n  // Should be same as sgn0 function in\n  // [RFC9380](https://www.rfc-editor.org/rfc/rfc9380#section-4.1).\n  // NOTE: sgn0 is 'negative in LE', which is same as odd. And negative in LE is kinda strange definition anyway.\n  isOdd?(num: T): boolean; // Odd instead of even since we have it for Fp2\n  // legendre?(num: T): T;\n  invertBatch: (lst: T[]) => T[];\n  toBytes(num: T): Uint8Array;\n  fromBytes(bytes: Uint8Array, skipValidation?: boolean): T;\n  // If c is False, CMOV returns a, otherwise it returns b.\n  cmov(a: T, b: T, c: boolean): T;\n}\n// prettier-ignore\nconst FIELD_FIELDS = [\n  'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',\n  'eql', 'add', 'sub', 'mul', 'pow', 'div',\n  'addN', 'subN', 'mulN', 'sqrN'\n] as const;\nexport function validateField<T>(field: IField<T>): IField<T> {\n  const initial = {\n    ORDER: 'bigint',\n    BYTES: 'number',\n    BITS: 'number',\n  } as Record<string, string>;\n  const opts = FIELD_FIELDS.reduce((map, val: string) => {\n    map[val] = 'function';\n    return map;\n  }, initial);\n  validateObject(field, opts);\n  // const max = 16384;\n  // if (field.BYTES < 1 || field.BYTES > max) throw new Error('invalid field');\n  // if (field.BITS < 1 || field.BITS > 8 * max) throw new Error('invalid field');\n  return field;\n}\n\n// Generic field functions\n\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */\nexport function FpPow<T>(Fp: IField<T>, num: T, power: bigint): T {\n  if (power < _0n) throw new Error('invalid exponent, negatives unsupported');\n  if (power === _0n) return Fp.ONE;\n  if (power === _1n) return num;\n  let p = Fp.ONE;\n  let d = num;\n  while (power > _0n) {\n    if (power & _1n) p = Fp.mul(p, d);\n    d = Fp.sqr(d);\n    power >>= _1n;\n  }\n  return p;\n}\n\n/**\n * Efficiently invert an array of Field elements.\n * Exception-free. Will return `undefined` for 0 elements.\n * @param passZero map 0 to 0 (instead of undefined)\n */\nexport function FpInvertBatch<T>(Fp: IField<T>, nums: T[], passZero = false): T[] {\n  const inverted = new Array(nums.length).fill(passZero ? Fp.ZERO : undefined);\n  // Walk from first to last, multiply them by each other MOD p\n  const multipliedAcc = nums.reduce((acc, num, i) => {\n    if (Fp.is0(num)) return acc;\n    inverted[i] = acc;\n    return Fp.mul(acc, num);\n  }, Fp.ONE);\n  // Invert last element\n  const invertedAcc = Fp.inv(multipliedAcc);\n  // Walk from last to first, multiply them by inverted each other MOD p\n  nums.reduceRight((acc, num, i) => {\n    if (Fp.is0(num)) return acc;\n    inverted[i] = Fp.mul(acc, inverted[i]);\n    return Fp.mul(acc, num);\n  }, invertedAcc);\n  return inverted;\n}\n\n// TODO: remove\nexport function FpDiv<T>(Fp: IField<T>, lhs: T, rhs: T | bigint): T {\n  return Fp.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, Fp.ORDER) : Fp.inv(rhs));\n}\n\n/**\n * Legendre symbol.\n * Legendre constant is used to calculate Legendre symbol (a | p)\n * which denotes the value of a^((p-1)/2) (mod p).\n *\n * * (a | p) \u2261 1    if a is a square (mod p), quadratic residue\n * * (a | p) \u2261 -1   if a is not a square (mod p), quadratic non residue\n * * (a | p) \u2261 0    if a \u2261 0 (mod p)\n */\nexport function FpLegendre<T>(Fp: IField<T>, n: T): -1 | 0 | 1 {\n  // We can use 3rd argument as optional cache of this value\n  // but seems unneeded for now. The operation is very fast.\n  const p1mod2 = (Fp.ORDER - _1n) / _2n;\n  const powered = Fp.pow(n, p1mod2);\n  const yes = Fp.eql(powered, Fp.ONE);\n  const zero = Fp.eql(powered, Fp.ZERO);\n  const no = Fp.eql(powered, Fp.neg(Fp.ONE));\n  if (!yes && !zero && !no) throw new Error('invalid Legendre symbol result');\n  return yes ? 1 : zero ? 0 : -1;\n}\n\n// This function returns True whenever the value x is a square in the field F.\nexport function FpIsSquare<T>(Fp: IField<T>, n: T): boolean {\n  const l = FpLegendre(Fp, n);\n  return l === 1;\n}\n\nexport type NLength = { nByteLength: number; nBitLength: number };\n// CURVE.n lengths\nexport function nLength(n: bigint, nBitLength?: number): NLength {\n  // Bit size, byte size of CURVE.n\n  if (nBitLength !== undefined) anumber(nBitLength);\n  const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n  const nByteLength = Math.ceil(_nBitLength / 8);\n  return { nBitLength: _nBitLength, nByteLength };\n}\n\ntype FpField = IField<bigint> & Required<Pick<IField<bigint>, 'isOdd'>>;\ntype SqrtFn = (n: bigint) => bigint;\ntype FieldOpts = Partial<{\n  isLE: boolean;\n  BITS: number;\n  sqrt: SqrtFn;\n  allowedLengths?: readonly number[]; // for P521 (adds padding for smaller sizes)\n  modFromBytes: boolean; // bls12-381 requires mod(n) instead of rejecting keys >= n\n}>;\nclass _Field implements IField<bigint> {\n  readonly ORDER: bigint;\n  readonly BITS: number;\n  readonly BYTES: number;\n  readonly isLE: boolean;\n  readonly ZERO = _0n;\n  readonly ONE = _1n;\n  readonly _lengths?: number[];\n  private _sqrt: ReturnType<typeof FpSqrt> | undefined; // cached sqrt\n  private readonly _mod?: boolean;\n  constructor(ORDER: bigint, opts: FieldOpts = {}) {\n    if (ORDER <= _0n) throw new Error('invalid field: expected ORDER > 0, got ' + ORDER);\n    let _nbitLength: number | undefined = undefined;\n    this.isLE = false;\n    if (opts != null && typeof opts === 'object') {\n      if (typeof opts.BITS === 'number') _nbitLength = opts.BITS;\n      if (typeof opts.sqrt === 'function') this.sqrt = opts.sqrt;\n      if (typeof opts.isLE === 'boolean') this.isLE = opts.isLE;\n      if (opts.allowedLengths) this._lengths = opts.allowedLengths?.slice();\n      if (typeof opts.modFromBytes === 'boolean') this._mod = opts.modFromBytes;\n    }\n    const { nBitLength, nByteLength } = nLength(ORDER, _nbitLength);\n    if (nByteLength > 2048) throw new Error('invalid field: expected ORDER of <= 2048 bytes');\n    this.ORDER = ORDER;\n    this.BITS = nBitLength;\n    this.BYTES = nByteLength;\n    this._sqrt = undefined;\n    Object.preventExtensions(this);\n  }\n\n  create(num: bigint) {\n    return mod(num, this.ORDER);\n  }\n  isValid(num: bigint) {\n    if (typeof num !== 'bigint')\n      throw new Error('invalid field element: expected bigint, got ' + typeof num);\n    return _0n <= num && num < this.ORDER; // 0 is valid element, but it's not invertible\n  }\n  is0(num: bigint) {\n    return num === _0n;\n  }\n  // is valid and invertible\n  isValidNot0(num: bigint) {\n    return !this.is0(num) && this.isValid(num);\n  }\n  isOdd(num: bigint) {\n    return (num & _1n) === _1n;\n  }\n  neg(num: bigint) {\n    return mod(-num, this.ORDER);\n  }\n  eql(lhs: bigint, rhs: bigint) {\n    return lhs === rhs;\n  }\n\n  sqr(num: bigint) {\n    return mod(num * num, this.ORDER);\n  }\n  add(lhs: bigint, rhs: bigint) {\n    return mod(lhs + rhs, this.ORDER);\n  }\n  sub(lhs: bigint, rhs: bigint) {\n    return mod(lhs - rhs, this.ORDER);\n  }\n  mul(lhs: bigint, rhs: bigint) {\n    return mod(lhs * rhs, this.ORDER);\n  }\n  pow(num: bigint, power: bigint): bigint {\n    return FpPow(this, num, power);\n  }\n  div(lhs: bigint, rhs: bigint) {\n    return mod(lhs * invert(rhs, this.ORDER), this.ORDER);\n  }\n\n  // Same as above, but doesn't normalize\n  sqrN(num: bigint) {\n    return num * num;\n  }\n  addN(lhs: bigint, rhs: bigint) {\n    return lhs + rhs;\n  }\n  subN(lhs: bigint, rhs: bigint) {\n    return lhs - rhs;\n  }\n  mulN(lhs: bigint, rhs: bigint) {\n    return lhs * rhs;\n  }\n\n  inv(num: bigint) {\n    return invert(num, this.ORDER);\n  }\n  sqrt(num: bigint): bigint {\n    // Caching _sqrt speeds up sqrt9mod16 by 5x and tonneli-shanks by 10%\n    if (!this._sqrt) this._sqrt = FpSqrt(this.ORDER);\n    return this._sqrt(this, num);\n  }\n  toBytes(num: bigint) {\n    return this.isLE ? numberToBytesLE(num, this.BYTES) : numberToBytesBE(num, this.BYTES);\n  }\n  fromBytes(bytes: Uint8Array, skipValidation = false) {\n    abytes(bytes);\n    const { _lengths: allowedLengths, BYTES, isLE, ORDER, _mod: modFromBytes } = this;\n    if (allowedLengths) {\n      if (!allowedLengths.includes(bytes.length) || bytes.length > BYTES) {\n        throw new Error(\n          'Field.fromBytes: expected ' + allowedLengths + ' bytes, got ' + bytes.length\n        );\n      }\n      const padded = new Uint8Array(BYTES);\n      // isLE add 0 to right, !isLE to the left.\n      padded.set(bytes, isLE ? 0 : padded.length - bytes.length);\n      bytes = padded;\n    }\n    if (bytes.length !== BYTES)\n      throw new Error('Field.fromBytes: expected ' + BYTES + ' bytes, got ' + bytes.length);\n    let scalar = isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);\n    if (modFromBytes) scalar = mod(scalar, ORDER);\n    if (!skipValidation)\n      if (!this.isValid(scalar))\n        throw new Error('invalid field element: outside of range 0..ORDER');\n    // NOTE: we don't validate scalar here, please use isValid. This done such way because some\n    // protocol may allow non-reduced scalar that reduced later or changed some other way.\n    return scalar;\n  }\n  // TODO: we don't need it here, move out to separate fn\n  invertBatch(lst: bigint[]): bigint[] {\n    return FpInvertBatch(this, lst);\n  }\n  // We can't move this out because Fp6, Fp12 implement it\n  // and it's unclear what to return in there.\n  cmov(a: bigint, b: bigint, condition: boolean) {\n    return condition ? b : a;\n  }\n}\n\n/**\n * Creates a finite field. Major performance optimizations:\n * * 1. Denormalized operations like mulN instead of mul.\n * * 2. Identical object shape: never add or remove keys.\n * * 3. `Object.freeze`.\n * Fragile: always run a benchmark on a change.\n * Security note: operations don't check 'isValid' for all elements for performance reasons,\n * it is caller responsibility to check this.\n * This is low-level code, please make sure you know what you're doing.\n *\n * Note about field properties:\n * * CHARACTERISTIC p = prime number, number of elements in main subgroup.\n * * ORDER q = similar to cofactor in curves, may be composite `q = p^m`.\n *\n * @param ORDER field order, probably prime, or could be composite\n * @param bitLen how many bits the field consumes\n * @param isLE (default: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */\nexport function Field(ORDER: bigint, opts: FieldOpts = {}): Readonly<FpField> {\n  return new _Field(ORDER, opts);\n}\n\n// Generic random scalar, we can do same for other fields if via Fp2.mul(Fp2.ONE, Fp2.random)?\n// This allows unsafe methods like ignore bias or zero. These unsafe, but often used in different protocols (if deterministic RNG).\n// which mean we cannot force this via opts.\n// Not sure what to do with randomBytes, we can accept it inside opts if wanted.\n// Probably need to export getMinHashLength somewhere?\n// random(bytes?: Uint8Array, unsafeAllowZero = false, unsafeAllowBias = false) {\n//   const LEN = !unsafeAllowBias ? getMinHashLength(ORDER) : BYTES;\n//   if (bytes === undefined) bytes = randomBytes(LEN); // _opts.randomBytes?\n//   const num = isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);\n//   // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n//   const reduced = unsafeAllowZero ? mod(num, ORDER) : mod(num, ORDER - _1n) + _1n;\n//   return reduced;\n// },\n\nexport function FpSqrtOdd<T>(Fp: IField<T>, elm: T): T {\n  if (!Fp.isOdd) throw new Error(\"Field doesn't have isOdd\");\n  const root = Fp.sqrt(elm);\n  return Fp.isOdd(root) ? root : Fp.neg(root);\n}\n\nexport function FpSqrtEven<T>(Fp: IField<T>, elm: T): T {\n  if (!Fp.isOdd) throw new Error(\"Field doesn't have isOdd\");\n  const root = Fp.sqrt(elm);\n  return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */\nexport function getFieldBytesLength(fieldOrder: bigint): number {\n  if (typeof fieldOrder !== 'bigint') throw new Error('field order must be bigint');\n  const bitLength = fieldOrder.toString(2).length;\n  return Math.ceil(bitLength / 8);\n}\n\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */\nexport function getMinHashLength(fieldOrder: bigint): number {\n  const length = getFieldBytesLength(fieldOrder);\n  return length + Math.ceil(length / 2);\n}\n\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.Point.Fn.ORDER)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */\nexport function mapHashToField(key: Uint8Array, fieldOrder: bigint, isLE = false): Uint8Array {\n  abytes(key);\n  const len = key.length;\n  const fieldLen = getFieldBytesLength(fieldOrder);\n  const minLen = getMinHashLength(fieldOrder);\n  // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n  if (len < 16 || len < minLen || len > 1024)\n    throw new Error('expected ' + minLen + '-1024 bytes of input, got ' + len);\n  const num = isLE ? bytesToNumberLE(key) : bytesToNumberBE(key);\n  // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n  const reduced = mod(num, fieldOrder - _1n) + _1n;\n  return isLE ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);\n}\n", "/**\n * Methods for elliptic curve multiplication by scalars.\n * Contains wNAF, pippenger.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { bitLen, bitMask, type Signer } from '../utils.ts';\nimport { Field, FpInvertBatch, validateField, type IField } from './modular.ts';\n\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\n\nexport type AffinePoint<T> = {\n  x: T;\n  y: T;\n} & { Z?: never };\n\n// We can't \"abstract out\" coordinates (X, Y, Z; and T in Edwards): argument names of constructor\n// are not accessible. See Typescript gh-56093, gh-41594.\n//\n// We have to use recursive types, so it will return actual point, not constained `CurvePoint`.\n// If, at any point, P is `any`, it will erase all types and replace it\n// with `any`, because of recursion, `any implements CurvePoint`,\n// but we lose all constrains on methods.\n\n/** Base interface for all elliptic curve Points. */\nexport interface CurvePoint<F, P extends CurvePoint<F, P>> {\n  /** Affine x coordinate. Different from projective / extended X coordinate. */\n  x: F;\n  /** Affine y coordinate. Different from projective / extended Y coordinate. */\n  y: F;\n  Z?: F;\n  double(): P;\n  negate(): P;\n  add(other: P): P;\n  subtract(other: P): P;\n  equals(other: P): boolean;\n  multiply(scalar: bigint): P;\n  assertValidity(): void;\n  clearCofactor(): P;\n  is0(): boolean;\n  isTorsionFree(): boolean;\n  isSmallOrder(): boolean;\n  multiplyUnsafe(scalar: bigint): P;\n  /**\n   * Massively speeds up `p.multiply(n)` by using precompute tables (caching). See {@link wNAF}.\n   * @param isLazy calculate cache now. Default (true) ensures it's deferred to first `multiply()`\n   */\n  precompute(windowSize?: number, isLazy?: boolean): P;\n  /** Converts point to 2D xy affine coordinates */\n  toAffine(invertedZ?: F): AffinePoint<F>;\n  toBytes(): Uint8Array;\n  toHex(): string;\n}\n\n/** Base interface for all elliptic curve Point constructors. */\nexport interface CurvePointCons<P extends CurvePoint<any, P>> {\n  [Symbol.hasInstance]: (item: unknown) => boolean;\n  BASE: P;\n  ZERO: P;\n  /** Field for basic curve math */\n  Fp: IField<P_F<P>>;\n  /** Scalar field, for scalars in multiply and others */\n  Fn: IField<bigint>;\n  /** Creates point from x, y. Does NOT validate if the point is valid. Use `.assertValidity()`. */\n  fromAffine(p: AffinePoint<P_F<P>>): P;\n  fromBytes(bytes: Uint8Array): P;\n  fromHex(hex: string): P;\n}\n\n// Type inference helpers: PC - PointConstructor, P - Point, Fp - Field element\n// Short names, because we use them a lot in result types:\n// * we can't do 'P = GetCurvePoint<PC>': this is default value and doesn't constrain anything\n// * we can't do 'type X = GetCurvePoint<PC>': it won't be accesible for arguments/return types\n// * `CurvePointCons<P extends CurvePoint<any, P>>` constraints from interface definition\n//   won't propagate, if `PC extends CurvePointCons<any>`: the P would be 'any', which is incorrect\n// * PC could be super specific with super specific P, which implements CurvePoint<any, P>.\n//   this means we need to do stuff like\n//   `function test<P extends CurvePoint<any, P>, PC extends CurvePointCons<P>>(`\n//   if we want type safety around P, otherwise PC_P<PC> will be any\n\n/** Returns Fp type from Point (P_F<P> == P.F) */\nexport type P_F<P extends CurvePoint<any, P>> = P extends CurvePoint<infer F, P> ? F : never;\n/** Returns Fp type from PointCons (PC_F<PC> == PC.P.F) */\nexport type PC_F<PC extends CurvePointCons<CurvePoint<any, any>>> = PC['Fp']['ZERO'];\n/** Returns Point type from PointCons (PC_P<PC> == PC.P) */\nexport type PC_P<PC extends CurvePointCons<CurvePoint<any, any>>> = PC['ZERO'];\n\n// Ugly hack to get proper type inference, because in typescript fails to infer resursively.\n// The hack allows to do up to 10 chained operations without applying type erasure.\n//\n// Types which won't work:\n// * `CurvePointCons<CurvePoint<any, any>>`, will return `any` after 1 operation\n// * `CurvePointCons<any>: WeierstrassPointCons<bigint> extends CurvePointCons<any> = false`\n// * `P extends CurvePoint, PC extends CurvePointCons<P>`\n//     * It can't infer P from PC alone\n//     * Too many relations between F, P & PC\n//     * It will infer P/F if `arg: CurvePointCons<F, P>`, but will fail if PC is generic\n//     * It will work correctly if there is an additional argument of type P\n//     * But generally, we don't want to parametrize `CurvePointCons` over `F`: it will complicate\n//       types, making them un-inferable\n// prettier-ignore\nexport type PC_ANY = CurvePointCons<\n  CurvePoint<any,\n  CurvePoint<any,\n  CurvePoint<any,\n  CurvePoint<any,\n  CurvePoint<any,\n  CurvePoint<any,\n  CurvePoint<any,\n  CurvePoint<any,\n  CurvePoint<any,\n  CurvePoint<any, any>\n  >>>>>>>>>\n>;\n\nexport interface CurveLengths {\n  secretKey?: number;\n  publicKey?: number;\n  publicKeyUncompressed?: number;\n  publicKeyHasPrefix?: boolean;\n  signature?: number;\n  seed?: number;\n}\n\nexport type Mapper<T> = (i: T[]) => T[];\n\nexport function negateCt<T extends { negate: () => T }>(condition: boolean, item: T): T {\n  const neg = item.negate();\n  return condition ? neg : item;\n}\n\n/**\n * Takes a bunch of Projective Points but executes only one\n * inversion on all of them. Inversion is very slow operation,\n * so this improves performance massively.\n * Optimization: converts a list of projective points to a list of identical points with Z=1.\n */\nexport function normalizeZ<P extends CurvePoint<any, P>, PC extends CurvePointCons<P>>(\n  c: PC,\n  points: P[]\n): P[] {\n  const invertedZs = FpInvertBatch(\n    c.Fp,\n    points.map((p) => p.Z!)\n  );\n  return points.map((p, i) => c.fromAffine(p.toAffine(invertedZs[i])));\n}\n\nfunction validateW(W: number, bits: number) {\n  if (!Number.isSafeInteger(W) || W <= 0 || W > bits)\n    throw new Error('invalid window size, expected [1..' + bits + '], got W=' + W);\n}\n\n/** Internal wNAF opts for specific W and scalarBits */\ntype WOpts = {\n  windows: number;\n  windowSize: number;\n  mask: bigint;\n  maxNumber: number;\n  shiftBy: bigint;\n};\n\nfunction calcWOpts(W: number, scalarBits: number): WOpts {\n  validateW(W, scalarBits);\n  const windows = Math.ceil(scalarBits / W) + 1; // W=8 33. Not 32, because we skip zero\n  const windowSize = 2 ** (W - 1); // W=8 128. Not 256, because we skip zero\n  const maxNumber = 2 ** W; // W=8 256\n  const mask = bitMask(W); // W=8 255 == mask 0b11111111\n  const shiftBy = BigInt(W); // W=8 8\n  return { windows, windowSize, mask, maxNumber, shiftBy };\n}\n\nfunction calcOffsets(n: bigint, window: number, wOpts: WOpts) {\n  const { windowSize, mask, maxNumber, shiftBy } = wOpts;\n  let wbits = Number(n & mask); // extract W bits.\n  let nextN = n >> shiftBy; // shift number by W bits.\n\n  // What actually happens here:\n  // const highestBit = Number(mask ^ (mask >> 1n));\n  // let wbits2 = wbits - 1; // skip zero\n  // if (wbits2 & highestBit) { wbits2 ^= Number(mask); // (~);\n\n  // split if bits > max: +224 => 256-32\n  if (wbits > windowSize) {\n    // we skip zero, which means instead of `>= size-1`, we do `> size`\n    wbits -= maxNumber; // -32, can be maxNumber - wbits, but then we need to set isNeg here.\n    nextN += _1n; // +256 (carry)\n  }\n  const offsetStart = window * windowSize;\n  const offset = offsetStart + Math.abs(wbits) - 1; // -1 because we skip zero\n  const isZero = wbits === 0; // is current window slice a 0?\n  const isNeg = wbits < 0; // is current window slice negative?\n  const isNegF = window % 2 !== 0; // fake random statement for noise\n  const offsetF = offsetStart; // fake offset for noise\n  return { nextN, offset, isZero, isNeg, isNegF, offsetF };\n}\n\nfunction validateMSMPoints(points: any[], c: any) {\n  if (!Array.isArray(points)) throw new Error('array expected');\n  points.forEach((p, i) => {\n    if (!(p instanceof c)) throw new Error('invalid point at index ' + i);\n  });\n}\nfunction validateMSMScalars(scalars: any[], field: any) {\n  if (!Array.isArray(scalars)) throw new Error('array of scalars expected');\n  scalars.forEach((s, i) => {\n    if (!field.isValid(s)) throw new Error('invalid scalar at index ' + i);\n  });\n}\n\n// Since points in different groups cannot be equal (different object constructor),\n// we can have single place to store precomputes.\n// Allows to make points frozen / immutable.\nconst pointPrecomputes = new WeakMap<any, any[]>();\nconst pointWindowSizes = new WeakMap<any, number>();\n\nfunction getW(P: any): number {\n  // To disable precomputes:\n  // return 1;\n  return pointWindowSizes.get(P) || 1;\n}\n\nfunction assert0(n: bigint): void {\n  if (n !== _0n) throw new Error('invalid wNAF');\n}\n\n/**\n * Elliptic curve multiplication of Point by scalar. Fragile.\n * Table generation takes **30MB of ram and 10ms on high-end CPU**,\n * but may take much longer on slow devices. Actual generation will happen on\n * first call of `multiply()`. By default, `BASE` point is precomputed.\n *\n * Scalars should always be less than curve order: this should be checked inside of a curve itself.\n * Creates precomputation tables for fast multiplication:\n * - private scalar is split by fixed size windows of W bits\n * - every window point is collected from window's table & added to accumulator\n * - since windows are different, same point inside tables won't be accessed more than once per calc\n * - each multiplication is 'Math.ceil(CURVE_ORDER / \uD835\uDC4A) + 1' point additions (fixed for any scalar)\n * - +1 window is neccessary for wNAF\n * - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n *\n * @todo Research returning 2d JS array of windows, instead of a single window.\n * This would allow windows to be in different memory locations\n */\nexport class wNAF<PC extends PC_ANY> {\n  private readonly BASE: PC_P<PC>;\n  private readonly ZERO: PC_P<PC>;\n  private readonly Fn: PC['Fn'];\n  readonly bits: number;\n\n  // Parametrized with a given Point class (not individual point)\n  constructor(Point: PC, bits: number) {\n    this.BASE = Point.BASE;\n    this.ZERO = Point.ZERO;\n    this.Fn = Point.Fn;\n    this.bits = bits;\n  }\n\n  // non-const time multiplication ladder\n  _unsafeLadder(elm: PC_P<PC>, n: bigint, p: PC_P<PC> = this.ZERO): PC_P<PC> {\n    let d: PC_P<PC> = elm;\n    while (n > _0n) {\n      if (n & _1n) p = p.add(d);\n      d = d.double();\n      n >>= _1n;\n    }\n    return p;\n  }\n\n  /**\n   * Creates a wNAF precomputation window. Used for caching.\n   * Default window size is set by `utils.precompute()` and is equal to 8.\n   * Number of precomputed points depends on the curve size:\n   * 2^(\uD835\uDC4A\u22121) * (Math.ceil(\uD835\uDC5B / \uD835\uDC4A) + 1), where:\n   * - \uD835\uDC4A is the window size\n   * - \uD835\uDC5B is the bitlength of the curve order.\n   * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n   * @param point Point instance\n   * @param W window size\n   * @returns precomputed point tables flattened to a single array\n   */\n  private precomputeWindow(point: PC_P<PC>, W: number): PC_P<PC>[] {\n    const { windows, windowSize } = calcWOpts(W, this.bits);\n    const points: PC_P<PC>[] = [];\n    let p: PC_P<PC> = point;\n    let base = p;\n    for (let window = 0; window < windows; window++) {\n      base = p;\n      points.push(base);\n      // i=1, bc we skip 0\n      for (let i = 1; i < windowSize; i++) {\n        base = base.add(p);\n        points.push(base);\n      }\n      p = base.double();\n    }\n    return points;\n  }\n\n  /**\n   * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n   * More compact implementation:\n   * https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541\n   * @returns real and fake (for const-time) points\n   */\n  private wNAF(W: number, precomputes: PC_P<PC>[], n: bigint): { p: PC_P<PC>; f: PC_P<PC> } {\n    // Scalar should be smaller than field order\n    if (!this.Fn.isValid(n)) throw new Error('invalid scalar');\n    // Accumulators\n    let p = this.ZERO;\n    let f = this.BASE;\n    // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n    // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n    // there is negate now: it is possible that negated element from low value\n    // would be the same as high element, which will create carry into next window.\n    // It's not obvious how this can fail, but still worth investigating later.\n    const wo = calcWOpts(W, this.bits);\n    for (let window = 0; window < wo.windows; window++) {\n      // (n === _0n) is handled and not early-exited. isEven and offsetF are used for noise\n      const { nextN, offset, isZero, isNeg, isNegF, offsetF } = calcOffsets(n, window, wo);\n      n = nextN;\n      if (isZero) {\n        // bits are 0: add garbage to fake point\n        // Important part for const-time getPublicKey: add random \"noise\" point to f.\n        f = f.add(negateCt(isNegF, precomputes[offsetF]));\n      } else {\n        // bits are 1: add to result point\n        p = p.add(negateCt(isNeg, precomputes[offset]));\n      }\n    }\n    assert0(n);\n    // Return both real and fake points: JIT won't eliminate f.\n    // At this point there is a way to F be infinity-point even if p is not,\n    // which makes it less const-time: around 1 bigint multiply.\n    return { p, f };\n  }\n\n  /**\n   * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.\n   * @param acc accumulator point to add result of multiplication\n   * @returns point\n   */\n  private wNAFUnsafe(\n    W: number,\n    precomputes: PC_P<PC>[],\n    n: bigint,\n    acc: PC_P<PC> = this.ZERO\n  ): PC_P<PC> {\n    const wo = calcWOpts(W, this.bits);\n    for (let window = 0; window < wo.windows; window++) {\n      if (n === _0n) break; // Early-exit, skip 0 value\n      const { nextN, offset, isZero, isNeg } = calcOffsets(n, window, wo);\n      n = nextN;\n      if (isZero) {\n        // Window bits are 0: skip processing.\n        // Move to next window.\n        continue;\n      } else {\n        const item = precomputes[offset];\n        acc = acc.add(isNeg ? item.negate() : item); // Re-using acc allows to save adds in MSM\n      }\n    }\n    assert0(n);\n    return acc;\n  }\n\n  private getPrecomputes(W: number, point: PC_P<PC>, transform?: Mapper<PC_P<PC>>): PC_P<PC>[] {\n    // Calculate precomputes on a first run, reuse them after\n    let comp = pointPrecomputes.get(point);\n    if (!comp) {\n      comp = this.precomputeWindow(point, W) as PC_P<PC>[];\n      if (W !== 1) {\n        // Doing transform outside of if brings 15% perf hit\n        if (typeof transform === 'function') comp = transform(comp);\n        pointPrecomputes.set(point, comp);\n      }\n    }\n    return comp;\n  }\n\n  cached(\n    point: PC_P<PC>,\n    scalar: bigint,\n    transform?: Mapper<PC_P<PC>>\n  ): { p: PC_P<PC>; f: PC_P<PC> } {\n    const W = getW(point);\n    return this.wNAF(W, this.getPrecomputes(W, point, transform), scalar);\n  }\n\n  unsafe(point: PC_P<PC>, scalar: bigint, transform?: Mapper<PC_P<PC>>, prev?: PC_P<PC>): PC_P<PC> {\n    const W = getW(point);\n    if (W === 1) return this._unsafeLadder(point, scalar, prev); // For W=1 ladder is ~x2 faster\n    return this.wNAFUnsafe(W, this.getPrecomputes(W, point, transform), scalar, prev);\n  }\n\n  // We calculate precomputes for elliptic curve point multiplication\n  // using windowed method. This specifies window size and\n  // stores precomputed values. Usually only base point would be precomputed.\n  createCache(P: PC_P<PC>, W: number): void {\n    validateW(W, this.bits);\n    pointWindowSizes.set(P, W);\n    pointPrecomputes.delete(P);\n  }\n\n  hasCache(elm: PC_P<PC>): boolean {\n    return getW(elm) !== 1;\n  }\n}\n\n/**\n * Endomorphism-specific multiplication for Koblitz curves.\n * Cost: 128 dbl, 0-256 adds.\n */\nexport function mulEndoUnsafe<P extends CurvePoint<any, P>, PC extends CurvePointCons<P>>(\n  Point: PC,\n  point: P,\n  k1: bigint,\n  k2: bigint\n): { p1: P; p2: P } {\n  let acc = point;\n  let p1 = Point.ZERO;\n  let p2 = Point.ZERO;\n  while (k1 > _0n || k2 > _0n) {\n    if (k1 & _1n) p1 = p1.add(acc);\n    if (k2 & _1n) p2 = p2.add(acc);\n    acc = acc.double();\n    k1 >>= _1n;\n    k2 >>= _1n;\n  }\n  return { p1, p2 };\n}\n\n/**\n * Pippenger algorithm for multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * 30x faster vs naive addition on L=4096, 10x faster than precomputes.\n * For N=254bit, L=1, it does: 1024 ADD + 254 DBL. For L=5: 1536 ADD + 254 DBL.\n * Algorithmically constant-time (for same L), even when 1 point + scalar, or when scalar = 0.\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @param scalars array of L scalars (aka secret keys / bigints)\n */\nexport function pippenger<P extends CurvePoint<any, P>, PC extends CurvePointCons<P>>(\n  c: PC,\n  points: P[],\n  scalars: bigint[]\n): P {\n  // If we split scalars by some window (let's say 8 bits), every chunk will only\n  // take 256 buckets even if there are 4096 scalars, also re-uses double.\n  // TODO:\n  // - https://eprint.iacr.org/2024/750.pdf\n  // - https://tches.iacr.org/index.php/TCHES/article/view/10287\n  // 0 is accepted in scalars\n  const fieldN = c.Fn;\n  validateMSMPoints(points, c);\n  validateMSMScalars(scalars, fieldN);\n  const plength = points.length;\n  const slength = scalars.length;\n  if (plength !== slength) throw new Error('arrays of points and scalars must have equal length');\n  // if (plength === 0) throw new Error('array must be of length >= 2');\n  const zero = c.ZERO;\n  const wbits = bitLen(BigInt(plength));\n  let windowSize = 1; // bits\n  if (wbits > 12) windowSize = wbits - 3;\n  else if (wbits > 4) windowSize = wbits - 2;\n  else if (wbits > 0) windowSize = 2;\n  const MASK = bitMask(windowSize);\n  const buckets = new Array(Number(MASK) + 1).fill(zero); // +1 for zero array\n  const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;\n  let sum = zero;\n  for (let i = lastBits; i >= 0; i -= windowSize) {\n    buckets.fill(zero);\n    for (let j = 0; j < slength; j++) {\n      const scalar = scalars[j];\n      const wbits = Number((scalar >> BigInt(i)) & MASK);\n      buckets[wbits] = buckets[wbits].add(points[j]);\n    }\n    let resI = zero; // not using this will do small speed-up, but will lose ct\n    // Skip first bucket, because it is zero\n    for (let j = buckets.length - 1, sumI = zero; j > 0; j--) {\n      sumI = sumI.add(buckets[j]);\n      resI = resI.add(sumI);\n    }\n    sum = sum.add(resI);\n    if (i !== 0) for (let j = 0; j < windowSize; j++) sum = sum.double();\n  }\n  return sum as P;\n}\n/**\n * Precomputed multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @returns function which multiplies points with scaars\n */\nexport function precomputeMSMUnsafe<P extends CurvePoint<any, P>, PC extends CurvePointCons<P>>(\n  c: PC,\n  points: P[],\n  windowSize: number\n): (scalars: bigint[]) => P {\n  /**\n   * Performance Analysis of Window-based Precomputation\n   *\n   * Base Case (256-bit scalar, 8-bit window):\n   * - Standard precomputation requires:\n   *   - 31 additions per scalar \u00D7 256 scalars = 7,936 ops\n   *   - Plus 255 summary additions = 8,191 total ops\n   *   Note: Summary additions can be optimized via accumulator\n   *\n   * Chunked Precomputation Analysis:\n   * - Using 32 chunks requires:\n   *   - 255 additions per chunk\n   *   - 256 doublings\n   *   - Total: (255 \u00D7 32) + 256 = 8,416 ops\n   *\n   * Memory Usage Comparison:\n   * Window Size | Standard Points | Chunked Points\n   * ------------|-----------------|---------------\n   *     4-bit   |     520         |      15\n   *     8-bit   |    4,224        |     255\n   *    10-bit   |   13,824        |   1,023\n   *    16-bit   |  557,056        |  65,535\n   *\n   * Key Advantages:\n   * 1. Enables larger window sizes due to reduced memory overhead\n   * 2. More efficient for smaller scalar counts:\n   *    - 16 chunks: (16 \u00D7 255) + 256 = 4,336 ops\n   *    - ~2x faster than standard 8,191 ops\n   *\n   * Limitations:\n   * - Not suitable for plain precomputes (requires 256 constant doublings)\n   * - Performance degrades with larger scalar counts:\n   *   - Optimal for ~256 scalars\n   *   - Less efficient for 4096+ scalars (Pippenger preferred)\n   */\n  const fieldN = c.Fn;\n  validateW(windowSize, fieldN.BITS);\n  validateMSMPoints(points, c);\n  const zero = c.ZERO;\n  const tableSize = 2 ** windowSize - 1; // table size (without zero)\n  const chunks = Math.ceil(fieldN.BITS / windowSize); // chunks of item\n  const MASK = bitMask(windowSize);\n  const tables = points.map((p: P) => {\n    const res = [];\n    for (let i = 0, acc = p; i < tableSize; i++) {\n      res.push(acc);\n      acc = acc.add(p);\n    }\n    return res;\n  });\n  return (scalars: bigint[]): P => {\n    validateMSMScalars(scalars, fieldN);\n    if (scalars.length > points.length)\n      throw new Error('array of scalars must be smaller than array of points');\n    let res = zero;\n    for (let i = 0; i < chunks; i++) {\n      // No need to double if accumulator is still zero.\n      if (res !== zero) for (let j = 0; j < windowSize; j++) res = res.double();\n      const shiftBy = BigInt(chunks * windowSize - (i + 1) * windowSize);\n      for (let j = 0; j < scalars.length; j++) {\n        const n = scalars[j];\n        const curr = Number((n >> shiftBy) & MASK);\n        if (!curr) continue; // skip zero scalars chunks\n        res = res.add(tables[j][curr - 1]);\n      }\n    }\n    return res;\n  };\n}\n\nexport type ValidCurveParams<T> = {\n  p: bigint;\n  n: bigint;\n  h: bigint;\n  a: T;\n  b?: T;\n  d?: T;\n  Gx: T;\n  Gy: T;\n};\n\nfunction createField<T>(order: bigint, field?: IField<T>, isLE?: boolean): IField<T> {\n  if (field) {\n    if (field.ORDER !== order) throw new Error('Field.ORDER must match order: Fp == p, Fn == n');\n    validateField(field);\n    return field;\n  } else {\n    return Field(order, { isLE }) as unknown as IField<T>;\n  }\n}\nexport type FpFn<T> = { Fp: IField<T>; Fn: IField<bigint> };\n\n/** Validates CURVE opts and creates fields */\nexport function createCurveFields<T>(\n  type: 'weierstrass' | 'edwards',\n  CURVE: ValidCurveParams<T>,\n  curveOpts: Partial<FpFn<T>> = {},\n  FpFnLE?: boolean\n): FpFn<T> & { CURVE: ValidCurveParams<T> } {\n  if (FpFnLE === undefined) FpFnLE = type === 'edwards';\n  if (!CURVE || typeof CURVE !== 'object') throw new Error(`expected valid ${type} CURVE object`);\n  for (const p of ['p', 'n', 'h'] as const) {\n    const val = CURVE[p];\n    if (!(typeof val === 'bigint' && val > _0n))\n      throw new Error(`CURVE.${p} must be positive bigint`);\n  }\n  const Fp = createField(CURVE.p, curveOpts.Fp, FpFnLE);\n  const Fn = createField(CURVE.n, curveOpts.Fn, FpFnLE);\n  const _b: 'b' | 'd' = type === 'weierstrass' ? 'b' : 'd';\n  const params = ['Gx', 'Gy', 'a', _b] as const;\n  for (const p of params) {\n    // @ts-ignore\n    if (!Fp.isValid(CURVE[p]))\n      throw new Error(`CURVE.${p} must be valid field element of CURVE.Fp`);\n  }\n  CURVE = Object.freeze(Object.assign({}, CURVE));\n  return { CURVE, Fp, Fn };\n}\n\ntype KeygenFn = (\n  seed?: Uint8Array,\n  isCompressed?: boolean\n) => { secretKey: Uint8Array; publicKey: Uint8Array };\nexport function createKeygen(\n  randomSecretKey: Function,\n  getPublicKey: Signer['getPublicKey']\n): KeygenFn {\n  return function keygen(seed?: Uint8Array) {\n    const secretKey = randomSecretKey(seed);\n    return { secretKey, publicKey: getPublicKey(secretKey) };\n  };\n}\n", "/**\n * Twisted Edwards curve. The formula is: ax\u00B2 + y\u00B2 = 1 + dx\u00B2y\u00B2.\n * For design rationale of types / exports, see weierstrass module documentation.\n * Untwisted Edwards curves exist, but they aren't used in real-world protocols.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport {\n  abool,\n  abytes,\n  aInRange,\n  bytesToHex,\n  bytesToNumberLE,\n  concatBytes,\n  copyBytes,\n  hexToBytes,\n  isBytes,\n  memoized,\n  notImplemented,\n  validateObject,\n  randomBytes as wcRandomBytes,\n  type FHash,\n  type Signer,\n} from '../utils.ts';\nimport {\n  createCurveFields,\n  createKeygen,\n  normalizeZ,\n  wNAF,\n  type AffinePoint,\n  type CurveLengths,\n  type CurvePoint,\n  type CurvePointCons,\n} from './curve.ts';\nimport { type IField } from './modular.ts';\n\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _8n = BigInt(8);\n\n/** Instance of Extended Point with coordinates in X, Y, Z, T. */\nexport interface EdwardsPoint extends CurvePoint<bigint, EdwardsPoint> {\n  /** extended X coordinate. Different from affine x. */\n  readonly X: bigint;\n  /** extended Y coordinate. Different from affine y. */\n  readonly Y: bigint;\n  /** extended Z coordinate */\n  readonly Z: bigint;\n  /** extended T coordinate */\n  readonly T: bigint;\n}\n/** Static methods of Extended Point with coordinates in X, Y, Z, T. */\nexport interface EdwardsPointCons extends CurvePointCons<EdwardsPoint> {\n  new (X: bigint, Y: bigint, Z: bigint, T: bigint): EdwardsPoint;\n  CURVE(): EdwardsOpts;\n  fromBytes(bytes: Uint8Array, zip215?: boolean): EdwardsPoint;\n  fromHex(hex: string, zip215?: boolean): EdwardsPoint;\n}\n\n/**\n * Twisted Edwards curve options.\n *\n * * a: formula param\n * * d: formula param\n * * p: prime characteristic (order) of finite field, in which arithmetics is done\n * * n: order of prime subgroup a.k.a total amount of valid curve points\n * * h: cofactor. h*n is group order; n is subgroup order\n * * Gx: x coordinate of generator point a.k.a. base point\n * * Gy: y coordinate of generator point\n */\nexport type EdwardsOpts = Readonly<{\n  p: bigint;\n  n: bigint;\n  h: bigint;\n  a: bigint;\n  d: bigint;\n  Gx: bigint;\n  Gy: bigint;\n}>;\n\n/**\n * Extra curve options for Twisted Edwards.\n *\n * * Fp: redefined Field over curve.p\n * * Fn: redefined Field over curve.n\n * * uvRatio: helper function for decompression, calculating \u221A(u/v)\n */\nexport type EdwardsExtraOpts = Partial<{\n  Fp: IField<bigint>;\n  Fn: IField<bigint>;\n  FpFnLE: boolean;\n  uvRatio: (u: bigint, v: bigint) => { isValid: boolean; value: bigint };\n}>;\n\n/**\n * EdDSA (Edwards Digital Signature algorithm) options.\n *\n * * hash: hash function used to hash secret keys and messages\n * * adjustScalarBytes: clears bits to get valid field element\n * * domain: Used for hashing\n * * mapToCurve: for hash-to-curve standard\n * * prehash: RFC 8032 pre-hashing of messages to sign() / verify()\n * * randomBytes: function generating random bytes, used for randomSecretKey\n */\nexport type EdDSAOpts = Partial<{\n  adjustScalarBytes: (bytes: Uint8Array) => Uint8Array;\n  domain: (data: Uint8Array, ctx: Uint8Array, phflag: boolean) => Uint8Array;\n  mapToCurve: (scalar: bigint[]) => AffinePoint<bigint>;\n  prehash: FHash;\n  randomBytes: (bytesLength?: number) => Uint8Array;\n}>;\n\n/**\n * EdDSA (Edwards Digital Signature algorithm) interface.\n *\n * Allows to create and verify signatures, create public and secret keys.\n */\nexport interface EdDSA {\n  keygen: (seed?: Uint8Array) => { secretKey: Uint8Array; publicKey: Uint8Array };\n  getPublicKey: (secretKey: Uint8Array) => Uint8Array;\n  sign: (\n    message: Uint8Array,\n    secretKey: Uint8Array,\n    options?: { context?: Uint8Array }\n  ) => Uint8Array;\n  verify: (\n    sig: Uint8Array,\n    message: Uint8Array,\n    publicKey: Uint8Array,\n    options?: { context?: Uint8Array; zip215: boolean }\n  ) => boolean;\n  Point: EdwardsPointCons;\n  utils: {\n    randomSecretKey: (seed?: Uint8Array) => Uint8Array;\n    isValidSecretKey: (secretKey: Uint8Array) => boolean;\n    isValidPublicKey: (publicKey: Uint8Array, zip215?: boolean) => boolean;\n\n    /**\n     * Converts ed public key to x public key.\n     *\n     * There is NO `fromMontgomery`:\n     * - There are 2 valid ed25519 points for every x25519, with flipped coordinate\n     * - Sometimes there are 0 valid ed25519 points, because x25519 *additionally*\n     *   accepts inputs on the quadratic twist, which can't be moved to ed25519\n     *\n     * @example\n     * ```js\n     * const someonesPub_ed = ed25519.getPublicKey(ed25519.utils.randomSecretKey());\n     * const someonesPub = ed25519.utils.toMontgomery(someonesPub);\n     * const aPriv = x25519.utils.randomSecretKey();\n     * const shared = x25519.getSharedSecret(aPriv, someonesPub)\n     * ```\n     */\n    toMontgomery: (publicKey: Uint8Array) => Uint8Array;\n    /**\n     * Converts ed secret key to x secret key.\n     * @example\n     * ```js\n     * const someonesPub = x25519.getPublicKey(x25519.utils.randomSecretKey());\n     * const aPriv_ed = ed25519.utils.randomSecretKey();\n     * const aPriv = ed25519.utils.toMontgomerySecret(aPriv_ed);\n     * const shared = x25519.getSharedSecret(aPriv, someonesPub)\n     * ```\n     */\n    toMontgomerySecret: (secretKey: Uint8Array) => Uint8Array;\n    getExtendedPublicKey: (key: Uint8Array) => {\n      head: Uint8Array;\n      prefix: Uint8Array;\n      scalar: bigint;\n      point: EdwardsPoint;\n      pointBytes: Uint8Array;\n    };\n  };\n  lengths: CurveLengths;\n}\n\nfunction isEdValidXY(Fp: IField<bigint>, CURVE: EdwardsOpts, x: bigint, y: bigint): boolean {\n  const x2 = Fp.sqr(x);\n  const y2 = Fp.sqr(y);\n  const left = Fp.add(Fp.mul(CURVE.a, x2), y2);\n  const right = Fp.add(Fp.ONE, Fp.mul(CURVE.d, Fp.mul(x2, y2)));\n  return Fp.eql(left, right);\n}\n\nexport function edwards(params: EdwardsOpts, extraOpts: EdwardsExtraOpts = {}): EdwardsPointCons {\n  const validated = createCurveFields('edwards', params, extraOpts, extraOpts.FpFnLE);\n  const { Fp, Fn } = validated;\n  let CURVE = validated.CURVE as EdwardsOpts;\n  const { h: cofactor } = CURVE;\n  validateObject(extraOpts, {}, { uvRatio: 'function' });\n\n  // Important:\n  // There are some places where Fp.BYTES is used instead of nByteLength.\n  // So far, everything has been tested with curves of Fp.BYTES == nByteLength.\n  // TODO: test and find curves which behave otherwise.\n  const MASK = _2n << (BigInt(Fn.BYTES * 8) - _1n);\n  const modP = (n: bigint) => Fp.create(n); // Function overrides\n\n  // sqrt(u/v)\n  const uvRatio =\n    extraOpts.uvRatio ||\n    ((u: bigint, v: bigint) => {\n      try {\n        return { isValid: true, value: Fp.sqrt(Fp.div(u, v)) };\n      } catch (e) {\n        return { isValid: false, value: _0n };\n      }\n    });\n\n  // Validate whether the passed curve params are valid.\n  // equation ax\u00B2 + y\u00B2 = 1 + dx\u00B2y\u00B2 should work for generator point.\n  if (!isEdValidXY(Fp, CURVE, CURVE.Gx, CURVE.Gy))\n    throw new Error('bad curve params: generator point');\n\n  /**\n   * Asserts coordinate is valid: 0 <= n < MASK.\n   * Coordinates >= Fp.ORDER are allowed for zip215.\n   */\n  function acoord(title: string, n: bigint, banZero = false) {\n    const min = banZero ? _1n : _0n;\n    aInRange('coordinate ' + title, n, min, MASK);\n    return n;\n  }\n\n  function aedpoint(other: unknown) {\n    if (!(other instanceof Point)) throw new Error('EdwardsPoint expected');\n  }\n  // Converts Extended point to default (x, y) coordinates.\n  // Can accept precomputed Z^-1 - for example, from invertBatch.\n  const toAffineMemo = memoized((p: Point, iz?: bigint): AffinePoint<bigint> => {\n    const { X, Y, Z } = p;\n    const is0 = p.is0();\n    if (iz == null) iz = is0 ? _8n : (Fp.inv(Z) as bigint); // 8 was chosen arbitrarily\n    const x = modP(X * iz);\n    const y = modP(Y * iz);\n    const zz = Fp.mul(Z, iz);\n    if (is0) return { x: _0n, y: _1n };\n    if (zz !== _1n) throw new Error('invZ was invalid');\n    return { x, y };\n  });\n  const assertValidMemo = memoized((p: Point) => {\n    const { a, d } = CURVE;\n    if (p.is0()) throw new Error('bad point: ZERO'); // TODO: optimize, with vars below?\n    // Equation in affine coordinates: ax\u00B2 + y\u00B2 = 1 + dx\u00B2y\u00B2\n    // Equation in projective coordinates (X/Z, Y/Z, Z):  (aX\u00B2 + Y\u00B2)Z\u00B2 = Z\u2074 + dX\u00B2Y\u00B2\n    const { X, Y, Z, T } = p;\n    const X2 = modP(X * X); // X\u00B2\n    const Y2 = modP(Y * Y); // Y\u00B2\n    const Z2 = modP(Z * Z); // Z\u00B2\n    const Z4 = modP(Z2 * Z2); // Z\u2074\n    const aX2 = modP(X2 * a); // aX\u00B2\n    const left = modP(Z2 * modP(aX2 + Y2)); // (aX\u00B2 + Y\u00B2)Z\u00B2\n    const right = modP(Z4 + modP(d * modP(X2 * Y2))); // Z\u2074 + dX\u00B2Y\u00B2\n    if (left !== right) throw new Error('bad point: equation left != right (1)');\n    // In Extended coordinates we also have T, which is x*y=T/Z: check X*Y == Z*T\n    const XY = modP(X * Y);\n    const ZT = modP(Z * T);\n    if (XY !== ZT) throw new Error('bad point: equation left != right (2)');\n    return true;\n  });\n\n  // Extended Point works in extended coordinates: (X, Y, Z, T) \u220B (x=X/Z, y=Y/Z, T=xy).\n  // https://en.wikipedia.org/wiki/Twisted_Edwards_curve#Extended_coordinates\n  class Point implements EdwardsPoint {\n    // base / generator point\n    static readonly BASE = new Point(CURVE.Gx, CURVE.Gy, _1n, modP(CURVE.Gx * CURVE.Gy));\n    // zero / infinity / identity point\n    static readonly ZERO = new Point(_0n, _1n, _1n, _0n); // 0, 1, 1, 0\n    // math field\n    static readonly Fp = Fp;\n    // scalar field\n    static readonly Fn = Fn;\n\n    readonly X: bigint;\n    readonly Y: bigint;\n    readonly Z: bigint;\n    readonly T: bigint;\n\n    constructor(X: bigint, Y: bigint, Z: bigint, T: bigint) {\n      this.X = acoord('x', X);\n      this.Y = acoord('y', Y);\n      this.Z = acoord('z', Z, true);\n      this.T = acoord('t', T);\n      Object.freeze(this);\n    }\n\n    static CURVE(): EdwardsOpts {\n      return CURVE;\n    }\n\n    static fromAffine(p: AffinePoint<bigint>): Point {\n      if (p instanceof Point) throw new Error('extended point not allowed');\n      const { x, y } = p || {};\n      acoord('x', x);\n      acoord('y', y);\n      return new Point(x, y, _1n, modP(x * y));\n    }\n\n    // Uses algo from RFC8032 5.1.3.\n    static fromBytes(bytes: Uint8Array, zip215 = false): Point {\n      const len = Fp.BYTES;\n      const { a, d } = CURVE;\n      bytes = copyBytes(abytes(bytes, len, 'point'));\n      abool(zip215, 'zip215');\n      const normed = copyBytes(bytes); // copy again, we'll manipulate it\n      const lastByte = bytes[len - 1]; // select last byte\n      normed[len - 1] = lastByte & ~0x80; // clear last bit\n      const y = bytesToNumberLE(normed);\n\n      // zip215=true is good for consensus-critical apps. =false follows RFC8032 / NIST186-5.\n      // RFC8032 prohibits >= p, but ZIP215 doesn't\n      // zip215=true:  0 <= y < MASK (2^256 for ed25519)\n      // zip215=false: 0 <= y < P (2^255-19 for ed25519)\n      const max = zip215 ? MASK : Fp.ORDER;\n      aInRange('point.y', y, _0n, max);\n\n      // Ed25519: x\u00B2 = (y\u00B2-1)/(dy\u00B2+1) mod p. Ed448: x\u00B2 = (y\u00B2-1)/(dy\u00B2-1) mod p. Generic case:\n      // ax\u00B2+y\u00B2=1+dx\u00B2y\u00B2 => y\u00B2-1=dx\u00B2y\u00B2-ax\u00B2 => y\u00B2-1=x\u00B2(dy\u00B2-a) => x\u00B2=(y\u00B2-1)/(dy\u00B2-a)\n      const y2 = modP(y * y); // denominator is always non-0 mod p.\n      const u = modP(y2 - _1n); // u = y\u00B2 - 1\n      const v = modP(d * y2 - a); // v = d y\u00B2 + 1.\n      let { isValid, value: x } = uvRatio(u, v); // \u221A(u/v)\n      if (!isValid) throw new Error('bad point: invalid y coordinate');\n      const isXOdd = (x & _1n) === _1n; // There are 2 square roots. Use x_0 bit to select proper\n      const isLastByteOdd = (lastByte & 0x80) !== 0; // x_0, last bit\n      if (!zip215 && x === _0n && isLastByteOdd)\n        // if x=0 and x_0 = 1, fail\n        throw new Error('bad point: x=0 and x_0=1');\n      if (isLastByteOdd !== isXOdd) x = modP(-x); // if x_0 != x mod 2, set x = p-x\n      return Point.fromAffine({ x, y });\n    }\n\n    static fromHex(hex: string, zip215 = false): Point {\n      return Point.fromBytes(hexToBytes(hex), zip215);\n    }\n\n    get x(): bigint {\n      return this.toAffine().x;\n    }\n    get y(): bigint {\n      return this.toAffine().y;\n    }\n\n    precompute(windowSize: number = 8, isLazy = true) {\n      wnaf.createCache(this, windowSize);\n      if (!isLazy) this.multiply(_2n); // random number\n      return this;\n    }\n\n    // Useful in fromAffine() - not for fromBytes(), which always created valid points.\n    assertValidity(): void {\n      assertValidMemo(this);\n    }\n\n    // Compare one point to another.\n    equals(other: Point): boolean {\n      aedpoint(other);\n      const { X: X1, Y: Y1, Z: Z1 } = this;\n      const { X: X2, Y: Y2, Z: Z2 } = other;\n      const X1Z2 = modP(X1 * Z2);\n      const X2Z1 = modP(X2 * Z1);\n      const Y1Z2 = modP(Y1 * Z2);\n      const Y2Z1 = modP(Y2 * Z1);\n      return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;\n    }\n\n    is0(): boolean {\n      return this.equals(Point.ZERO);\n    }\n\n    negate(): Point {\n      // Flips point sign to a negative one (-x, y in affine coords)\n      return new Point(modP(-this.X), this.Y, this.Z, modP(-this.T));\n    }\n\n    // Fast algo for doubling Extended Point.\n    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd\n    // Cost: 4M + 4S + 1*a + 6add + 1*2.\n    double(): Point {\n      const { a } = CURVE;\n      const { X: X1, Y: Y1, Z: Z1 } = this;\n      const A = modP(X1 * X1); // A = X12\n      const B = modP(Y1 * Y1); // B = Y12\n      const C = modP(_2n * modP(Z1 * Z1)); // C = 2*Z12\n      const D = modP(a * A); // D = a*A\n      const x1y1 = X1 + Y1;\n      const E = modP(modP(x1y1 * x1y1) - A - B); // E = (X1+Y1)2-A-B\n      const G = D + B; // G = D+B\n      const F = G - C; // F = G-C\n      const H = D - B; // H = D-B\n      const X3 = modP(E * F); // X3 = E*F\n      const Y3 = modP(G * H); // Y3 = G*H\n      const T3 = modP(E * H); // T3 = E*H\n      const Z3 = modP(F * G); // Z3 = F*G\n      return new Point(X3, Y3, Z3, T3);\n    }\n\n    // Fast algo for adding 2 Extended Points.\n    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd\n    // Cost: 9M + 1*a + 1*d + 7add.\n    add(other: Point) {\n      aedpoint(other);\n      const { a, d } = CURVE;\n      const { X: X1, Y: Y1, Z: Z1, T: T1 } = this;\n      const { X: X2, Y: Y2, Z: Z2, T: T2 } = other;\n      const A = modP(X1 * X2); // A = X1*X2\n      const B = modP(Y1 * Y2); // B = Y1*Y2\n      const C = modP(T1 * d * T2); // C = T1*d*T2\n      const D = modP(Z1 * Z2); // D = Z1*Z2\n      const E = modP((X1 + Y1) * (X2 + Y2) - A - B); // E = (X1+Y1)*(X2+Y2)-A-B\n      const F = D - C; // F = D-C\n      const G = D + C; // G = D+C\n      const H = modP(B - a * A); // H = B-a*A\n      const X3 = modP(E * F); // X3 = E*F\n      const Y3 = modP(G * H); // Y3 = G*H\n      const T3 = modP(E * H); // T3 = E*H\n      const Z3 = modP(F * G); // Z3 = F*G\n      return new Point(X3, Y3, Z3, T3);\n    }\n\n    subtract(other: Point): Point {\n      return this.add(other.negate());\n    }\n\n    // Constant-time multiplication.\n    multiply(scalar: bigint): Point {\n      // 1 <= scalar < L\n      if (!Fn.isValidNot0(scalar)) throw new Error('invalid scalar: expected 1 <= sc < curve.n');\n      const { p, f } = wnaf.cached(this, scalar, (p) => normalizeZ(Point, p));\n      return normalizeZ(Point, [p, f])[0];\n    }\n\n    // Non-constant-time multiplication. Uses double-and-add algorithm.\n    // It's faster, but should only be used when you don't care about\n    // an exposed private key e.g. sig verification.\n    // Does NOT allow scalars higher than CURVE.n.\n    // Accepts optional accumulator to merge with multiply (important for sparse scalars)\n    multiplyUnsafe(scalar: bigint, acc = Point.ZERO): Point {\n      // 0 <= scalar < L\n      if (!Fn.isValid(scalar)) throw new Error('invalid scalar: expected 0 <= sc < curve.n');\n      if (scalar === _0n) return Point.ZERO;\n      if (this.is0() || scalar === _1n) return this;\n      return wnaf.unsafe(this, scalar, (p) => normalizeZ(Point, p), acc);\n    }\n\n    // Checks if point is of small order.\n    // If you add something to small order point, you will have \"dirty\"\n    // point with torsion component.\n    // Multiplies point by cofactor and checks if the result is 0.\n    isSmallOrder(): boolean {\n      return this.multiplyUnsafe(cofactor).is0();\n    }\n\n    // Multiplies point by curve order and checks if the result is 0.\n    // Returns `false` is the point is dirty.\n    isTorsionFree(): boolean {\n      return wnaf.unsafe(this, CURVE.n).is0();\n    }\n\n    // Converts Extended point to default (x, y) coordinates.\n    // Can accept precomputed Z^-1 - for example, from invertBatch.\n    toAffine(invertedZ?: bigint): AffinePoint<bigint> {\n      return toAffineMemo(this, invertedZ);\n    }\n\n    clearCofactor(): Point {\n      if (cofactor === _1n) return this;\n      return this.multiplyUnsafe(cofactor);\n    }\n\n    toBytes(): Uint8Array {\n      const { x, y } = this.toAffine();\n      // Fp.toBytes() allows non-canonical encoding of y (>= p).\n      const bytes = Fp.toBytes(y);\n      // Each y has 2 valid points: (x, y), (x,-y).\n      // When compressing, it's enough to store y and use the last byte to encode sign of x\n      bytes[bytes.length - 1] |= x & _1n ? 0x80 : 0;\n      return bytes;\n    }\n    toHex(): string {\n      return bytesToHex(this.toBytes());\n    }\n\n    toString() {\n      return `<Point ${this.is0() ? 'ZERO' : this.toHex()}>`;\n    }\n  }\n  const wnaf = new wNAF(Point, Fn.BITS);\n  Point.BASE.precompute(8); // Enable precomputes. Slows down first publicKey computation by 20ms.\n  return Point;\n}\n\n/**\n * Base class for prime-order points like Ristretto255 and Decaf448.\n * These points eliminate cofactor issues by representing equivalence classes\n * of Edwards curve points.\n */\nexport abstract class PrimeEdwardsPoint<T extends PrimeEdwardsPoint<T>>\n  implements CurvePoint<bigint, T>\n{\n  static BASE: PrimeEdwardsPoint<any>;\n  static ZERO: PrimeEdwardsPoint<any>;\n  static Fp: IField<bigint>;\n  static Fn: IField<bigint>;\n\n  protected readonly ep: EdwardsPoint;\n\n  constructor(ep: EdwardsPoint) {\n    this.ep = ep;\n  }\n\n  // Abstract methods that must be implemented by subclasses\n  abstract toBytes(): Uint8Array;\n  abstract equals(other: T): boolean;\n\n  // Static methods that must be implemented by subclasses\n  static fromBytes(_bytes: Uint8Array): any {\n    notImplemented();\n  }\n\n  static fromHex(_hex: string): any {\n    notImplemented();\n  }\n\n  get x(): bigint {\n    return this.toAffine().x;\n  }\n  get y(): bigint {\n    return this.toAffine().y;\n  }\n\n  // Common implementations\n  clearCofactor(): T {\n    // no-op for prime-order groups\n    return this as any;\n  }\n\n  assertValidity(): void {\n    this.ep.assertValidity();\n  }\n\n  toAffine(invertedZ?: bigint): AffinePoint<bigint> {\n    return this.ep.toAffine(invertedZ);\n  }\n\n  toHex(): string {\n    return bytesToHex(this.toBytes());\n  }\n\n  toString(): string {\n    return this.toHex();\n  }\n\n  isTorsionFree(): boolean {\n    return true;\n  }\n\n  isSmallOrder(): boolean {\n    return false;\n  }\n\n  add(other: T): T {\n    this.assertSame(other);\n    return this.init(this.ep.add(other.ep));\n  }\n\n  subtract(other: T): T {\n    this.assertSame(other);\n    return this.init(this.ep.subtract(other.ep));\n  }\n\n  multiply(scalar: bigint): T {\n    return this.init(this.ep.multiply(scalar));\n  }\n\n  multiplyUnsafe(scalar: bigint): T {\n    return this.init(this.ep.multiplyUnsafe(scalar));\n  }\n\n  double(): T {\n    return this.init(this.ep.double());\n  }\n\n  negate(): T {\n    return this.init(this.ep.negate());\n  }\n\n  precompute(windowSize?: number, isLazy?: boolean): T {\n    return this.init(this.ep.precompute(windowSize, isLazy));\n  }\n\n  // Helper methods\n  abstract is0(): boolean;\n  protected abstract assertSame(other: T): void;\n  protected abstract init(ep: EdwardsPoint): T;\n}\n\n/**\n * Initializes EdDSA signatures over given Edwards curve.\n */\nexport function eddsa(Point: EdwardsPointCons, cHash: FHash, eddsaOpts: EdDSAOpts = {}): EdDSA {\n  if (typeof cHash !== 'function') throw new Error('\"hash\" function param is required');\n  validateObject(\n    eddsaOpts,\n    {},\n    {\n      adjustScalarBytes: 'function',\n      randomBytes: 'function',\n      domain: 'function',\n      prehash: 'function',\n      mapToCurve: 'function',\n    }\n  );\n\n  const { prehash } = eddsaOpts;\n  const { BASE, Fp, Fn } = Point;\n\n  const randomBytes = eddsaOpts.randomBytes || wcRandomBytes;\n  const adjustScalarBytes = eddsaOpts.adjustScalarBytes || ((bytes: Uint8Array) => bytes);\n  const domain =\n    eddsaOpts.domain ||\n    ((data: Uint8Array, ctx: Uint8Array, phflag: boolean) => {\n      abool(phflag, 'phflag');\n      if (ctx.length || phflag) throw new Error('Contexts/pre-hash are not supported');\n      return data;\n    }); // NOOP\n\n  // Little-endian SHA512 with modulo n\n  function modN_LE(hash: Uint8Array): bigint {\n    return Fn.create(bytesToNumberLE(hash)); // Not Fn.fromBytes: it has length limit\n  }\n\n  // Get the hashed private scalar per RFC8032 5.1.5\n  function getPrivateScalar(key: Uint8Array) {\n    const len = lengths.secretKey;\n    abytes(key, lengths.secretKey, 'secretKey');\n    // Hash private key with curve's hash function to produce uniformingly random input\n    // Check byte lengths: ensure(64, h(ensure(32, key)))\n    const hashed = abytes(cHash(key), 2 * len, 'hashedSecretKey');\n    const head = adjustScalarBytes(hashed.slice(0, len)); // clear first half bits, produce FE\n    const prefix = hashed.slice(len, 2 * len); // second half is called key prefix (5.1.6)\n    const scalar = modN_LE(head); // The actual private scalar\n    return { head, prefix, scalar };\n  }\n\n  /** Convenience method that creates public key from scalar. RFC8032 5.1.5 */\n  function getExtendedPublicKey(secretKey: Uint8Array) {\n    const { head, prefix, scalar } = getPrivateScalar(secretKey);\n    const point = BASE.multiply(scalar); // Point on Edwards curve aka public key\n    const pointBytes = point.toBytes();\n    return { head, prefix, scalar, point, pointBytes };\n  }\n\n  /** Calculates EdDSA pub key. RFC8032 5.1.5. */\n  function getPublicKey(secretKey: Uint8Array): Uint8Array {\n    return getExtendedPublicKey(secretKey).pointBytes;\n  }\n\n  // int('LE', SHA512(dom2(F, C) || msgs)) mod N\n  function hashDomainToScalar(context: Uint8Array = Uint8Array.of(), ...msgs: Uint8Array[]) {\n    const msg = concatBytes(...msgs);\n    return modN_LE(cHash(domain(msg, abytes(context, undefined, 'context'), !!prehash)));\n  }\n\n  /** Signs message with secret key. RFC8032 5.1.6 */\n  function sign(\n    msg: Uint8Array,\n    secretKey: Uint8Array,\n    options: { context?: Uint8Array } = {}\n  ): Uint8Array {\n    msg = abytes(msg, undefined, 'message');\n    if (prehash) msg = prehash(msg); // for ed25519ph etc.\n    const { prefix, scalar, pointBytes } = getExtendedPublicKey(secretKey);\n    const r = hashDomainToScalar(options.context, prefix, msg); // r = dom2(F, C) || prefix || PH(M)\n    const R = BASE.multiply(r).toBytes(); // R = rG\n    const k = hashDomainToScalar(options.context, R, pointBytes, msg); // R || A || PH(M)\n    const s = Fn.create(r + k * scalar); // S = (r + k * s) mod L\n    if (!Fn.isValid(s)) throw new Error('sign failed: invalid s'); // 0 <= s < L\n    const rs = concatBytes(R, Fn.toBytes(s));\n    return abytes(rs, lengths.signature, 'result');\n  }\n\n  // verification rule is either zip215 or rfc8032 / nist186-5. Consult fromHex:\n  const verifyOpts: { context?: Uint8Array; zip215?: boolean } = { zip215: true };\n\n  /**\n   * Verifies EdDSA signature against message and public key. RFC8032 5.1.7.\n   * An extended group equation is checked.\n   */\n  function verify(\n    sig: Uint8Array,\n    msg: Uint8Array,\n    publicKey: Uint8Array,\n    options = verifyOpts\n  ): boolean {\n    const { context, zip215 } = options;\n    const len = lengths.signature;\n    sig = abytes(sig, len, 'signature');\n    msg = abytes(msg, undefined, 'message');\n    publicKey = abytes(publicKey, lengths.publicKey, 'publicKey');\n    if (zip215 !== undefined) abool(zip215, 'zip215');\n    if (prehash) msg = prehash(msg); // for ed25519ph, etc\n\n    const mid = len / 2;\n    const r = sig.subarray(0, mid);\n    const s = bytesToNumberLE(sig.subarray(mid, len));\n    let A, R, SB;\n    try {\n      // zip215=true is good for consensus-critical apps. =false follows RFC8032 / NIST186-5.\n      // zip215=true:  0 <= y < MASK (2^256 for ed25519)\n      // zip215=false: 0 <= y < P (2^255-19 for ed25519)\n      A = Point.fromBytes(publicKey, zip215);\n      R = Point.fromBytes(r, zip215);\n      SB = BASE.multiplyUnsafe(s); // 0 <= s < l is done inside\n    } catch (error) {\n      return false;\n    }\n    if (!zip215 && A.isSmallOrder()) return false; // zip215 allows public keys of small order\n\n    const k = hashDomainToScalar(context, R.toBytes(), A.toBytes(), msg);\n    const RkA = R.add(A.multiplyUnsafe(k));\n    // Extended group equation\n    // [8][S]B = [8]R + [8][k]A'\n    return RkA.subtract(SB).clearCofactor().is0();\n  }\n\n  const _size = Fp.BYTES; // 32 for ed25519, 57 for ed448\n  const lengths = {\n    secretKey: _size,\n    publicKey: _size,\n    signature: 2 * _size,\n    seed: _size,\n  };\n  function randomSecretKey(seed = randomBytes(lengths.seed)): Uint8Array {\n    return abytes(seed, lengths.seed, 'seed');\n  }\n\n  function isValidSecretKey(key: Uint8Array): boolean {\n    return isBytes(key) && key.length === Fn.BYTES;\n  }\n\n  function isValidPublicKey(key: Uint8Array, zip215?: boolean): boolean {\n    try {\n      return !!Point.fromBytes(key, zip215);\n    } catch (error) {\n      return false;\n    }\n  }\n\n  const utils = {\n    getExtendedPublicKey,\n    randomSecretKey,\n    isValidSecretKey,\n    isValidPublicKey,\n    /**\n     * Converts ed public key to x public key. Uses formula:\n     * - ed25519:\n     *   - `(u, v) = ((1+y)/(1-y), sqrt(-486664)*u/x)`\n     *   - `(x, y) = (sqrt(-486664)*u/v, (u-1)/(u+1))`\n     * - ed448:\n     *   - `(u, v) = ((y-1)/(y+1), sqrt(156324)*u/x)`\n     *   - `(x, y) = (sqrt(156324)*u/v, (1+u)/(1-u))`\n     */\n    toMontgomery(publicKey: Uint8Array): Uint8Array {\n      const { y } = Point.fromBytes(publicKey);\n      const size = lengths.publicKey;\n      const is25519 = size === 32;\n      if (!is25519 && size !== 57) throw new Error('only defined for 25519 and 448');\n      const u = is25519 ? Fp.div(_1n + y, _1n - y) : Fp.div(y - _1n, y + _1n);\n      return Fp.toBytes(u);\n    },\n    toMontgomerySecret(secretKey: Uint8Array): Uint8Array {\n      const size = lengths.secretKey;\n      abytes(secretKey, size);\n      const hashed = cHash(secretKey.subarray(0, size));\n      return adjustScalarBytes(hashed).subarray(0, size);\n    },\n  };\n\n  return Object.freeze({\n    keygen: createKeygen(randomSecretKey, getPublicKey),\n    getPublicKey,\n    sign,\n    verify,\n    utils,\n    Point,\n    lengths,\n  }) satisfies Signer;\n}\n", "/**\n * Montgomery curve methods. It's not really whole montgomery curve,\n * just bunch of very specific methods for X25519 / X448 from\n * [RFC 7748](https://www.rfc-editor.org/rfc/rfc7748)\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport {\n  abytes,\n  aInRange,\n  bytesToNumberLE,\n  copyBytes,\n  numberToBytesLE,\n  randomBytes,\n  validateObject,\n  type CryptoKeys,\n} from '../utils.ts';\nimport { createKeygen, type CurveLengths } from './curve.ts';\nimport { mod } from './modular.ts';\n\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\n\nexport type MontgomeryOpts = {\n  P: bigint; // finite field prime\n  type: 'x25519' | 'x448';\n  adjustScalarBytes: (bytes: Uint8Array) => Uint8Array;\n  powPminus2: (x: bigint) => bigint;\n  randomBytes?: (bytesLength?: number) => Uint8Array;\n};\n\nexport type MontgomeryECDH = {\n  scalarMult: (scalar: Uint8Array, u: Uint8Array) => Uint8Array;\n  scalarMultBase: (scalar: Uint8Array) => Uint8Array;\n  getSharedSecret: (secretKeyA: Uint8Array, publicKeyB: Uint8Array) => Uint8Array;\n  getPublicKey: (secretKey: Uint8Array) => Uint8Array;\n  utils: {\n    randomSecretKey: () => Uint8Array;\n  };\n  GuBytes: Uint8Array;\n  lengths: CurveLengths;\n  keygen: (seed?: Uint8Array) => { secretKey: Uint8Array; publicKey: Uint8Array };\n};\n\nfunction validateOpts(curve: MontgomeryOpts) {\n  validateObject(curve, {\n    adjustScalarBytes: 'function',\n    powPminus2: 'function',\n  });\n  return Object.freeze({ ...curve } as const);\n}\n\nexport function montgomery(curveDef: MontgomeryOpts): MontgomeryECDH {\n  const CURVE = validateOpts(curveDef);\n  const { P, type, adjustScalarBytes, powPminus2, randomBytes: rand } = CURVE;\n  const is25519 = type === 'x25519';\n  if (!is25519 && type !== 'x448') throw new Error('invalid type');\n  const randomBytes_ = rand || randomBytes;\n\n  const montgomeryBits = is25519 ? 255 : 448;\n  const fieldLen = is25519 ? 32 : 56;\n  const Gu = is25519 ? BigInt(9) : BigInt(5);\n  // RFC 7748 #5:\n  // The constant a24 is (486662 - 2) / 4 = 121665 for curve25519/X25519 and\n  // (156326 - 2) / 4 = 39081 for curve448/X448\n  // const a = is25519 ? 156326n : 486662n;\n  const a24 = is25519 ? BigInt(121665) : BigInt(39081);\n  // RFC: x25519 \"the resulting integer is of the form 2^254 plus\n  // eight times a value between 0 and 2^251 - 1 (inclusive)\"\n  // x448: \"2^447 plus four times a value between 0 and 2^445 - 1 (inclusive)\"\n  const minScalar = is25519 ? _2n ** BigInt(254) : _2n ** BigInt(447);\n  const maxAdded = is25519\n    ? BigInt(8) * _2n ** BigInt(251) - _1n\n    : BigInt(4) * _2n ** BigInt(445) - _1n;\n  const maxScalar = minScalar + maxAdded + _1n; // (inclusive)\n  const modP = (n: bigint) => mod(n, P);\n  const GuBytes = encodeU(Gu);\n  function encodeU(u: bigint): Uint8Array {\n    return numberToBytesLE(modP(u), fieldLen);\n  }\n  function decodeU(u: Uint8Array): bigint {\n    const _u = copyBytes(abytes(u, fieldLen, 'uCoordinate'));\n    // RFC: When receiving such an array, implementations of X25519\n    // (but not X448) MUST mask the most significant bit in the final byte.\n    if (is25519) _u[31] &= 127; // 0b0111_1111\n    // RFC: Implementations MUST accept non-canonical values and process them as\n    // if they had been reduced modulo the field prime.  The non-canonical\n    // values are 2^255 - 19 through 2^255 - 1 for X25519 and 2^448 - 2^224\n    // - 1 through 2^448 - 1 for X448.\n    return modP(bytesToNumberLE(_u));\n  }\n  function decodeScalar(scalar: Uint8Array): bigint {\n    return bytesToNumberLE(adjustScalarBytes(copyBytes(abytes(scalar, fieldLen, 'scalar'))));\n  }\n  function scalarMult(scalar: Uint8Array, u: Uint8Array): Uint8Array {\n    const pu = montgomeryLadder(decodeU(u), decodeScalar(scalar));\n    // Some public keys are useless, of low-order. Curve author doesn't think\n    // it needs to be validated, but we do it nonetheless.\n    // https://cr.yp.to/ecdh.html#validate\n    if (pu === _0n) throw new Error('invalid private or public key received');\n    return encodeU(pu);\n  }\n  // Computes public key from private. By doing scalar multiplication of base point.\n  function scalarMultBase(scalar: Uint8Array): Uint8Array {\n    return scalarMult(scalar, GuBytes);\n  }\n  const getPublicKey = scalarMultBase;\n  const getSharedSecret = scalarMult;\n\n  // cswap from RFC7748 \"example code\"\n  function cswap(swap: bigint, x_2: bigint, x_3: bigint): { x_2: bigint; x_3: bigint } {\n    // dummy = mask(swap) AND (x_2 XOR x_3)\n    // Where mask(swap) is the all-1 or all-0 word of the same length as x_2\n    // and x_3, computed, e.g., as mask(swap) = 0 - swap.\n    const dummy = modP(swap * (x_2 - x_3));\n    x_2 = modP(x_2 - dummy); // x_2 = x_2 XOR dummy\n    x_3 = modP(x_3 + dummy); // x_3 = x_3 XOR dummy\n    return { x_2, x_3 };\n  }\n\n  /**\n   * Montgomery x-only multiplication ladder.\n   * @param pointU u coordinate (x) on Montgomery Curve 25519\n   * @param scalar by which the point would be multiplied\n   * @returns new Point on Montgomery curve\n   */\n  function montgomeryLadder(u: bigint, scalar: bigint): bigint {\n    aInRange('u', u, _0n, P);\n    aInRange('scalar', scalar, minScalar, maxScalar);\n    const k = scalar;\n    const x_1 = u;\n    let x_2 = _1n;\n    let z_2 = _0n;\n    let x_3 = u;\n    let z_3 = _1n;\n    let swap = _0n;\n    for (let t = BigInt(montgomeryBits - 1); t >= _0n; t--) {\n      const k_t = (k >> t) & _1n;\n      swap ^= k_t;\n      ({ x_2, x_3 } = cswap(swap, x_2, x_3));\n      ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));\n      swap = k_t;\n\n      const A = x_2 + z_2;\n      const AA = modP(A * A);\n      const B = x_2 - z_2;\n      const BB = modP(B * B);\n      const E = AA - BB;\n      const C = x_3 + z_3;\n      const D = x_3 - z_3;\n      const DA = modP(D * A);\n      const CB = modP(C * B);\n      const dacb = DA + CB;\n      const da_cb = DA - CB;\n      x_3 = modP(dacb * dacb);\n      z_3 = modP(x_1 * modP(da_cb * da_cb));\n      x_2 = modP(AA * BB);\n      z_2 = modP(E * (AA + modP(a24 * E)));\n    }\n    ({ x_2, x_3 } = cswap(swap, x_2, x_3));\n    ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));\n    const z2 = powPminus2(z_2); // `Fp.pow(x, P - _2n)` is much slower equivalent\n    return modP(x_2 * z2); // Return x_2 * (z_2^(p - 2))\n  }\n  const lengths = {\n    secretKey: fieldLen,\n    publicKey: fieldLen,\n    seed: fieldLen,\n  };\n  const randomSecretKey = (seed = randomBytes_(fieldLen)) => {\n    abytes(seed, lengths.seed, 'seed');\n    return seed;\n  };\n  const utils = { randomSecretKey };\n\n  return Object.freeze({\n    keygen: createKeygen(randomSecretKey, getPublicKey),\n    getSharedSecret,\n    getPublicKey,\n    scalarMult,\n    scalarMultBase,\n    utils,\n    GuBytes: GuBytes.slice(),\n    lengths,\n  }) satisfies CryptoKeys;\n}\n", "/**\n * ed25519 Twisted Edwards curve with following addons:\n * - X25519 ECDH\n * - Ristretto cofactor elimination\n * - Elligator hash-to-group / point indistinguishability\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { sha512 } from '@noble/hashes/sha2.js';\nimport { abytes, concatBytes, hexToBytes } from '@noble/hashes/utils.js';\nimport { type AffinePoint } from './abstract/curve.ts';\nimport {\n  eddsa,\n  edwards,\n  PrimeEdwardsPoint,\n  type EdDSA,\n  type EdDSAOpts,\n  type EdwardsOpts,\n  type EdwardsPoint,\n  type EdwardsPointCons,\n} from './abstract/edwards.ts';\nimport {\n  _DST_scalar,\n  createHasher,\n  expand_message_xmd,\n  type H2CDSTOpts,\n  type H2CHasher,\n  type H2CHasherBase,\n} from './abstract/hash-to-curve.ts';\nimport {\n  FpInvertBatch,\n  FpSqrtEven,\n  isNegativeLE,\n  mod,\n  pow2,\n  type IField,\n} from './abstract/modular.ts';\nimport { montgomery, type MontgomeryECDH } from './abstract/montgomery.ts';\nimport { createORPF, type OPRF } from './abstract/oprf.ts';\nimport { asciiToBytes, bytesToNumberLE, equalBytes } from './utils.ts';\n\n// prettier-ignore\nconst _0n = /* @__PURE__ */ BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = /* @__PURE__ */ BigInt(3);\n// prettier-ignore\nconst _5n = BigInt(5), _8n = BigInt(8);\n\n// P = 2n**255n - 19n\nconst ed25519_CURVE_p = BigInt(\n  '0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed'\n);\n// N = 2n**252n + 27742317777372353535851937790883648493n\n// a = Fp.create(BigInt(-1))\n// d = -121665/121666 a.k.a. Fp.neg(121665 * Fp.inv(121666))\nconst ed25519_CURVE: EdwardsOpts = /* @__PURE__ */ (() => ({\n  p: ed25519_CURVE_p,\n  n: BigInt('0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed'),\n  h: _8n,\n  a: BigInt('0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec'),\n  d: BigInt('0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3'),\n  Gx: BigInt('0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a'),\n  Gy: BigInt('0x6666666666666666666666666666666666666666666666666666666666666658'),\n}))();\n\nfunction ed25519_pow_2_252_3(x: bigint) {\n  // prettier-ignore\n  const _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);\n  const P = ed25519_CURVE_p;\n  const x2 = (x * x) % P;\n  const b2 = (x2 * x) % P; // x^3, 11\n  const b4 = (pow2(b2, _2n, P) * b2) % P; // x^15, 1111\n  const b5 = (pow2(b4, _1n, P) * x) % P; // x^31\n  const b10 = (pow2(b5, _5n, P) * b5) % P;\n  const b20 = (pow2(b10, _10n, P) * b10) % P;\n  const b40 = (pow2(b20, _20n, P) * b20) % P;\n  const b80 = (pow2(b40, _40n, P) * b40) % P;\n  const b160 = (pow2(b80, _80n, P) * b80) % P;\n  const b240 = (pow2(b160, _80n, P) * b80) % P;\n  const b250 = (pow2(b240, _10n, P) * b10) % P;\n  const pow_p_5_8 = (pow2(b250, _2n, P) * x) % P;\n  // ^ To pow to (p+3)/8, multiply it by x.\n  return { pow_p_5_8, b2 };\n}\n\nfunction adjustScalarBytes(bytes: Uint8Array): Uint8Array {\n  // Section 5: For X25519, in order to decode 32 random bytes as an integer scalar,\n  // set the three least significant bits of the first byte\n  bytes[0] &= 248; // 0b1111_1000\n  // and the most significant bit of the last to zero,\n  bytes[31] &= 127; // 0b0111_1111\n  // set the second most significant bit of the last byte to 1\n  bytes[31] |= 64; // 0b0100_0000\n  return bytes;\n}\n\n// \u221A(-1) aka \u221A(a) aka 2^((p-1)/4)\n// Fp.sqrt(Fp.neg(1))\nconst ED25519_SQRT_M1 = /* @__PURE__ */ BigInt(\n  '19681161376707505956807079304988542015446066515923890162744021073123829784752'\n);\n// sqrt(u/v)\nfunction uvRatio(u: bigint, v: bigint): { isValid: boolean; value: bigint } {\n  const P = ed25519_CURVE_p;\n  const v3 = mod(v * v * v, P); // v\u00B3\n  const v7 = mod(v3 * v3 * v, P); // v\u2077\n  // (p+3)/8 and (p-5)/8\n  const pow = ed25519_pow_2_252_3(u * v7).pow_p_5_8;\n  let x = mod(u * v3 * pow, P); // (uv\u00B3)(uv\u2077)^(p-5)/8\n  const vx2 = mod(v * x * x, P); // vx\u00B2\n  const root1 = x; // First root candidate\n  const root2 = mod(x * ED25519_SQRT_M1, P); // Second root candidate\n  const useRoot1 = vx2 === u; // If vx\u00B2 = u (mod p), x is a square root\n  const useRoot2 = vx2 === mod(-u, P); // If vx\u00B2 = -u, set x <-- x * 2^((p-1)/4)\n  const noRoot = vx2 === mod(-u * ED25519_SQRT_M1, P); // There is no valid root, vx\u00B2 = -u\u221A(-1)\n  if (useRoot1) x = root1;\n  if (useRoot2 || noRoot) x = root2; // We return root2 anyway, for const-time\n  if (isNegativeLE(x, P)) x = mod(-x, P);\n  return { isValid: useRoot1 || useRoot2, value: x };\n}\n\nconst ed25519_Point = /* @__PURE__ */ edwards(ed25519_CURVE, { uvRatio });\nconst Fp = /* @__PURE__ */ (() => ed25519_Point.Fp)();\nconst Fn = /* @__PURE__ */ (() => ed25519_Point.Fn)();\n\nfunction ed25519_domain(data: Uint8Array, ctx: Uint8Array, phflag: boolean) {\n  if (ctx.length > 255) throw new Error('Context is too big');\n  return concatBytes(\n    asciiToBytes('SigEd25519 no Ed25519 collisions'),\n    new Uint8Array([phflag ? 1 : 0, ctx.length]),\n    ctx,\n    data\n  );\n}\n\nfunction ed(opts: EdDSAOpts) {\n  return eddsa(ed25519_Point, sha512, Object.assign({ adjustScalarBytes }, opts));\n}\n\n/**\n * ed25519 curve with EdDSA signatures.\n * @example\n * ```js\n * import { ed25519 } from '@noble/curves/ed25519.js';\n * const { secretKey, publicKey } = ed25519.keygen();\n * // const publicKey = ed25519.getPublicKey(secretKey);\n * const msg = new TextEncoder().encode('hello noble');\n * const sig = ed25519.sign(msg, secretKey);\n * const isValid = ed25519.verify(sig, msg, pub); // ZIP215\n * // RFC8032 / FIPS 186-5\n * const isValid2 = ed25519.verify(sig, msg, pub, { zip215: false });\n * ```\n */\nexport const ed25519: EdDSA = /* @__PURE__ */ ed({});\n/** Context version of ed25519 (ctx for domain separation). See {@link ed25519} */\nexport const ed25519ctx: EdDSA = /* @__PURE__ */ ed({ domain: ed25519_domain });\n/** Prehashed version of ed25519. See {@link ed25519} */\nexport const ed25519ph: EdDSA = /* @__PURE__ */ ed({ domain: ed25519_domain, prehash: sha512 });\n\n/**\n * ECDH using curve25519 aka x25519.\n * @example\n * ```js\n * import { x25519 } from '@noble/curves/ed25519.js';\n * const alice = x25519.keygen();\n * const bob = x25519.keygen();\n * const shared = x25519.getSharedSecret(alice.secretKey, bob.publicKey);\n * ```\n */\nexport const x25519: MontgomeryECDH = /* @__PURE__ */ (() => {\n  const P = ed25519_CURVE_p;\n  return montgomery({\n    P,\n    type: 'x25519',\n    powPminus2: (x: bigint): bigint => {\n      // x^(p-2) aka x^(2^255-21)\n      const { pow_p_5_8, b2 } = ed25519_pow_2_252_3(x);\n      return mod(pow2(pow_p_5_8, _3n, P) * b2, P);\n    },\n    adjustScalarBytes,\n  });\n})();\n\n// Hash To Curve Elligator2 Map (NOTE: different from ristretto255 elligator)\n// NOTE: very important part is usage of FpSqrtEven for ELL2_C1_EDWARDS, since\n// SageMath returns different root first and everything falls apart\nconst ELL2_C1 = /* @__PURE__ */ (() => (ed25519_CURVE_p + _3n) / _8n)(); // 1. c1 = (q + 3) / 8       # Integer arithmetic\nconst ELL2_C2 = /* @__PURE__ */ (() => Fp.pow(_2n, ELL2_C1))(); // 2. c2 = 2^c1\nconst ELL2_C3 = /* @__PURE__ */ (() => Fp.sqrt(Fp.neg(Fp.ONE)))(); // 3. c3 = sqrt(-1)\n\n/**\n * RFC 9380 method `map_to_curve_elligator2_curve25519`. Experimental name: may be renamed later.\n * @private\n */\n// prettier-ignore\nexport function _map_to_curve_elligator2_curve25519(u: bigint): {\n  xMn: bigint, xMd: bigint, yMn: bigint, yMd: bigint\n} {\n  const ELL2_C4 = (ed25519_CURVE_p - _5n) / _8n; // 4. c4 = (q - 5) / 8       # Integer arithmetic\n  const ELL2_J = BigInt(486662);\n\n  let tv1 = Fp.sqr(u);          //  1.  tv1 = u^2\n  tv1 = Fp.mul(tv1, _2n);       //  2.  tv1 = 2 * tv1\n  let xd = Fp.add(tv1, Fp.ONE); //  3.   xd = tv1 + 1         # Nonzero: -1 is square (mod p), tv1 is not\n  let x1n = Fp.neg(ELL2_J);     //  4.  x1n = -J              # x1 = x1n / xd = -J / (1 + 2 * u^2)\n  let tv2 = Fp.sqr(xd);         //  5.  tv2 = xd^2\n  let gxd = Fp.mul(tv2, xd);    //  6.  gxd = tv2 * xd        # gxd = xd^3\n  let gx1 = Fp.mul(tv1, ELL2_J);//  7.  gx1 = J * tv1         # x1n + J * xd\n  gx1 = Fp.mul(gx1, x1n);       //  8.  gx1 = gx1 * x1n       # x1n^2 + J * x1n * xd\n  gx1 = Fp.add(gx1, tv2);       //  9.  gx1 = gx1 + tv2       # x1n^2 + J * x1n * xd + xd^2\n  gx1 = Fp.mul(gx1, x1n);       //  10. gx1 = gx1 * x1n       # x1n^3 + J * x1n^2 * xd + x1n * xd^2\n  let tv3 = Fp.sqr(gxd);        //  11. tv3 = gxd^2\n  tv2 = Fp.sqr(tv3);            //  12. tv2 = tv3^2           # gxd^4\n  tv3 = Fp.mul(tv3, gxd);       //  13. tv3 = tv3 * gxd       # gxd^3\n  tv3 = Fp.mul(tv3, gx1);       //  14. tv3 = tv3 * gx1       # gx1 * gxd^3\n  tv2 = Fp.mul(tv2, tv3);       //  15. tv2 = tv2 * tv3       # gx1 * gxd^7\n  let y11 = Fp.pow(tv2, ELL2_C4); //  16. y11 = tv2^c4        # (gx1 * gxd^7)^((p - 5) / 8)\n  y11 = Fp.mul(y11, tv3);       //  17. y11 = y11 * tv3       # gx1*gxd^3*(gx1*gxd^7)^((p-5)/8)\n  let y12 = Fp.mul(y11, ELL2_C3); //  18. y12 = y11 * c3\n  tv2 = Fp.sqr(y11);            //  19. tv2 = y11^2\n  tv2 = Fp.mul(tv2, gxd);       //  20. tv2 = tv2 * gxd\n  let e1 = Fp.eql(tv2, gx1);    //  21.  e1 = tv2 == gx1\n  let y1 = Fp.cmov(y12, y11, e1); //  22.  y1 = CMOV(y12, y11, e1)  # If g(x1) is square, this is its sqrt\n  let x2n = Fp.mul(x1n, tv1);   //  23. x2n = x1n * tv1       # x2 = x2n / xd = 2 * u^2 * x1n / xd\n  let y21 = Fp.mul(y11, u);     //  24. y21 = y11 * u\n  y21 = Fp.mul(y21, ELL2_C2);   //  25. y21 = y21 * c2\n  let y22 = Fp.mul(y21, ELL2_C3); //  26. y22 = y21 * c3\n  let gx2 = Fp.mul(gx1, tv1);   //  27. gx2 = gx1 * tv1       # g(x2) = gx2 / gxd = 2 * u^2 * g(x1)\n  tv2 = Fp.sqr(y21);            //  28. tv2 = y21^2\n  tv2 = Fp.mul(tv2, gxd);       //  29. tv2 = tv2 * gxd\n  let e2 = Fp.eql(tv2, gx2);    //  30.  e2 = tv2 == gx2\n  let y2 = Fp.cmov(y22, y21, e2); //  31.  y2 = CMOV(y22, y21, e2)  # If g(x2) is square, this is its sqrt\n  tv2 = Fp.sqr(y1);             //  32. tv2 = y1^2\n  tv2 = Fp.mul(tv2, gxd);       //  33. tv2 = tv2 * gxd\n  let e3 = Fp.eql(tv2, gx1);    //  34.  e3 = tv2 == gx1\n  let xn = Fp.cmov(x2n, x1n, e3); //  35.  xn = CMOV(x2n, x1n, e3)  # If e3, x = x1, else x = x2\n  let y = Fp.cmov(y2, y1, e3);  //  36.   y = CMOV(y2, y1, e3)    # If e3, y = y1, else y = y2\n  let e4 = Fp.isOdd!(y);         //  37.  e4 = sgn0(y) == 1        # Fix sign of y\n  y = Fp.cmov(y, Fp.neg(y), e3 !== e4); //  38.   y = CMOV(y, -y, e3 XOR e4)\n  return { xMn: xn, xMd: xd, yMn: y, yMd: _1n }; //  39. return (xn, xd, y, 1)\n}\n\nconst ELL2_C1_EDWARDS = /* @__PURE__ */ (() => FpSqrtEven(Fp, Fp.neg(BigInt(486664))))(); // sgn0(c1) MUST equal 0\nfunction map_to_curve_elligator2_edwards25519(u: bigint) {\n  const { xMn, xMd, yMn, yMd } = _map_to_curve_elligator2_curve25519(u); //  1.  (xMn, xMd, yMn, yMd) =\n  // map_to_curve_elligator2_curve25519(u)\n  let xn = Fp.mul(xMn, yMd); //  2.  xn = xMn * yMd\n  xn = Fp.mul(xn, ELL2_C1_EDWARDS); //  3.  xn = xn * c1\n  let xd = Fp.mul(xMd, yMn); //  4.  xd = xMd * yMn    # xn / xd = c1 * xM / yM\n  let yn = Fp.sub(xMn, xMd); //  5.  yn = xMn - xMd\n  let yd = Fp.add(xMn, xMd); //  6.  yd = xMn + xMd    # (n / d - 1) / (n / d + 1) = (n - d) / (n + d)\n  let tv1 = Fp.mul(xd, yd); //  7. tv1 = xd * yd\n  let e = Fp.eql(tv1, Fp.ZERO); //  8.   e = tv1 == 0\n  xn = Fp.cmov(xn, Fp.ZERO, e); //  9.  xn = CMOV(xn, 0, e)\n  xd = Fp.cmov(xd, Fp.ONE, e); //  10. xd = CMOV(xd, 1, e)\n  yn = Fp.cmov(yn, Fp.ONE, e); //  11. yn = CMOV(yn, 1, e)\n  yd = Fp.cmov(yd, Fp.ONE, e); //  12. yd = CMOV(yd, 1, e)\n  const [xd_inv, yd_inv] = FpInvertBatch(Fp, [xd, yd], true); // batch division\n  return { x: Fp.mul(xn, xd_inv), y: Fp.mul(yn, yd_inv) }; //  13. return (xn, xd, yn, yd)\n}\n\n/** Hashing to ed25519 points / field. RFC 9380 methods. */\nexport const ed25519_hasher: H2CHasher<EdwardsPointCons> = /* @__PURE__ */ (() =>\n  createHasher(\n    ed25519_Point,\n    (scalars: bigint[]) => map_to_curve_elligator2_edwards25519(scalars[0]),\n    {\n      DST: 'edwards25519_XMD:SHA-512_ELL2_RO_',\n      encodeDST: 'edwards25519_XMD:SHA-512_ELL2_NU_',\n      p: ed25519_CURVE_p,\n      m: 1,\n      k: 128,\n      expand: 'xmd',\n      hash: sha512,\n    }\n  ))();\n\n// \u221A(-1) aka \u221A(a) aka 2^((p-1)/4)\nconst SQRT_M1 = ED25519_SQRT_M1;\n// \u221A(ad - 1)\nconst SQRT_AD_MINUS_ONE = /* @__PURE__ */ BigInt(\n  '25063068953384623474111414158702152701244531502492656460079210482610430750235'\n);\n// 1 / \u221A(a-d)\nconst INVSQRT_A_MINUS_D = /* @__PURE__ */ BigInt(\n  '54469307008909316920995813868745141605393597292927456921205312896311721017578'\n);\n// 1-d\u00B2\nconst ONE_MINUS_D_SQ = /* @__PURE__ */ BigInt(\n  '1159843021668779879193775521855586647937357759715417654439879720876111806838'\n);\n// (d-1)\u00B2\nconst D_MINUS_ONE_SQ = /* @__PURE__ */ BigInt(\n  '40440834346308536858101042469323190826248399146238708352240133220865137265952'\n);\n// Calculates 1/\u221A(number)\nconst invertSqrt = (number: bigint) => uvRatio(_1n, number);\n\nconst MAX_255B = /* @__PURE__ */ BigInt(\n  '0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff'\n);\nconst bytes255ToNumberLE = (bytes: Uint8Array) => Fp.create(bytesToNumberLE(bytes) & MAX_255B);\n\n/**\n * Computes Elligator map for Ristretto255.\n * Described in [RFC9380](https://www.rfc-editor.org/rfc/rfc9380#appendix-B) and on\n * the [website](https://ristretto.group/formulas/elligator.html).\n */\nfunction calcElligatorRistrettoMap(r0: bigint): EdwardsPoint {\n  const { d } = ed25519_CURVE;\n  const P = ed25519_CURVE_p;\n  const mod = (n: bigint) => Fp.create(n);\n  const r = mod(SQRT_M1 * r0 * r0); // 1\n  const Ns = mod((r + _1n) * ONE_MINUS_D_SQ); // 2\n  let c = BigInt(-1); // 3\n  const D = mod((c - d * r) * mod(r + d)); // 4\n  let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D); // 5\n  let s_ = mod(s * r0); // 6\n  if (!isNegativeLE(s_, P)) s_ = mod(-s_);\n  if (!Ns_D_is_sq) s = s_; // 7\n  if (!Ns_D_is_sq) c = r; // 8\n  const Nt = mod(c * (r - _1n) * D_MINUS_ONE_SQ - D); // 9\n  const s2 = s * s;\n  const W0 = mod((s + s) * D); // 10\n  const W1 = mod(Nt * SQRT_AD_MINUS_ONE); // 11\n  const W2 = mod(_1n - s2); // 12\n  const W3 = mod(_1n + s2); // 13\n  return new ed25519_Point(mod(W0 * W3), mod(W2 * W1), mod(W1 * W3), mod(W0 * W2));\n}\n\n/**\n * Wrapper over Edwards Point for ristretto255.\n *\n * Each ed25519/EdwardsPoint has 8 different equivalent points. This can be\n * a source of bugs for protocols like ring signatures. Ristretto was created to solve this.\n * Ristretto point operates in X:Y:Z:T extended coordinates like EdwardsPoint,\n * but it should work in its own namespace: do not combine those two.\n * See [RFC9496](https://www.rfc-editor.org/rfc/rfc9496).\n */\nclass _RistrettoPoint extends PrimeEdwardsPoint<_RistrettoPoint> {\n  // Do NOT change syntax: the following gymnastics is done,\n  // because typescript strips comments, which makes bundlers disable tree-shaking.\n  // prettier-ignore\n  static BASE: _RistrettoPoint =\n    /* @__PURE__ */ (() => new _RistrettoPoint(ed25519_Point.BASE))();\n  // prettier-ignore\n  static ZERO: _RistrettoPoint =\n    /* @__PURE__ */ (() => new _RistrettoPoint(ed25519_Point.ZERO))();\n  // prettier-ignore\n  static Fp: IField<bigint> =\n    /* @__PURE__ */ (() => Fp)();\n  // prettier-ignore\n  static Fn: IField<bigint> =\n    /* @__PURE__ */ (() => Fn)();\n\n  constructor(ep: EdwardsPoint) {\n    super(ep);\n  }\n\n  static fromAffine(ap: AffinePoint<bigint>): _RistrettoPoint {\n    return new _RistrettoPoint(ed25519_Point.fromAffine(ap));\n  }\n\n  protected assertSame(other: _RistrettoPoint): void {\n    if (!(other instanceof _RistrettoPoint)) throw new Error('RistrettoPoint expected');\n  }\n\n  protected init(ep: EdwardsPoint): _RistrettoPoint {\n    return new _RistrettoPoint(ep);\n  }\n\n  static fromBytes(bytes: Uint8Array): _RistrettoPoint {\n    abytes(bytes, 32);\n    const { a, d } = ed25519_CURVE;\n    const P = ed25519_CURVE_p;\n    const mod = (n: bigint) => Fp.create(n);\n    const s = bytes255ToNumberLE(bytes);\n    // 1. Check that s_bytes is the canonical encoding of a field element, or else abort.\n    // 3. Check that s is non-negative, or else abort\n    if (!equalBytes(Fp.toBytes(s), bytes) || isNegativeLE(s, P))\n      throw new Error('invalid ristretto255 encoding 1');\n    const s2 = mod(s * s);\n    const u1 = mod(_1n + a * s2); // 4 (a is -1)\n    const u2 = mod(_1n - a * s2); // 5\n    const u1_2 = mod(u1 * u1);\n    const u2_2 = mod(u2 * u2);\n    const v = mod(a * d * u1_2 - u2_2); // 6\n    const { isValid, value: I } = invertSqrt(mod(v * u2_2)); // 7\n    const Dx = mod(I * u2); // 8\n    const Dy = mod(I * Dx * v); // 9\n    let x = mod((s + s) * Dx); // 10\n    if (isNegativeLE(x, P)) x = mod(-x); // 10\n    const y = mod(u1 * Dy); // 11\n    const t = mod(x * y); // 12\n    if (!isValid || isNegativeLE(t, P) || y === _0n)\n      throw new Error('invalid ristretto255 encoding 2');\n    return new _RistrettoPoint(new ed25519_Point(x, y, _1n, t));\n  }\n\n  /**\n   * Converts ristretto-encoded string to ristretto point.\n   * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-decode).\n   * @param hex Ristretto-encoded 32 bytes. Not every 32-byte string is valid ristretto encoding\n   */\n  static fromHex(hex: string): _RistrettoPoint {\n    return _RistrettoPoint.fromBytes(hexToBytes(hex));\n  }\n\n  /**\n   * Encodes ristretto point to Uint8Array.\n   * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-encode).\n   */\n  toBytes(): Uint8Array {\n    let { X, Y, Z, T } = this.ep;\n    const P = ed25519_CURVE_p;\n    const mod = (n: bigint) => Fp.create(n);\n    const u1 = mod(mod(Z + Y) * mod(Z - Y)); // 1\n    const u2 = mod(X * Y); // 2\n    // Square root always exists\n    const u2sq = mod(u2 * u2);\n    const { value: invsqrt } = invertSqrt(mod(u1 * u2sq)); // 3\n    const D1 = mod(invsqrt * u1); // 4\n    const D2 = mod(invsqrt * u2); // 5\n    const zInv = mod(D1 * D2 * T); // 6\n    let D: bigint; // 7\n    if (isNegativeLE(T * zInv, P)) {\n      let _x = mod(Y * SQRT_M1);\n      let _y = mod(X * SQRT_M1);\n      X = _x;\n      Y = _y;\n      D = mod(D1 * INVSQRT_A_MINUS_D);\n    } else {\n      D = D2; // 8\n    }\n    if (isNegativeLE(X * zInv, P)) Y = mod(-Y); // 9\n    let s = mod((Z - Y) * D); // 10 (check footer's note, no sqrt(-a))\n    if (isNegativeLE(s, P)) s = mod(-s);\n    return Fp.toBytes(s); // 11\n  }\n\n  /**\n   * Compares two Ristretto points.\n   * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-equals).\n   */\n  equals(other: _RistrettoPoint): boolean {\n    this.assertSame(other);\n    const { X: X1, Y: Y1 } = this.ep;\n    const { X: X2, Y: Y2 } = other.ep;\n    const mod = (n: bigint) => Fp.create(n);\n    // (x1 * y2 == y1 * x2) | (y1 * y2 == x1 * x2)\n    const one = mod(X1 * Y2) === mod(Y1 * X2);\n    const two = mod(Y1 * Y2) === mod(X1 * X2);\n    return one || two;\n  }\n\n  is0(): boolean {\n    return this.equals(_RistrettoPoint.ZERO);\n  }\n}\n\nexport const ristretto255: {\n  Point: typeof _RistrettoPoint;\n} = { Point: _RistrettoPoint };\n\n/** Hashing to ristretto255 points / field. RFC 9380 methods. */\nexport const ristretto255_hasher: H2CHasherBase<typeof _RistrettoPoint> = {\n  Point: _RistrettoPoint,\n  /**\n  * Spec: https://www.rfc-editor.org/rfc/rfc9380.html#name-hashing-to-ristretto255. Caveats:\n  * * There are no test vectors\n  * * encodeToCurve / mapToCurve is undefined\n  * * mapToCurve would be `calcElligatorRistrettoMap(scalars[0])`, not ristretto255_map!\n  * * hashToScalar is undefined too, so we just use OPRF implementation\n  * * We cannot re-use 'createHasher', because ristretto255_map is different algorithm/RFC\n    (os2ip -> bytes255ToNumberLE)\n  * * mapToCurve == calcElligatorRistrettoMap, hashToCurve == ristretto255_map\n  * * hashToScalar is undefined in RFC9380 for ristretto, we are using version from OPRF here, using bytes255ToNumblerLE will create different result if we use bytes255ToNumberLE as os2ip\n  * * current version is closest to spec.\n  */\n  hashToCurve(msg: Uint8Array, options?: H2CDSTOpts): _RistrettoPoint {\n    // == 'hash_to_ristretto255'\n    const DST = options?.DST || 'ristretto255_XMD:SHA-512_R255MAP_RO_';\n    const xmd = expand_message_xmd(msg, DST, 64, sha512);\n    // NOTE: RFC 9380 incorrectly calls this function 'ristretto255_map', in RFC 9496 map was function inside (per point)\n    // That also lead to confustion that ristretto255_map is mapToCurve (it is not! it is old hashToCurve)\n    return ristretto255_hasher.deriveToCurve!(xmd);\n  },\n  hashToScalar(msg: Uint8Array, options: H2CDSTOpts = { DST: _DST_scalar }) {\n    const xmd = expand_message_xmd(msg, options.DST, 64, sha512);\n    return Fn.create(bytesToNumberLE(xmd));\n  },\n  /**\n   * HashToCurve-like construction based on RFC 9496 (Element Derivation).\n   * Converts 64 uniform random bytes into a curve point.\n   *\n   * WARNING: This represents an older hash-to-curve construction, preceding the finalization of RFC 9380.\n   * It was later reused as a component in the newer `hash_to_ristretto255` function defined in RFC 9380.\n   */\n  deriveToCurve(bytes: Uint8Array): _RistrettoPoint {\n    // https://www.rfc-editor.org/rfc/rfc9496.html#name-element-derivation\n    abytes(bytes, 64);\n    const r1 = bytes255ToNumberLE(bytes.subarray(0, 32));\n    const R1 = calcElligatorRistrettoMap(r1);\n    const r2 = bytes255ToNumberLE(bytes.subarray(32, 64));\n    const R2 = calcElligatorRistrettoMap(r2);\n    return new _RistrettoPoint(R1.add(R2));\n  },\n};\n\n/** ristretto255 OPRF, defined in RFC 9497. */\nexport const ristretto255_oprf: OPRF = /* @__PURE__ */ (() =>\n  createORPF({\n    name: 'ristretto255-SHA512',\n    Point: _RistrettoPoint,\n    hash: sha512,\n    hashToGroup: ristretto255_hasher.hashToCurve,\n    hashToScalar: ristretto255_hasher.hashToScalar,\n  }))();\n\n/**\n * Weird / bogus points, useful for debugging.\n * All 8 ed25519 points of 8-torsion subgroup can be generated from the point\n * T = `26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05`.\n * \u27E8T\u27E9 = { O, T, 2T, 3T, 4T, 5T, 6T, 7T }\n */\nexport const ED25519_TORSION_SUBGROUP: string[] = [\n  '0100000000000000000000000000000000000000000000000000000000000000',\n  'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a',\n  '0000000000000000000000000000000000000000000000000000000000000080',\n  '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05',\n  'ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f',\n  '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85',\n  '0000000000000000000000000000000000000000000000000000000000000000',\n  'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa',\n];\n", "/**\n * Utilities for hex, bytes, CSPRNG.\n * @module\n */\n/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */\n\n/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */\nexport function isBytes(a: unknown): a is Uint8Array {\n  return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n\n/** Asserts something is boolean. */\nexport function abool(b: boolean): void {\n  if (typeof b !== 'boolean') throw new Error(`boolean expected, not ${b}`);\n}\n\n/** Asserts something is positive integer. */\nexport function anumber(n: number): void {\n  if (!Number.isSafeInteger(n) || n < 0) throw new Error('positive integer expected, got ' + n);\n}\n\n/** Asserts something is Uint8Array. */\nexport function abytes(value: Uint8Array, length?: number, title: string = ''): Uint8Array {\n  const bytes = isBytes(value);\n  const len = value?.length;\n  const needsLen = length !== undefined;\n  if (!bytes || (needsLen && len !== length)) {\n    const prefix = title && `\"${title}\" `;\n    const ofLen = needsLen ? ` of length ${length}` : '';\n    const got = bytes ? `length=${len}` : `type=${typeof value}`;\n    throw new Error(prefix + 'expected Uint8Array' + ofLen + ', got ' + got);\n  }\n  return value;\n}\n\n/** Asserts a hash instance has not been destroyed / finished */\nexport function aexists(instance: any, checkFinished = true): void {\n  if (instance.destroyed) throw new Error('Hash instance has been destroyed');\n  if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');\n}\n\n/** Asserts output is properly-sized byte array */\nexport function aoutput(out: any, instance: any): void {\n  abytes(out, undefined, 'output');\n  const min = instance.outputLen;\n  if (out.length < min) {\n    throw new Error('digestInto() expects output buffer of length at least ' + min);\n  }\n}\n\nexport type IHash = {\n  (data: string | Uint8Array): Uint8Array;\n  blockLen: number;\n  outputLen: number;\n  create: any;\n};\n\n/** Generic type encompassing 8/16/32-byte arrays - but not 64-byte. */\n// prettier-ignore\nexport type TypedArray = Int8Array | Uint8ClampedArray | Uint8Array |\n  Uint16Array | Int16Array | Uint32Array | Int32Array;\n\n/** Cast u8 / u16 / u32 to u8. */\nexport function u8(arr: TypedArray): Uint8Array {\n  return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n\n/** Cast u8 / u16 / u32 to u32. */\nexport function u32(arr: TypedArray): Uint32Array {\n  return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n}\n\n/** Zeroize a byte array. Warning: JS provides no guarantees. */\nexport function clean(...arrays: TypedArray[]): void {\n  for (let i = 0; i < arrays.length; i++) {\n    arrays[i].fill(0);\n  }\n}\n\n/** Create DataView of an array for easy byte-level manipulation. */\nexport function createView(arr: TypedArray): DataView {\n  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n\n/** Is current platform little-endian? Most are. Big-Endian platform: IBM */\nexport const isLE: boolean = /* @__PURE__ */ (() =>\n  new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();\n\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\nconst hasHexBuiltin: boolean = /* @__PURE__ */ (() =>\n  // @ts-ignore\n  typeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function')();\n\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) =>\n  i.toString(16).padStart(2, '0')\n);\n\n/**\n * Convert byte array to hex string. Uses built-in function, when available.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes: Uint8Array): string {\n  abytes(bytes);\n  // @ts-ignore\n  if (hasHexBuiltin) return bytes.toHex();\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\n\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 } as const;\nfunction asciiToBase16(ch: number): number | undefined {\n  if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0; // '2' => 50-48\n  if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n  if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n  return;\n}\n\n/**\n * Convert hex string to byte array. Uses built-in function, when available.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  // @ts-ignore\n  if (hasHexBuiltin) return Uint8Array.fromHex(hex);\n  const hl = hex.length;\n  const al = hl / 2;\n  if (hl % 2) throw new Error('hex string expected, got unpadded hex of length ' + hl);\n  const array = new Uint8Array(al);\n  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n    const n1 = asciiToBase16(hex.charCodeAt(hi));\n    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n    if (n1 === undefined || n2 === undefined) {\n      const char = hex[hi] + hex[hi + 1];\n      throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n    }\n    array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n  }\n  return array;\n}\n\n// Used in micro\nexport function hexToNumber(hex: string): bigint {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  return BigInt(hex === '' ? '0' : '0x' + hex); // Big Endian\n}\n\n// Used in ff1\n// BE: Big Endian, LE: Little Endian\nexport function bytesToNumberBE(bytes: Uint8Array): bigint {\n  return hexToNumber(bytesToHex(bytes));\n}\n\n// Used in micro, ff1\nexport function numberToBytesBE(n: number | bigint, len: number): Uint8Array {\n  return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\n\n// Global symbols, but ts doesn't see them: https://github.com/microsoft/TypeScript/issues/31535\ndeclare const TextEncoder: any;\ndeclare const TextDecoder: any;\n\n/**\n * Converts string to bytes using UTF8 encoding.\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str: string): Uint8Array {\n  if (typeof str !== 'string') throw new Error('string expected');\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n\n/**\n * Converts bytes to string using UTF8 encoding.\n * @example bytesToUtf8(new Uint8Array([97, 98, 99])) // 'abc'\n */\nexport function bytesToUtf8(bytes: Uint8Array): string {\n  return new TextDecoder().decode(bytes);\n}\n\n/**\n * Checks if two U8A use same underlying buffer and overlaps.\n * This is invalid and can corrupt data.\n */\nexport function overlapBytes(a: Uint8Array, b: Uint8Array): boolean {\n  return (\n    a.buffer === b.buffer && // best we can do, may fail with an obscure Proxy\n    a.byteOffset < b.byteOffset + b.byteLength && // a starts before b end\n    b.byteOffset < a.byteOffset + a.byteLength // b starts before a end\n  );\n}\n\n/**\n * If input and output overlap and input starts before output, we will overwrite end of input before\n * we start processing it, so this is not supported for most ciphers (except chacha/salse, which designed with this)\n */\nexport function complexOverlapBytes(input: Uint8Array, output: Uint8Array): void {\n  // This is very cursed. It works somehow, but I'm completely unsure,\n  // reasoning about overlapping aligned windows is very hard.\n  if (overlapBytes(input, output) && input.byteOffset < output.byteOffset)\n    throw new Error('complex overlap of input and output is not supported');\n}\n\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  let sum = 0;\n  for (let i = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    abytes(a);\n    sum += a.length;\n  }\n  const res = new Uint8Array(sum);\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    res.set(a, pad);\n    pad += a.length;\n  }\n  return res;\n}\n\n// Used in ARX only\ntype EmptyObj = {};\nexport function checkOpts<T1 extends EmptyObj, T2 extends EmptyObj>(\n  defaults: T1,\n  opts: T2\n): T1 & T2 {\n  if (opts == null || typeof opts !== 'object') throw new Error('options must be defined');\n  const merged = Object.assign(defaults, opts);\n  return merged as T1 & T2;\n}\n\n/** Compares 2 uint8array-s in kinda constant time. */\nexport function equalBytes(a: Uint8Array, b: Uint8Array): boolean {\n  if (a.length !== b.length) return false;\n  let diff = 0;\n  for (let i = 0; i < a.length; i++) diff |= a[i] ^ b[i];\n  return diff === 0;\n}\n\n// TODO: remove\nexport interface IHash2 {\n  blockLen: number; // Bytes per block\n  outputLen: number; // Bytes in output\n  update(buf: string | Uint8Array): this;\n  // Writes digest into buf\n  digestInto(buf: Uint8Array): void;\n  digest(): Uint8Array;\n  /**\n   * Resets internal state. Makes Hash instance unusable.\n   * Reset is impossible for keyed hashes if key is consumed into state. If digest is not consumed\n   * by user, they will need to manually call `destroy()` when zeroing is necessary.\n   */\n  destroy(): void;\n}\n\n// This will allow to re-use with composable things like packed & base encoders\n// Also, we probably can make tags composable\n\n/** Sync cipher: takes byte array and returns byte array. */\nexport type Cipher = {\n  encrypt(plaintext: Uint8Array): Uint8Array;\n  decrypt(ciphertext: Uint8Array): Uint8Array;\n};\n\n/** Async cipher e.g. from built-in WebCrypto. */\nexport type AsyncCipher = {\n  encrypt(plaintext: Uint8Array): Promise<Uint8Array>;\n  decrypt(ciphertext: Uint8Array): Promise<Uint8Array>;\n};\n\n/** Cipher with `output` argument which can optimize by doing 1 less allocation. */\nexport type CipherWithOutput = Cipher & {\n  encrypt(plaintext: Uint8Array, output?: Uint8Array): Uint8Array;\n  decrypt(ciphertext: Uint8Array, output?: Uint8Array): Uint8Array;\n};\n\n/**\n * Params are outside of return type, so it is accessible before calling constructor.\n * If function support multiple nonceLength's, we return the best one.\n */\nexport type CipherParams = {\n  blockSize: number;\n  nonceLength?: number;\n  tagLength?: number;\n  varSizeNonce?: boolean;\n};\n/** ARX cipher, like salsa or chacha. */\nexport type ARXCipher = ((\n  key: Uint8Array,\n  nonce: Uint8Array,\n  AAD?: Uint8Array\n) => CipherWithOutput) & {\n  blockSize: number;\n  nonceLength: number;\n  tagLength: number;\n};\nexport type CipherCons<T extends any[]> = (key: Uint8Array, ...args: T) => Cipher;\n/**\n * Wraps a cipher: validates args, ensures encrypt() can only be called once.\n * @__NO_SIDE_EFFECTS__\n */\nexport const wrapCipher = <C extends CipherCons<any>, P extends CipherParams>(\n  params: P,\n  constructor: C\n): C & P => {\n  function wrappedCipher(key: Uint8Array, ...args: any[]): CipherWithOutput {\n    // Validate key\n    abytes(key, undefined, 'key');\n\n    // Big-Endian hardware is rare. Just in case someone still decides to run ciphers:\n    if (!isLE) throw new Error('Non little-endian hardware is not yet supported');\n\n    // Validate nonce if nonceLength is present\n    if (params.nonceLength !== undefined) {\n      const nonce = args[0];\n      abytes(nonce, params.varSizeNonce ? undefined : params.nonceLength, 'nonce');\n    }\n\n    // Validate AAD if tagLength present\n    const tagl = params.tagLength;\n    if (tagl && args[1] !== undefined) abytes(args[1], undefined, 'AAD');\n\n    const cipher = constructor(key, ...args);\n    const checkOutput = (fnLength: number, output?: Uint8Array) => {\n      if (output !== undefined) {\n        if (fnLength !== 2) throw new Error('cipher output not supported');\n        abytes(output, undefined, 'output');\n      }\n    };\n    // Create wrapped cipher with validation and single-use encryption\n    let called = false;\n    const wrCipher = {\n      encrypt(data: Uint8Array, output?: Uint8Array) {\n        if (called) throw new Error('cannot encrypt() twice with same key + nonce');\n        called = true;\n        abytes(data);\n        checkOutput(cipher.encrypt.length, output);\n        return (cipher as CipherWithOutput).encrypt(data, output);\n      },\n      decrypt(data: Uint8Array, output?: Uint8Array) {\n        abytes(data);\n        if (tagl && data.length < tagl)\n          throw new Error('\"ciphertext\" expected length bigger than tagLength=' + tagl);\n        checkOutput(cipher.decrypt.length, output);\n        return (cipher as CipherWithOutput).decrypt(data, output);\n      },\n    };\n\n    return wrCipher;\n  }\n\n  Object.assign(wrappedCipher, params);\n  return wrappedCipher as C & P;\n};\n\n/** Represents salsa / chacha stream. */\nexport type XorStream = (\n  key: Uint8Array,\n  nonce: Uint8Array,\n  data: Uint8Array,\n  output?: Uint8Array,\n  counter?: number\n) => Uint8Array;\n\n/**\n * By default, returns u8a of length.\n * When out is available, it checks it for validity and uses it.\n */\nexport function getOutput(\n  expectedLength: number,\n  out?: Uint8Array,\n  onlyAligned = true\n): Uint8Array {\n  if (out === undefined) return new Uint8Array(expectedLength);\n  if (out.length !== expectedLength)\n    throw new Error(\n      '\"output\" expected Uint8Array of length ' + expectedLength + ', got: ' + out.length\n    );\n  if (onlyAligned && !isAligned32(out)) throw new Error('invalid output, must be aligned');\n  return out;\n}\n\nexport function u64Lengths(dataLength: number, aadLength: number, isLE: boolean): Uint8Array {\n  abool(isLE);\n  const num = new Uint8Array(16);\n  const view = createView(num);\n  view.setBigUint64(0, BigInt(aadLength), isLE);\n  view.setBigUint64(8, BigInt(dataLength), isLE);\n  return num;\n}\n\n// Is byte array aligned to 4 byte offset (u32)?\nexport function isAligned32(bytes: Uint8Array): boolean {\n  return bytes.byteOffset % 4 === 0;\n}\n\n// copy bytes to new u8a (aligned). Because Buffer.slice is broken.\nexport function copyBytes(bytes: Uint8Array): Uint8Array {\n  return Uint8Array.from(bytes);\n}\n\n/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */\nexport function randomBytes(bytesLength = 32): Uint8Array {\n  const cr = typeof globalThis === 'object' ? (globalThis as any).crypto : null;\n  if (typeof cr?.getRandomValues !== 'function')\n    throw new Error('crypto.getRandomValues must be defined');\n  return cr.getRandomValues(new Uint8Array(bytesLength));\n}\n\n/**\n * The pseudorandom number generator doesn't wipe current state:\n * instead, it generates new one based on previous state + entropy.\n * Not reseed/rekey, since AES CTR DRBG does rekey on each randomBytes,\n * which is in fact `reseed`, since it changes counter too.\n */\nexport interface PRG {\n  addEntropy(seed: Uint8Array): void;\n  randomBytes(length: number): Uint8Array;\n  clean(): void;\n}\n\ntype RemoveNonceInner<T extends any[], Ret> = ((...args: T) => Ret) extends (\n  arg0: any,\n  arg1: any,\n  ...rest: infer R\n) => any\n  ? (key: Uint8Array, ...args: R) => Ret\n  : never;\n\nexport type RemoveNonce<T extends (...args: any) => any> = RemoveNonceInner<\n  Parameters<T>,\n  ReturnType<T>\n>;\nexport type CipherWithNonce = ((\n  key: Uint8Array,\n  nonce: Uint8Array,\n  ...args: any[]\n) => Cipher | AsyncCipher) & {\n  nonceLength: number;\n};\n\n/**\n * Uses CSPRG for nonce, nonce injected in ciphertext.\n * For `encrypt`, a `nonceBytes`-length buffer is fetched from CSPRNG and\n * prepended to encrypted ciphertext. For `decrypt`, first `nonceBytes` of ciphertext\n * are treated as nonce.\n *\n * NOTE: Under the same key, using random nonces (e.g. `managedNonce`) with AES-GCM and ChaCha\n * should be limited to `2**23` (8M) messages to get a collision chance of `2**-50`. Stretching to  * `2**32` (4B) messages, chance would become `2**-33` - still negligible, but creeping up.\n * @example\n * const gcm = managedNonce(aes.gcm);\n * const ciphr = gcm(key).encrypt(data);\n * const plain = gcm(key).decrypt(ciph);\n */\nexport function managedNonce<T extends CipherWithNonce>(\n  fn: T,\n  randomBytes_: typeof randomBytes = randomBytes\n): RemoveNonce<T> {\n  const { nonceLength } = fn;\n  anumber(nonceLength);\n  const addNonce = (nonce: Uint8Array, ciphertext: Uint8Array) => {\n    const out = concatBytes(nonce, ciphertext);\n    ciphertext.fill(0);\n    return out;\n  };\n  // NOTE: we cannot support DST here, it would be mistake:\n  // - we don't know how much dst length cipher requires\n  // - nonce may unalign dst and break everything\n  // - we create new u8a anyway (concatBytes)\n  // - previously we passed all args to cipher, but that was mistake!\n  return ((key: Uint8Array, ...args: any[]): any => ({\n    encrypt(plaintext: Uint8Array) {\n      abytes(plaintext);\n      const nonce = randomBytes_(nonceLength);\n      const encrypted = fn(key, nonce, ...args).encrypt(plaintext);\n      // @ts-ignore\n      if (encrypted instanceof Promise) return encrypted.then((ct) => addNonce(nonce, ct));\n      return addNonce(nonce, encrypted);\n    },\n    decrypt(ciphertext: Uint8Array) {\n      abytes(ciphertext);\n      const nonce = ciphertext.subarray(0, nonceLength);\n      const decrypted = ciphertext.subarray(nonceLength);\n      return fn(key, nonce, ...args).decrypt(decrypted);\n    },\n  })) as RemoveNonce<T>;\n}\n", "/**\n * Basic utils for ARX (add-rotate-xor) salsa and chacha ciphers.\n\nRFC8439 requires multi-step cipher stream, where\nauthKey starts with counter: 0, actual msg with counter: 1.\n\nFor this, we need a way to re-use nonce / counter:\n\n    const counter = new Uint8Array(4);\n    chacha(..., counter, ...); // counter is now 1\n    chacha(..., counter, ...); // counter is now 2\n\nThis is complicated:\n\n- 32-bit counters are enough, no need for 64-bit: max ArrayBuffer size in JS is 4GB\n- Original papers don't allow mutating counters\n- Counter overflow is undefined [^1]\n- Idea A: allow providing (nonce | counter) instead of just nonce, re-use it\n- Caveat: Cannot be re-used through all cases:\n- * chacha has (counter | nonce)\n- * xchacha has (nonce16 | counter | nonce16)\n- Idea B: separate nonce / counter and provide separate API for counter re-use\n- Caveat: there are different counter sizes depending on an algorithm.\n- salsa & chacha also differ in structures of key & sigma:\n  salsa20:      s[0] | k(4) | s[1] | nonce(2) | cnt(2) | s[2] | k(4) | s[3]\n  chacha:       s(4) | k(8) | cnt(1) | nonce(3)\n  chacha20orig: s(4) | k(8) | cnt(2) | nonce(2)\n- Idea C: helper method such as `setSalsaState(key, nonce, sigma, data)`\n- Caveat: we can't re-use counter array\n\nxchacha [^2] uses the subkey and remaining 8 byte nonce with ChaCha20 as normal\n(prefixed by 4 NUL bytes, since [RFC8439] specifies a 12-byte nonce).\n\n[^1]: https://mailarchive.ietf.org/arch/msg/cfrg/gsOnTJzcbgG6OqD8Sc0GO5aR_tU/\n[^2]: https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-xchacha#appendix-A.2\n\n * @module\n */\nimport {\n  type PRG,\n  type XorStream,\n  abool,\n  abytes,\n  anumber,\n  checkOpts,\n  clean,\n  copyBytes,\n  randomBytes,\n  u32,\n} from './utils.ts';\n\n// Replaces `TextEncoder`, which is not available in all environments\nconst encodeStr = (str: string) => Uint8Array.from(str.split(''), (c) => c.charCodeAt(0));\nconst sigma16 = encodeStr('expand 16-byte k');\nconst sigma32 = encodeStr('expand 32-byte k');\nconst sigma16_32 = u32(sigma16);\nconst sigma32_32 = u32(sigma32);\n\n/** Rotate left. */\nexport function rotl(a: number, b: number): number {\n  return (a << b) | (a >>> (32 - b));\n}\n\n/** Ciphers must use u32 for efficiency. */\nexport type CipherCoreFn = (\n  sigma: Uint32Array,\n  key: Uint32Array,\n  nonce: Uint32Array,\n  output: Uint32Array,\n  counter: number,\n  rounds?: number\n) => void;\n\n/** Method which extends key + short nonce into larger nonce / diff key. */\nexport type ExtendNonceFn = (\n  sigma: Uint32Array,\n  key: Uint32Array,\n  input: Uint32Array,\n  output: Uint32Array\n) => void;\n\n/** ARX cipher options.\n * * `allowShortKeys` for 16-byte keys\n * * `counterLength` in bytes\n * * `counterRight`: right: `nonce|counter`; left: `counter|nonce`\n * */\nexport type CipherOpts = {\n  allowShortKeys?: boolean; // Original salsa / chacha allow 16-byte keys\n  extendNonceFn?: ExtendNonceFn;\n  counterLength?: number;\n  counterRight?: boolean;\n  rounds?: number;\n};\n\n// Is byte array aligned to 4 byte offset (u32)?\nfunction isAligned32(b: Uint8Array) {\n  return b.byteOffset % 4 === 0;\n}\n\n// Salsa and Chacha block length is always 512-bit\nconst BLOCK_LEN = 64;\nconst BLOCK_LEN32 = 16;\n\n// new Uint32Array([2**32])   // => Uint32Array(1) [ 0 ]\n// new Uint32Array([2**32-1]) // => Uint32Array(1) [ 4294967295 ]\nconst MAX_COUNTER = 2 ** 32 - 1;\n\nconst U32_EMPTY = Uint32Array.of();\nfunction runCipher(\n  core: CipherCoreFn,\n  sigma: Uint32Array,\n  key: Uint32Array,\n  nonce: Uint32Array,\n  data: Uint8Array,\n  output: Uint8Array,\n  counter: number,\n  rounds: number\n): void {\n  const len = data.length;\n  const block = new Uint8Array(BLOCK_LEN);\n  const b32 = u32(block);\n  // Make sure that buffers aligned to 4 bytes\n  const isAligned = isAligned32(data) && isAligned32(output);\n  const d32 = isAligned ? u32(data) : U32_EMPTY;\n  const o32 = isAligned ? u32(output) : U32_EMPTY;\n  for (let pos = 0; pos < len; counter++) {\n    core(sigma, key, nonce, b32, counter, rounds);\n    if (counter >= MAX_COUNTER) throw new Error('arx: counter overflow');\n    const take = Math.min(BLOCK_LEN, len - pos);\n    // aligned to 4 bytes\n    if (isAligned && take === BLOCK_LEN) {\n      const pos32 = pos / 4;\n      if (pos % 4 !== 0) throw new Error('arx: invalid block position');\n      for (let j = 0, posj: number; j < BLOCK_LEN32; j++) {\n        posj = pos32 + j;\n        o32[posj] = d32[posj] ^ b32[j];\n      }\n      pos += BLOCK_LEN;\n      continue;\n    }\n    for (let j = 0, posj; j < take; j++) {\n      posj = pos + j;\n      output[posj] = data[posj] ^ block[j];\n    }\n    pos += take;\n  }\n}\n\n/** Creates ARX-like (ChaCha, Salsa) cipher stream from core function. */\nexport function createCipher(core: CipherCoreFn, opts: CipherOpts): XorStream {\n  const { allowShortKeys, extendNonceFn, counterLength, counterRight, rounds } = checkOpts(\n    { allowShortKeys: false, counterLength: 8, counterRight: false, rounds: 20 },\n    opts\n  );\n  if (typeof core !== 'function') throw new Error('core must be a function');\n  anumber(counterLength);\n  anumber(rounds);\n  abool(counterRight);\n  abool(allowShortKeys);\n  return (\n    key: Uint8Array,\n    nonce: Uint8Array,\n    data: Uint8Array,\n    output?: Uint8Array,\n    counter = 0\n  ): Uint8Array => {\n    abytes(key, undefined, 'key');\n    abytes(nonce, undefined, 'nonce');\n    abytes(data, undefined, 'data');\n    const len = data.length;\n    if (output === undefined) output = new Uint8Array(len);\n    abytes(output, undefined, 'output');\n    anumber(counter);\n    if (counter < 0 || counter >= MAX_COUNTER) throw new Error('arx: counter overflow');\n    if (output.length < len)\n      throw new Error(`arx: output (${output.length}) is shorter than data (${len})`);\n    const toClean = [];\n\n    // Key & sigma\n    // key=16 -> sigma16, k=key|key\n    // key=32 -> sigma32, k=key\n    let l = key.length;\n    let k: Uint8Array;\n    let sigma: Uint32Array;\n    if (l === 32) {\n      toClean.push((k = copyBytes(key)));\n      sigma = sigma32_32;\n    } else if (l === 16 && allowShortKeys) {\n      k = new Uint8Array(32);\n      k.set(key);\n      k.set(key, 16);\n      sigma = sigma16_32;\n      toClean.push(k);\n    } else {\n      abytes(key, 32, 'arx key');\n      throw new Error('invalid key size');\n      // throw new Error(`\"arx key\" expected Uint8Array of length 32, got length=${l}`);\n    }\n\n    // Nonce\n    // salsa20:      8   (8-byte counter)\n    // chacha20orig: 8   (8-byte counter)\n    // chacha20:     12  (4-byte counter)\n    // xsalsa20:     24  (16 -> hsalsa,  8 -> old nonce)\n    // xchacha20:    24  (16 -> hchacha, 8 -> old nonce)\n    // Align nonce to 4 bytes\n    if (!isAligned32(nonce)) toClean.push((nonce = copyBytes(nonce)));\n\n    const k32 = u32(k);\n    // hsalsa & hchacha: handle extended nonce\n    if (extendNonceFn) {\n      if (nonce.length !== 24) throw new Error(`arx: extended nonce must be 24 bytes`);\n      extendNonceFn(sigma, k32, u32(nonce.subarray(0, 16)), k32);\n      nonce = nonce.subarray(16);\n    }\n\n    // Handle nonce counter\n    const nonceNcLen = 16 - counterLength;\n    if (nonceNcLen !== nonce.length)\n      throw new Error(`arx: nonce must be ${nonceNcLen} or 16 bytes`);\n\n    // Pad counter when nonce is 64 bit\n    if (nonceNcLen !== 12) {\n      const nc = new Uint8Array(12);\n      nc.set(nonce, counterRight ? 0 : 12 - nonce.length);\n      nonce = nc;\n      toClean.push(nonce);\n    }\n    const n32 = u32(nonce);\n    runCipher(core, sigma, k32, n32, data, output, counter, rounds);\n    clean(...toClean);\n    return output;\n  };\n}\n\n/** Internal class which wraps chacha20 or chacha8 to create CSPRNG. */\nexport class _XorStreamPRG implements PRG {\n  readonly blockLen: number;\n  readonly keyLen: number;\n  readonly nonceLen: number;\n  private state: Uint8Array;\n  private buf: Uint8Array;\n  private key: Uint8Array;\n  private nonce: Uint8Array;\n  private pos: number;\n  private ctr: number;\n  private cipher: XorStream;\n  constructor(\n    cipher: XorStream,\n    blockLen: number,\n    keyLen: number,\n    nonceLen: number,\n    seed: Uint8Array\n  ) {\n    this.cipher = cipher;\n    this.blockLen = blockLen;\n    this.keyLen = keyLen;\n    this.nonceLen = nonceLen;\n    this.state = new Uint8Array(this.keyLen + this.nonceLen);\n    this.reseed(seed);\n    this.ctr = 0;\n    this.pos = this.blockLen;\n    this.buf = new Uint8Array(this.blockLen);\n    this.key = this.state.subarray(0, this.keyLen);\n    this.nonce = this.state.subarray(this.keyLen);\n  }\n  private reseed(seed: Uint8Array) {\n    abytes(seed);\n    if (!seed || seed.length === 0) throw new Error('entropy required');\n    for (let i = 0; i < seed.length; i++) this.state[i % this.state.length] ^= seed[i];\n    this.ctr = 0;\n    this.pos = this.blockLen;\n  }\n  addEntropy(seed: Uint8Array): void {\n    this.state.set(this.randomBytes(this.state.length));\n    this.reseed(seed);\n  }\n  randomBytes(len: number): Uint8Array {\n    anumber(len);\n    if (len === 0) return new Uint8Array(0);\n    const out = new Uint8Array(len);\n    let outPos = 0;\n    // Leftovers\n    if (this.pos < this.blockLen) {\n      const take = Math.min(len, this.blockLen - this.pos);\n      out.set(this.buf.subarray(this.pos, this.pos + take), 0);\n      this.pos += take;\n      outPos += take;\n      if (outPos === len) return out; // fast path\n    }\n    // Full blocks directly to out\n    const blocks = Math.floor((len - outPos) / this.blockLen);\n    if (blocks > 0) {\n      const blockBytes = blocks * this.blockLen;\n      const b = out.subarray(outPos, outPos + blockBytes);\n      this.cipher(this.key, this.nonce, b, b, this.ctr);\n      this.ctr += blocks;\n      outPos += blockBytes;\n    }\n    // Save leftovers\n    const left = len - outPos;\n    if (left > 0) {\n      this.buf.fill(0);\n      // NOTE: cipher will handle overflow\n      this.cipher(this.key, this.nonce, this.buf, this.buf, this.ctr++);\n      out.set(this.buf.subarray(0, left), outPos);\n      this.pos = left;\n    }\n    return out;\n  }\n  clone(): _XorStreamPRG {\n    return new _XorStreamPRG(\n      this.cipher,\n      this.blockLen,\n      this.keyLen,\n      this.nonceLen,\n      this.randomBytes(this.state.length)\n    );\n  }\n  clean(): void {\n    this.pos = 0;\n    this.ctr = 0;\n    this.buf.fill(0);\n    this.state.fill(0);\n  }\n}\n\nexport type XorPRG = (seed?: Uint8Array) => _XorStreamPRG;\n\nexport const createPRG = (\n  cipher: XorStream,\n  blockLen: number,\n  keyLen: number,\n  nonceLen: number\n): XorPRG => {\n  return (seed: Uint8Array = randomBytes(32)): _XorStreamPRG =>\n    new _XorStreamPRG(cipher, blockLen, keyLen, nonceLen, seed);\n};\n", "/**\n * Poly1305 ([PDF](https://cr.yp.to/mac/poly1305-20050329.pdf),\n * [wiki](https://en.wikipedia.org/wiki/Poly1305))\n * is a fast and parallel secret-key message-authentication code suitable for\n * a wide variety of applications. It was standardized in\n * [RFC 8439](https://www.rfc-editor.org/rfc/rfc8439) and is now used in TLS 1.3.\n *\n * Polynomial MACs are not perfect for every situation:\n * they lack Random Key Robustness: the MAC can be forged, and can't be used in PAKE schemes.\n * See [invisible salamanders attack](https://keymaterial.net/2020/09/07/invisible-salamanders-in-aes-gcm-siv/).\n * To combat invisible salamanders, `hash(key)` can be included in ciphertext,\n * however, this would violate ciphertext indistinguishability:\n * an attacker would know which key was used - so `HKDF(key, i)`\n * could be used instead.\n *\n * Check out [original website](https://cr.yp.to/mac.html).\n * Based on Public Domain [poly1305-donna](https://github.com/floodyberry/poly1305-donna).\n * @module\n */\n// prettier-ignore\nimport {\n  abytes, aexists, aoutput, bytesToHex,\n  clean, concatBytes, copyBytes, hexToNumber, numberToBytesBE,\n  type IHash2\n} from './utils.ts';\n\nfunction u8to16(a: Uint8Array, i: number) {\n  return (a[i++] & 0xff) | ((a[i++] & 0xff) << 8);\n}\n\nfunction bytesToNumberLE(bytes: Uint8Array): bigint {\n  return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n}\n\n/** Small version of `poly1305` without loop unrolling. Unused, provided for auditability. */\nfunction poly1305_small(msg: Uint8Array, key: Uint8Array): Uint8Array {\n  abytes(msg);\n  abytes(key, 32, 'key');\n  const POW_2_130_5 = BigInt(2) ** BigInt(130) - BigInt(5); // 2^130-5\n  const POW_2_128_1 = BigInt(2) ** BigInt(128) - BigInt(1); // 2^128-1\n  const CLAMP_R = BigInt('0x0ffffffc0ffffffc0ffffffc0fffffff');\n  const r = bytesToNumberLE(key.subarray(0, 16)) & CLAMP_R;\n  const s = bytesToNumberLE(key.subarray(16));\n  // Process by 16 byte chunks\n  let acc = BigInt(0);\n  for (let i = 0; i < msg.length; i += 16) {\n    const m = msg.subarray(i, i + 16);\n    const n = bytesToNumberLE(m) | (BigInt(1) << BigInt(8 * m.length));\n    acc = ((acc + n) * r) % POW_2_130_5;\n  }\n  const res = (acc + s) & POW_2_128_1;\n  return numberToBytesBE(res, 16).reverse(); // LE\n}\n\n// Can be used to replace `computeTag` in chacha.ts. Unused, provided for auditability.\n// @ts-expect-error\nfunction poly1305_computeTag_small(\n  authKey: Uint8Array,\n  lengths: Uint8Array,\n  ciphertext: Uint8Array,\n  AAD?: Uint8Array\n): Uint8Array {\n  const res = [];\n  const updatePadded2 = (msg: Uint8Array) => {\n    res.push(msg);\n    const leftover = msg.length % 16;\n    if (leftover) res.push(new Uint8Array(16).slice(leftover));\n  };\n  if (AAD) updatePadded2(AAD);\n  updatePadded2(ciphertext);\n  res.push(lengths);\n  return poly1305_small(concatBytes(...res), authKey);\n}\n\n/** Poly1305 class. Prefer poly1305() function instead. */\nexport class Poly1305 implements IHash2 {\n  readonly blockLen = 16;\n  readonly outputLen = 16;\n  private buffer = new Uint8Array(16);\n  private r = new Uint16Array(10); // Allocating 1 array with .subarray() here is slower than 3\n  private h = new Uint16Array(10);\n  private pad = new Uint16Array(8);\n  private pos = 0;\n  protected finished = false;\n\n  // Can be speed-up using BigUint64Array, at the cost of complexity\n  constructor(key: Uint8Array) {\n    key = copyBytes(abytes(key, 32, 'key'));\n    const t0 = u8to16(key, 0);\n    const t1 = u8to16(key, 2);\n    const t2 = u8to16(key, 4);\n    const t3 = u8to16(key, 6);\n    const t4 = u8to16(key, 8);\n    const t5 = u8to16(key, 10);\n    const t6 = u8to16(key, 12);\n    const t7 = u8to16(key, 14);\n\n    // https://github.com/floodyberry/poly1305-donna/blob/e6ad6e091d30d7f4ec2d4f978be1fcfcbce72781/poly1305-donna-16.h#L47\n    this.r[0] = t0 & 0x1fff;\n    this.r[1] = ((t0 >>> 13) | (t1 << 3)) & 0x1fff;\n    this.r[2] = ((t1 >>> 10) | (t2 << 6)) & 0x1f03;\n    this.r[3] = ((t2 >>> 7) | (t3 << 9)) & 0x1fff;\n    this.r[4] = ((t3 >>> 4) | (t4 << 12)) & 0x00ff;\n    this.r[5] = (t4 >>> 1) & 0x1ffe;\n    this.r[6] = ((t4 >>> 14) | (t5 << 2)) & 0x1fff;\n    this.r[7] = ((t5 >>> 11) | (t6 << 5)) & 0x1f81;\n    this.r[8] = ((t6 >>> 8) | (t7 << 8)) & 0x1fff;\n    this.r[9] = (t7 >>> 5) & 0x007f;\n    for (let i = 0; i < 8; i++) this.pad[i] = u8to16(key, 16 + 2 * i);\n  }\n\n  private process(data: Uint8Array, offset: number, isLast = false) {\n    const hibit = isLast ? 0 : 1 << 11;\n    const { h, r } = this;\n    const r0 = r[0];\n    const r1 = r[1];\n    const r2 = r[2];\n    const r3 = r[3];\n    const r4 = r[4];\n    const r5 = r[5];\n    const r6 = r[6];\n    const r7 = r[7];\n    const r8 = r[8];\n    const r9 = r[9];\n\n    const t0 = u8to16(data, offset + 0);\n    const t1 = u8to16(data, offset + 2);\n    const t2 = u8to16(data, offset + 4);\n    const t3 = u8to16(data, offset + 6);\n    const t4 = u8to16(data, offset + 8);\n    const t5 = u8to16(data, offset + 10);\n    const t6 = u8to16(data, offset + 12);\n    const t7 = u8to16(data, offset + 14);\n\n    let h0 = h[0] + (t0 & 0x1fff);\n    let h1 = h[1] + (((t0 >>> 13) | (t1 << 3)) & 0x1fff);\n    let h2 = h[2] + (((t1 >>> 10) | (t2 << 6)) & 0x1fff);\n    let h3 = h[3] + (((t2 >>> 7) | (t3 << 9)) & 0x1fff);\n    let h4 = h[4] + (((t3 >>> 4) | (t4 << 12)) & 0x1fff);\n    let h5 = h[5] + ((t4 >>> 1) & 0x1fff);\n    let h6 = h[6] + (((t4 >>> 14) | (t5 << 2)) & 0x1fff);\n    let h7 = h[7] + (((t5 >>> 11) | (t6 << 5)) & 0x1fff);\n    let h8 = h[8] + (((t6 >>> 8) | (t7 << 8)) & 0x1fff);\n    let h9 = h[9] + ((t7 >>> 5) | hibit);\n\n    let c = 0;\n\n    let d0 = c + h0 * r0 + h1 * (5 * r9) + h2 * (5 * r8) + h3 * (5 * r7) + h4 * (5 * r6);\n    c = d0 >>> 13;\n    d0 &= 0x1fff;\n    d0 += h5 * (5 * r5) + h6 * (5 * r4) + h7 * (5 * r3) + h8 * (5 * r2) + h9 * (5 * r1);\n    c += d0 >>> 13;\n    d0 &= 0x1fff;\n\n    let d1 = c + h0 * r1 + h1 * r0 + h2 * (5 * r9) + h3 * (5 * r8) + h4 * (5 * r7);\n    c = d1 >>> 13;\n    d1 &= 0x1fff;\n    d1 += h5 * (5 * r6) + h6 * (5 * r5) + h7 * (5 * r4) + h8 * (5 * r3) + h9 * (5 * r2);\n    c += d1 >>> 13;\n    d1 &= 0x1fff;\n\n    let d2 = c + h0 * r2 + h1 * r1 + h2 * r0 + h3 * (5 * r9) + h4 * (5 * r8);\n    c = d2 >>> 13;\n    d2 &= 0x1fff;\n    d2 += h5 * (5 * r7) + h6 * (5 * r6) + h7 * (5 * r5) + h8 * (5 * r4) + h9 * (5 * r3);\n    c += d2 >>> 13;\n    d2 &= 0x1fff;\n\n    let d3 = c + h0 * r3 + h1 * r2 + h2 * r1 + h3 * r0 + h4 * (5 * r9);\n    c = d3 >>> 13;\n    d3 &= 0x1fff;\n    d3 += h5 * (5 * r8) + h6 * (5 * r7) + h7 * (5 * r6) + h8 * (5 * r5) + h9 * (5 * r4);\n    c += d3 >>> 13;\n    d3 &= 0x1fff;\n\n    let d4 = c + h0 * r4 + h1 * r3 + h2 * r2 + h3 * r1 + h4 * r0;\n    c = d4 >>> 13;\n    d4 &= 0x1fff;\n    d4 += h5 * (5 * r9) + h6 * (5 * r8) + h7 * (5 * r7) + h8 * (5 * r6) + h9 * (5 * r5);\n    c += d4 >>> 13;\n    d4 &= 0x1fff;\n\n    let d5 = c + h0 * r5 + h1 * r4 + h2 * r3 + h3 * r2 + h4 * r1;\n    c = d5 >>> 13;\n    d5 &= 0x1fff;\n    d5 += h5 * r0 + h6 * (5 * r9) + h7 * (5 * r8) + h8 * (5 * r7) + h9 * (5 * r6);\n    c += d5 >>> 13;\n    d5 &= 0x1fff;\n\n    let d6 = c + h0 * r6 + h1 * r5 + h2 * r4 + h3 * r3 + h4 * r2;\n    c = d6 >>> 13;\n    d6 &= 0x1fff;\n    d6 += h5 * r1 + h6 * r0 + h7 * (5 * r9) + h8 * (5 * r8) + h9 * (5 * r7);\n    c += d6 >>> 13;\n    d6 &= 0x1fff;\n\n    let d7 = c + h0 * r7 + h1 * r6 + h2 * r5 + h3 * r4 + h4 * r3;\n    c = d7 >>> 13;\n    d7 &= 0x1fff;\n    d7 += h5 * r2 + h6 * r1 + h7 * r0 + h8 * (5 * r9) + h9 * (5 * r8);\n    c += d7 >>> 13;\n    d7 &= 0x1fff;\n\n    let d8 = c + h0 * r8 + h1 * r7 + h2 * r6 + h3 * r5 + h4 * r4;\n    c = d8 >>> 13;\n    d8 &= 0x1fff;\n    d8 += h5 * r3 + h6 * r2 + h7 * r1 + h8 * r0 + h9 * (5 * r9);\n    c += d8 >>> 13;\n    d8 &= 0x1fff;\n\n    let d9 = c + h0 * r9 + h1 * r8 + h2 * r7 + h3 * r6 + h4 * r5;\n    c = d9 >>> 13;\n    d9 &= 0x1fff;\n    d9 += h5 * r4 + h6 * r3 + h7 * r2 + h8 * r1 + h9 * r0;\n    c += d9 >>> 13;\n    d9 &= 0x1fff;\n\n    c = ((c << 2) + c) | 0;\n    c = (c + d0) | 0;\n    d0 = c & 0x1fff;\n    c = c >>> 13;\n    d1 += c;\n\n    h[0] = d0;\n    h[1] = d1;\n    h[2] = d2;\n    h[3] = d3;\n    h[4] = d4;\n    h[5] = d5;\n    h[6] = d6;\n    h[7] = d7;\n    h[8] = d8;\n    h[9] = d9;\n  }\n\n  private finalize() {\n    const { h, pad } = this;\n    const g = new Uint16Array(10);\n    let c = h[1] >>> 13;\n    h[1] &= 0x1fff;\n    for (let i = 2; i < 10; i++) {\n      h[i] += c;\n      c = h[i] >>> 13;\n      h[i] &= 0x1fff;\n    }\n    h[0] += c * 5;\n    c = h[0] >>> 13;\n    h[0] &= 0x1fff;\n    h[1] += c;\n    c = h[1] >>> 13;\n    h[1] &= 0x1fff;\n    h[2] += c;\n\n    g[0] = h[0] + 5;\n    c = g[0] >>> 13;\n    g[0] &= 0x1fff;\n    for (let i = 1; i < 10; i++) {\n      g[i] = h[i] + c;\n      c = g[i] >>> 13;\n      g[i] &= 0x1fff;\n    }\n    g[9] -= 1 << 13;\n\n    let mask = (c ^ 1) - 1;\n    for (let i = 0; i < 10; i++) g[i] &= mask;\n    mask = ~mask;\n    for (let i = 0; i < 10; i++) h[i] = (h[i] & mask) | g[i];\n    h[0] = (h[0] | (h[1] << 13)) & 0xffff;\n    h[1] = ((h[1] >>> 3) | (h[2] << 10)) & 0xffff;\n    h[2] = ((h[2] >>> 6) | (h[3] << 7)) & 0xffff;\n    h[3] = ((h[3] >>> 9) | (h[4] << 4)) & 0xffff;\n    h[4] = ((h[4] >>> 12) | (h[5] << 1) | (h[6] << 14)) & 0xffff;\n    h[5] = ((h[6] >>> 2) | (h[7] << 11)) & 0xffff;\n    h[6] = ((h[7] >>> 5) | (h[8] << 8)) & 0xffff;\n    h[7] = ((h[8] >>> 8) | (h[9] << 5)) & 0xffff;\n\n    let f = h[0] + pad[0];\n    h[0] = f & 0xffff;\n    for (let i = 1; i < 8; i++) {\n      f = (((h[i] + pad[i]) | 0) + (f >>> 16)) | 0;\n      h[i] = f & 0xffff;\n    }\n    clean(g);\n  }\n  update(data: Uint8Array): this {\n    aexists(this);\n    abytes(data);\n    data = copyBytes(data);\n    const { buffer, blockLen } = this;\n    const len = data.length;\n\n    for (let pos = 0; pos < len; ) {\n      const take = Math.min(blockLen - this.pos, len - pos);\n      // Fast path: we have at least one block in input\n      if (take === blockLen) {\n        for (; blockLen <= len - pos; pos += blockLen) this.process(data, pos);\n        continue;\n      }\n      buffer.set(data.subarray(pos, pos + take), this.pos);\n      this.pos += take;\n      pos += take;\n      if (this.pos === blockLen) {\n        this.process(buffer, 0, false);\n        this.pos = 0;\n      }\n    }\n    return this;\n  }\n  destroy(): void {\n    clean(this.h, this.r, this.buffer, this.pad);\n  }\n  digestInto(out: Uint8Array): Uint8Array {\n    aexists(this);\n    aoutput(out, this);\n    this.finished = true;\n    const { buffer, h } = this;\n    let { pos } = this;\n    if (pos) {\n      buffer[pos++] = 1;\n      for (; pos < 16; pos++) buffer[pos] = 0;\n      this.process(buffer, 0, true);\n    }\n    this.finalize();\n    let opos = 0;\n    for (let i = 0; i < 8; i++) {\n      out[opos++] = h[i] >>> 0;\n      out[opos++] = h[i] >>> 8;\n    }\n    return out;\n  }\n  digest(): Uint8Array {\n    const { buffer, outputLen } = this;\n    this.digestInto(buffer);\n    const res = buffer.slice(0, outputLen);\n    this.destroy();\n    return res;\n  }\n}\n\nexport type CHash = ReturnType<typeof wrapConstructorWithKey>;\nexport function wrapConstructorWithKey<H extends IHash2>(\n  hashCons: (key: Uint8Array) => H\n): {\n  (msg: Uint8Array, key: Uint8Array): Uint8Array;\n  outputLen: number;\n  blockLen: number;\n  create(key: Uint8Array): H;\n} {\n  const hashC = (msg: Uint8Array, key: Uint8Array): Uint8Array =>\n    hashCons(key).update(msg).digest();\n  const tmp = hashCons(new Uint8Array(32)); // tmp array, used just once below\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (key: Uint8Array) => hashCons(key);\n  return hashC;\n}\n\n/** Poly1305 MAC from RFC 8439. */\nexport const poly1305: CHash = /** @__PURE__ */ (() =>\n  wrapConstructorWithKey((key) => new Poly1305(key)))();\n", "/**\n * ChaCha stream cipher, released\n * in 2008. Developed after Salsa20, ChaCha aims to increase diffusion per round.\n * It was standardized in [RFC 8439](https://www.rfc-editor.org/rfc/rfc8439) and\n * is now used in TLS 1.3.\n *\n * [XChaCha20](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-xchacha)\n * extended-nonce variant is also provided. Similar to XSalsa, it's safe to use with\n * randomly-generated nonces.\n *\n * Check out [PDF](http://cr.yp.to/chacha/chacha-20080128.pdf) and\n * [wiki](https://en.wikipedia.org/wiki/Salsa20) and\n * [website](https://cr.yp.to/chacha.html).\n *\n * @module\n */\nimport { type XorPRG, createCipher, createPRG, rotl } from './_arx.ts';\nimport { poly1305 } from './_poly1305.ts';\nimport {\n  type ARXCipher,\n  type CipherWithOutput,\n  type XorStream,\n  abytes,\n  clean,\n  equalBytes,\n  getOutput,\n  u64Lengths,\n  wrapCipher,\n} from './utils.ts';\n\n/**\n * ChaCha core function. It is implemented twice:\n * 1. Simple loop (chachaCore_small, hchacha_small)\n * 2. Unrolled loop (chachaCore, hchacha) - 4x faster, but larger & harder to read\n * The specific implementation is selected in `createCipher` below.\n */\n\n/** quarter-round */\n// prettier-ignore\nfunction chachaQR(x: Uint32Array, a: number, b: number, c: number, d: number) {\n  x[a] = (x[a] + x[b]) | 0; x[d] = rotl(x[d] ^ x[a], 16);\n  x[c] = (x[c] + x[d]) | 0; x[b] = rotl(x[b] ^ x[c], 12);\n  x[a] = (x[a] + x[b]) | 0; x[d] = rotl(x[d] ^ x[a], 8);\n  x[c] = (x[c] + x[d]) | 0; x[b] = rotl(x[b] ^ x[c], 7);\n}\n\n/** single round */\nfunction chachaRound(x: Uint32Array, rounds = 20) {\n  for (let r = 0; r < rounds; r += 2) {\n    chachaQR(x, 0, 4, 8, 12);\n    chachaQR(x, 1, 5, 9, 13);\n    chachaQR(x, 2, 6, 10, 14);\n    chachaQR(x, 3, 7, 11, 15);\n    chachaQR(x, 0, 5, 10, 15);\n    chachaQR(x, 1, 6, 11, 12);\n    chachaQR(x, 2, 7, 8, 13);\n    chachaQR(x, 3, 4, 9, 14);\n  }\n}\n\nconst ctmp = /* @__PURE__ */ new Uint32Array(16);\n\n/** Small version of chacha without loop unrolling. Unused, provided for auditability. */\n// prettier-ignore\nfunction chacha(\n  s: Uint32Array, k: Uint32Array, i: Uint32Array, out: Uint32Array,\n  isHChacha: boolean = true, rounds: number = 20\n): void {\n  // Create initial array using common pattern\n  const y = Uint32Array.from([\n    s[0], s[1], s[2], s[3], // \"expa\"   \"nd 3\"  \"2-by\"  \"te k\"\n    k[0], k[1], k[2], k[3], // Key      Key     Key     Key\n    k[4], k[5], k[6], k[7], // Key      Key     Key     Key\n    i[0], i[1], i[2], i[3], // Counter  Counter Nonce   Nonce\n  ]);\n  const x = ctmp;\n  x.set(y);\n  chachaRound(x, rounds);\n\n  // hchacha extracts 8 specific bytes, chacha adds orig to result\n  if (isHChacha) {\n    const xindexes = [0, 1, 2, 3, 12, 13, 14, 15];\n    for (let i = 0; i < 8; i++) out[i] = x[xindexes[i]];\n  } else {\n    for (let i = 0; i < 16; i++) out[i] = (y[i] + x[i]) | 0;\n  }\n}\n\n/** Identical to `chachaCore`. Unused. */\n// @ts-ignore\nconst chachaCore_small: typeof chachaCore = (s, k, n, out, cnt, rounds) =>\n  chacha(s, k, Uint32Array.from([n[0], n[1], cnt, 0]), out, false, rounds);\n/** Identical to `hchacha`. Unused. */\n// @ts-ignore\nconst hchacha_small: typeof hchacha = chacha;\n\n/** Identical to `chachaCore_small`. Unused. */\n// prettier-ignore\nfunction chachaCore(\n  s: Uint32Array, k: Uint32Array, n: Uint32Array, out: Uint32Array, cnt: number, rounds = 20\n): void {\n  let y00 = s[0], y01 = s[1], y02 = s[2], y03 = s[3], // \"expa\"   \"nd 3\"  \"2-by\"  \"te k\"\n      y04 = k[0], y05 = k[1], y06 = k[2], y07 = k[3], // Key      Key     Key     Key\n      y08 = k[4], y09 = k[5], y10 = k[6], y11 = k[7], // Key      Key     Key     Key\n      y12 = cnt,  y13 = n[0], y14 = n[1], y15 = n[2];  // Counter  Counter\tNonce   Nonce\n  // Save state to temporary variables\n  let x00 = y00, x01 = y01, x02 = y02, x03 = y03,\n      x04 = y04, x05 = y05, x06 = y06, x07 = y07,\n      x08 = y08, x09 = y09, x10 = y10, x11 = y11,\n      x12 = y12, x13 = y13, x14 = y14, x15 = y15;\n  for (let r = 0; r < rounds; r += 2) {\n    x00 = (x00 + x04) | 0; x12 = rotl(x12 ^ x00, 16);\n    x08 = (x08 + x12) | 0; x04 = rotl(x04 ^ x08, 12);\n    x00 = (x00 + x04) | 0; x12 = rotl(x12 ^ x00, 8);\n    x08 = (x08 + x12) | 0; x04 = rotl(x04 ^ x08, 7);\n\n    x01 = (x01 + x05) | 0; x13 = rotl(x13 ^ x01, 16);\n    x09 = (x09 + x13) | 0; x05 = rotl(x05 ^ x09, 12);\n    x01 = (x01 + x05) | 0; x13 = rotl(x13 ^ x01, 8);\n    x09 = (x09 + x13) | 0; x05 = rotl(x05 ^ x09, 7);\n\n    x02 = (x02 + x06) | 0; x14 = rotl(x14 ^ x02, 16);\n    x10 = (x10 + x14) | 0; x06 = rotl(x06 ^ x10, 12);\n    x02 = (x02 + x06) | 0; x14 = rotl(x14 ^ x02, 8);\n    x10 = (x10 + x14) | 0; x06 = rotl(x06 ^ x10, 7);\n\n    x03 = (x03 + x07) | 0; x15 = rotl(x15 ^ x03, 16);\n    x11 = (x11 + x15) | 0; x07 = rotl(x07 ^ x11, 12);\n    x03 = (x03 + x07) | 0; x15 = rotl(x15 ^ x03, 8)\n    x11 = (x11 + x15) | 0; x07 = rotl(x07 ^ x11, 7);\n\n    x00 = (x00 + x05) | 0; x15 = rotl(x15 ^ x00, 16);\n    x10 = (x10 + x15) | 0; x05 = rotl(x05 ^ x10, 12);\n    x00 = (x00 + x05) | 0; x15 = rotl(x15 ^ x00, 8);\n    x10 = (x10 + x15) | 0; x05 = rotl(x05 ^ x10, 7);\n\n    x01 = (x01 + x06) | 0; x12 = rotl(x12 ^ x01, 16);\n    x11 = (x11 + x12) | 0; x06 = rotl(x06 ^ x11, 12);\n    x01 = (x01 + x06) | 0; x12 = rotl(x12 ^ x01, 8);\n    x11 = (x11 + x12) | 0; x06 = rotl(x06 ^ x11, 7);\n\n    x02 = (x02 + x07) | 0; x13 = rotl(x13 ^ x02, 16);\n    x08 = (x08 + x13) | 0; x07 = rotl(x07 ^ x08, 12);\n    x02 = (x02 + x07) | 0; x13 = rotl(x13 ^ x02, 8);\n    x08 = (x08 + x13) | 0; x07 = rotl(x07 ^ x08, 7);\n\n    x03 = (x03 + x04) | 0; x14 = rotl(x14 ^ x03, 16)\n    x09 = (x09 + x14) | 0; x04 = rotl(x04 ^ x09, 12);\n    x03 = (x03 + x04) | 0; x14 = rotl(x14 ^ x03, 8);\n    x09 = (x09 + x14) | 0; x04 = rotl(x04 ^ x09, 7);\n  }\n  // Write output\n  let oi = 0;\n  out[oi++] = (y00 + x00) | 0; out[oi++] = (y01 + x01) | 0;\n  out[oi++] = (y02 + x02) | 0; out[oi++] = (y03 + x03) | 0;\n  out[oi++] = (y04 + x04) | 0; out[oi++] = (y05 + x05) | 0;\n  out[oi++] = (y06 + x06) | 0; out[oi++] = (y07 + x07) | 0;\n  out[oi++] = (y08 + x08) | 0; out[oi++] = (y09 + x09) | 0;\n  out[oi++] = (y10 + x10) | 0; out[oi++] = (y11 + x11) | 0;\n  out[oi++] = (y12 + x12) | 0; out[oi++] = (y13 + x13) | 0;\n  out[oi++] = (y14 + x14) | 0; out[oi++] = (y15 + x15) | 0;\n}\n/**\n * hchacha hashes key and nonce into key' and nonce' for xchacha20.\n * Identical to `hchacha_small`.\n * Need to find a way to merge it with `chachaCore` without 25% performance hit.\n */\n// prettier-ignore\nexport function hchacha(\n  s: Uint32Array, k: Uint32Array, i: Uint32Array, out: Uint32Array\n): void {\n  let x00 = s[0], x01 = s[1], x02 = s[2], x03 = s[3],\n      x04 = k[0], x05 = k[1], x06 = k[2], x07 = k[3],\n      x08 = k[4], x09 = k[5], x10 = k[6], x11 = k[7],\n      x12 = i[0], x13 = i[1], x14 = i[2], x15 = i[3];\n  for (let r = 0; r < 20; r += 2) {\n    x00 = (x00 + x04) | 0; x12 = rotl(x12 ^ x00, 16);\n    x08 = (x08 + x12) | 0; x04 = rotl(x04 ^ x08, 12);\n    x00 = (x00 + x04) | 0; x12 = rotl(x12 ^ x00, 8);\n    x08 = (x08 + x12) | 0; x04 = rotl(x04 ^ x08, 7);\n\n    x01 = (x01 + x05) | 0; x13 = rotl(x13 ^ x01, 16);\n    x09 = (x09 + x13) | 0; x05 = rotl(x05 ^ x09, 12);\n    x01 = (x01 + x05) | 0; x13 = rotl(x13 ^ x01, 8);\n    x09 = (x09 + x13) | 0; x05 = rotl(x05 ^ x09, 7);\n\n    x02 = (x02 + x06) | 0; x14 = rotl(x14 ^ x02, 16);\n    x10 = (x10 + x14) | 0; x06 = rotl(x06 ^ x10, 12);\n    x02 = (x02 + x06) | 0; x14 = rotl(x14 ^ x02, 8);\n    x10 = (x10 + x14) | 0; x06 = rotl(x06 ^ x10, 7);\n\n    x03 = (x03 + x07) | 0; x15 = rotl(x15 ^ x03, 16);\n    x11 = (x11 + x15) | 0; x07 = rotl(x07 ^ x11, 12);\n    x03 = (x03 + x07) | 0; x15 = rotl(x15 ^ x03, 8)\n    x11 = (x11 + x15) | 0; x07 = rotl(x07 ^ x11, 7);\n\n    x00 = (x00 + x05) | 0; x15 = rotl(x15 ^ x00, 16);\n    x10 = (x10 + x15) | 0; x05 = rotl(x05 ^ x10, 12);\n    x00 = (x00 + x05) | 0; x15 = rotl(x15 ^ x00, 8);\n    x10 = (x10 + x15) | 0; x05 = rotl(x05 ^ x10, 7);\n\n    x01 = (x01 + x06) | 0; x12 = rotl(x12 ^ x01, 16);\n    x11 = (x11 + x12) | 0; x06 = rotl(x06 ^ x11, 12);\n    x01 = (x01 + x06) | 0; x12 = rotl(x12 ^ x01, 8);\n    x11 = (x11 + x12) | 0; x06 = rotl(x06 ^ x11, 7);\n\n    x02 = (x02 + x07) | 0; x13 = rotl(x13 ^ x02, 16);\n    x08 = (x08 + x13) | 0; x07 = rotl(x07 ^ x08, 12);\n    x02 = (x02 + x07) | 0; x13 = rotl(x13 ^ x02, 8);\n    x08 = (x08 + x13) | 0; x07 = rotl(x07 ^ x08, 7);\n\n    x03 = (x03 + x04) | 0; x14 = rotl(x14 ^ x03, 16)\n    x09 = (x09 + x14) | 0; x04 = rotl(x04 ^ x09, 12);\n    x03 = (x03 + x04) | 0; x14 = rotl(x14 ^ x03, 8);\n    x09 = (x09 + x14) | 0; x04 = rotl(x04 ^ x09, 7);\n  }\n  let oi = 0;\n  out[oi++] = x00; out[oi++] = x01;\n  out[oi++] = x02; out[oi++] = x03;\n  out[oi++] = x12; out[oi++] = x13;\n  out[oi++] = x14; out[oi++] = x15;\n}\n\n/** Original, non-RFC chacha20 from DJB. 8-byte nonce, 8-byte counter. */\nexport const chacha20orig: XorStream = /* @__PURE__ */ createCipher(chachaCore, {\n  counterRight: false,\n  counterLength: 8,\n  allowShortKeys: true,\n});\n/**\n * ChaCha stream cipher. Conforms to RFC 8439 (IETF, TLS). 12-byte nonce, 4-byte counter.\n * With smaller nonce, it's not safe to make it random (CSPRNG), due to collision chance.\n */\nexport const chacha20: XorStream = /* @__PURE__ */ createCipher(chachaCore, {\n  counterRight: false,\n  counterLength: 4,\n  allowShortKeys: false,\n});\n\n/**\n * XChaCha eXtended-nonce ChaCha. With 24-byte nonce, it's safe to make it random (CSPRNG).\n * See [IRTF draft](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-xchacha).\n */\nexport const xchacha20: XorStream = /* @__PURE__ */ createCipher(chachaCore, {\n  counterRight: false,\n  counterLength: 8,\n  extendNonceFn: hchacha,\n  allowShortKeys: false,\n});\n\n/** Reduced 8-round chacha, described in original paper. */\nexport const chacha8: XorStream = /* @__PURE__ */ createCipher(chachaCore, {\n  counterRight: false,\n  counterLength: 4,\n  rounds: 8,\n});\n\n/** Reduced 12-round chacha, described in original paper. */\nexport const chacha12: XorStream = /* @__PURE__ */ createCipher(chachaCore, {\n  counterRight: false,\n  counterLength: 4,\n  rounds: 12,\n});\n\nconst ZEROS16 = /* @__PURE__ */ new Uint8Array(16);\n// Pad to digest size with zeros\nconst updatePadded = (h: ReturnType<typeof poly1305.create>, msg: Uint8Array) => {\n  h.update(msg);\n  const leftover = msg.length % 16;\n  if (leftover) h.update(ZEROS16.subarray(leftover));\n};\n\nconst ZEROS32 = /* @__PURE__ */ new Uint8Array(32);\nfunction computeTag(\n  fn: XorStream,\n  key: Uint8Array,\n  nonce: Uint8Array,\n  ciphertext: Uint8Array,\n  AAD?: Uint8Array\n): Uint8Array {\n  if (AAD !== undefined) abytes(AAD, undefined, 'AAD');\n  const authKey = fn(key, nonce, ZEROS32);\n  const lengths = u64Lengths(ciphertext.length, AAD ? AAD.length : 0, true);\n\n  // Methods below can be replaced with\n  // return poly1305_computeTag_small(authKey, lengths, ciphertext, AAD)\n  const h = poly1305.create(authKey);\n  if (AAD) updatePadded(h, AAD);\n  updatePadded(h, ciphertext);\n  h.update(lengths);\n  const res = h.digest();\n  clean(authKey, lengths);\n  return res;\n}\n\n/**\n * AEAD algorithm from RFC 8439.\n * Salsa20 and chacha (RFC 8439) use poly1305 differently.\n * We could have composed them, but it's hard because of authKey:\n * In salsa20, authKey changes position in salsa stream.\n * In chacha, authKey can't be computed inside computeTag, it modifies the counter.\n */\nexport const _poly1305_aead =\n  (xorStream: XorStream) =>\n  (key: Uint8Array, nonce: Uint8Array, AAD?: Uint8Array): CipherWithOutput => {\n    const tagLength = 16;\n    return {\n      encrypt(plaintext: Uint8Array, output?: Uint8Array) {\n        const plength = plaintext.length;\n        output = getOutput(plength + tagLength, output, false);\n        output.set(plaintext);\n        const oPlain = output.subarray(0, -tagLength);\n        // Actual encryption\n        xorStream(key, nonce, oPlain, oPlain, 1);\n        const tag = computeTag(xorStream, key, nonce, oPlain, AAD);\n        output.set(tag, plength); // append tag\n        clean(tag);\n        return output;\n      },\n      decrypt(ciphertext: Uint8Array, output?: Uint8Array) {\n        output = getOutput(ciphertext.length - tagLength, output, false);\n        const data = ciphertext.subarray(0, -tagLength);\n        const passedTag = ciphertext.subarray(-tagLength);\n        const tag = computeTag(xorStream, key, nonce, data, AAD);\n        if (!equalBytes(passedTag, tag)) throw new Error('invalid tag');\n        output.set(ciphertext.subarray(0, -tagLength));\n        // Actual decryption\n        xorStream(key, nonce, output, output, 1); // start stream with i=1\n        clean(tag);\n        return output;\n      },\n    };\n  };\n\n/**\n * ChaCha20-Poly1305 from RFC 8439.\n *\n * Unsafe to use random nonces under the same key, due to collision chance.\n * Prefer XChaCha instead.\n */\nexport const chacha20poly1305: ARXCipher = /* @__PURE__ */ wrapCipher(\n  { blockSize: 64, nonceLength: 12, tagLength: 16 },\n  _poly1305_aead(chacha20)\n);\n/**\n * XChaCha20-Poly1305 extended-nonce chacha.\n *\n * Can be safely used with random nonces (CSPRNG).\n * See [IRTF draft](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-xchacha).\n */\nexport const xchacha20poly1305: ARXCipher = /* @__PURE__ */ wrapCipher(\n  { blockSize: 64, nonceLength: 24, tagLength: 16 },\n  _poly1305_aead(xchacha20)\n);\n\n/**\n * Chacha20 CSPRNG (cryptographically secure pseudorandom number generator).\n * It's best to limit usage to non-production, non-critical cases: for example, test-only.\n * Compatible with libtomcrypt. It does not have a specification, so unclear how secure it is.\n */\nexport const rngChacha20: XorPRG = /* @__PURE__ */ createPRG(chacha20orig, 64, 32, 8);\n/**\n * Chacha20/8 CSPRNG (cryptographically secure pseudorandom number generator).\n * It's best to limit usage to non-production, non-critical cases: for example, test-only.\n * Faster than `rngChacha20`.\n */\nexport const rngChacha8: XorPRG = /* @__PURE__ */ createPRG(chacha8, 64, 32, 12);\n", "/**\n * HMAC: RFC2104 message authentication code.\n * @module\n */\nimport { abytes, aexists, ahash, clean, type CHash, type Hash } from './utils.ts';\n\n/** Internal class for HMAC. */\nexport class _HMAC<T extends Hash<T>> implements Hash<_HMAC<T>> {\n  oHash: T;\n  iHash: T;\n  blockLen: number;\n  outputLen: number;\n  private finished = false;\n  private destroyed = false;\n\n  constructor(hash: CHash, key: Uint8Array) {\n    ahash(hash);\n    abytes(key, undefined, 'key');\n    this.iHash = hash.create() as T;\n    if (typeof this.iHash.update !== 'function')\n      throw new Error('Expected instance of class which extends utils.Hash');\n    this.blockLen = this.iHash.blockLen;\n    this.outputLen = this.iHash.outputLen;\n    const blockLen = this.blockLen;\n    const pad = new Uint8Array(blockLen);\n    // blockLen can be bigger than outputLen\n    pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n    for (let i = 0; i < pad.length; i++) pad[i] ^= 0x36;\n    this.iHash.update(pad);\n    // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n    this.oHash = hash.create() as T;\n    // Undo internal XOR && apply outer XOR\n    for (let i = 0; i < pad.length; i++) pad[i] ^= 0x36 ^ 0x5c;\n    this.oHash.update(pad);\n    clean(pad);\n  }\n  update(buf: Uint8Array): this {\n    aexists(this);\n    this.iHash.update(buf);\n    return this;\n  }\n  digestInto(out: Uint8Array): void {\n    aexists(this);\n    abytes(out, this.outputLen, 'output');\n    this.finished = true;\n    this.iHash.digestInto(out);\n    this.oHash.update(out);\n    this.oHash.digestInto(out);\n    this.destroy();\n  }\n  digest(): Uint8Array {\n    const out = new Uint8Array(this.oHash.outputLen);\n    this.digestInto(out);\n    return out;\n  }\n  _cloneInto(to?: _HMAC<T>): _HMAC<T> {\n    // Create new instance without calling constructor since key already in state and we don't know it.\n    to ||= Object.create(Object.getPrototypeOf(this), {});\n    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n    to = to as this;\n    to.finished = finished;\n    to.destroyed = destroyed;\n    to.blockLen = blockLen;\n    to.outputLen = outputLen;\n    to.oHash = oHash._cloneInto(to.oHash);\n    to.iHash = iHash._cloneInto(to.iHash);\n    return to;\n  }\n  clone(): _HMAC<T> {\n    return this._cloneInto();\n  }\n  destroy(): void {\n    this.destroyed = true;\n    this.oHash.destroy();\n    this.iHash.destroy();\n  }\n}\n\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n * @example\n * import { hmac } from '@noble/hashes/hmac';\n * import { sha256 } from '@noble/hashes/sha2';\n * const mac1 = hmac(sha256, 'key', 'message');\n */\nexport const hmac: {\n  (hash: CHash, key: Uint8Array, message: Uint8Array): Uint8Array;\n  create(hash: CHash, key: Uint8Array): _HMAC<any>;\n} = (hash: CHash, key: Uint8Array, message: Uint8Array): Uint8Array =>\n  new _HMAC<any>(hash, key).update(message).digest();\nhmac.create = (hash: CHash, key: Uint8Array) => new _HMAC<any>(hash, key);\n", "/**\n * HKDF (RFC 5869): extract + expand in one step.\n * See https://soatok.blog/2021/11/17/understanding-hkdf/.\n * @module\n */\nimport { hmac } from './hmac.ts';\nimport { abytes, ahash, anumber, type CHash, clean } from './utils.ts';\n\n/**\n * HKDF-extract from spec. Less important part. `HKDF-Extract(IKM, salt) -> PRK`\n * Arguments position differs from spec (IKM is first one, since it is not optional)\n * @param hash - hash function that would be used (e.g. sha256)\n * @param ikm - input keying material, the initial key\n * @param salt - optional salt value (a non-secret random value)\n */\nexport function extract(hash: CHash, ikm: Uint8Array, salt?: Uint8Array): Uint8Array {\n  ahash(hash);\n  // NOTE: some libraries treat zero-length array as 'not provided';\n  // we don't, since we have undefined as 'not provided'\n  // https://github.com/RustCrypto/KDFs/issues/15\n  if (salt === undefined) salt = new Uint8Array(hash.outputLen);\n  return hmac(hash, salt, ikm);\n}\n\nconst HKDF_COUNTER = /* @__PURE__ */ Uint8Array.of(0);\nconst EMPTY_BUFFER = /* @__PURE__ */ Uint8Array.of();\n\n/**\n * HKDF-expand from the spec. The most important part. `HKDF-Expand(PRK, info, L) -> OKM`\n * @param hash - hash function that would be used (e.g. sha256)\n * @param prk - a pseudorandom key of at least HashLen octets (usually, the output from the extract step)\n * @param info - optional context and application specific information (can be a zero-length string)\n * @param length - length of output keying material in bytes\n */\nexport function expand(\n  hash: CHash,\n  prk: Uint8Array,\n  info?: Uint8Array,\n  length: number = 32\n): Uint8Array {\n  ahash(hash);\n  anumber(length, 'length');\n  const olen = hash.outputLen;\n  if (length > 255 * olen) throw new Error('Length must be <= 255*HashLen');\n  const blocks = Math.ceil(length / olen);\n  if (info === undefined) info = EMPTY_BUFFER;\n  else abytes(info, undefined, 'info');\n  // first L(ength) octets of T\n  const okm = new Uint8Array(blocks * olen);\n  // Re-use HMAC instance between blocks\n  const HMAC = hmac.create(hash, prk);\n  const HMACTmp = HMAC._cloneInto();\n  const T = new Uint8Array(HMAC.outputLen);\n  for (let counter = 0; counter < blocks; counter++) {\n    HKDF_COUNTER[0] = counter + 1;\n    // T(0) = empty string (zero length)\n    // T(N) = HMAC-Hash(PRK, T(N-1) | info | N)\n    HMACTmp.update(counter === 0 ? EMPTY_BUFFER : T)\n      .update(info)\n      .update(HKDF_COUNTER)\n      .digestInto(T);\n    okm.set(T, olen * counter);\n    HMAC._cloneInto(HMACTmp);\n  }\n  HMAC.destroy();\n  HMACTmp.destroy();\n  clean(T, HKDF_COUNTER);\n  return okm.slice(0, length);\n}\n\n/**\n * HKDF (RFC 5869): derive keys from an initial input.\n * Combines hkdf_extract + hkdf_expand in one step\n * @param hash - hash function that would be used (e.g. sha256)\n * @param ikm - input keying material, the initial key\n * @param salt - optional salt value (a non-secret random value)\n * @param info - optional context and application specific information (can be a zero-length string)\n * @param length - length of output keying material in bytes\n * @example\n * import { hkdf } from '@noble/hashes/hkdf';\n * import { sha256 } from '@noble/hashes/sha2';\n * import { randomBytes } from '@noble/hashes/utils';\n * const inputKey = randomBytes(32);\n * const salt = randomBytes(32);\n * const info = 'application-key';\n * const hk1 = hkdf(sha256, inputKey, salt, info, 32);\n */\nexport const hkdf = (\n  hash: CHash,\n  ikm: Uint8Array,\n  salt: Uint8Array | undefined,\n  info: Uint8Array | undefined,\n  length: number\n): Uint8Array => expand(hash, extract(hash, ikm, salt), info, length);\n", "/**\n * Cryptographic primitives for Sovereign Communications\n *\n * Security Standards:\n * - Ed25519: RFC 8032 - Edwards-Curve Digital Signature Algorithm\n * - X25519: RFC 7748 - Elliptic Curve Diffie-Hellman (ECDH)\n * - XChaCha20-Poly1305: draft-irtf-cfrg-xchacha - AEAD cipher\n * - HKDF: RFC 5869 - HMAC-based Key Derivation Function\n * - SHA-256: FIPS 180-4 - Secure Hash Standard\n *\n * Implementation: @noble libraries (audited, minimal dependencies)\n *\n * Side-Channel Attack Protections:\n * - Constant-time comparisons for secret data\n * - Secure key wiping after use\n * - Nonce tracking and reuse prevention\n */\nimport { ed25519 } from '@noble/curves/ed25519.js';\nimport { x25519 } from '@noble/curves/ed25519.js';\nimport { sha256 } from '@noble/hashes/sha2.js';\nimport { randomBytes as nobleRandomBytes } from '@noble/hashes/utils.js';\nimport { xchacha20poly1305 } from '@noble/ciphers/chacha.js';\nimport { hkdf } from '@noble/hashes/hkdf.js';\nexport const randomBytes = nobleRandomBytes;\n/**\n * Nonce manager to prevent reuse\n */\nexport class NonceManager {\n    constructor() {\n        this.usedNonces = new Set();\n        this.maxTracked = 10000;\n    }\n    /**\n     * Check if nonce has been used and mark it as used\n     * @throws Error if nonce has been reused\n     */\n    markUsed(nonce) {\n        const nonceStr = Array.from(nonce).join(',');\n        if (this.usedNonces.has(nonceStr)) {\n            throw new Error('Nonce reuse detected! This is a critical security violation.');\n        }\n        this.usedNonces.add(nonceStr);\n        // Prevent memory bloat\n        if (this.usedNonces.size > this.maxTracked) {\n            // Remove oldest entries (first 1000)\n            const toRemove = Array.from(this.usedNonces).slice(0, 1000);\n            toRemove.forEach(n => this.usedNonces.delete(n));\n        }\n    }\n    /**\n     * Check if nonce has been used without marking\n     */\n    hasBeenUsed(nonce) {\n        const nonceStr = Array.from(nonce).join(',');\n        return this.usedNonces.has(nonceStr);\n    }\n    /**\n     * Clear all tracked nonces\n     */\n    clear() {\n        this.usedNonces.clear();\n    }\n}\n/**\n * Timing-safe comparison function to prevent timing attacks\n * Returns true if arrays are equal, false otherwise\n * Execution time is independent of where differences occur\n */\nexport function timingSafeEqual(a, b) {\n    if (a.length !== b.length) {\n        return false;\n    }\n    let result = 0;\n    for (let i = 0; i < a.length; i++) {\n        result |= a[i] ^ b[i];\n    }\n    return result === 0;\n}\n/**\n * Securely wipe key material from memory\n * Overwrites the array with zeros\n */\nexport function secureWipe(data) {\n    data.fill(0);\n}\n/**\n * Validate entropy quality of random data\n * Performs basic statistical tests\n */\nexport function validateEntropy(data) {\n    if (data.length < 32)\n        return false;\n    // Check for all zeros\n    if (data.every(b => b === 0))\n        return false;\n    // Check for all same value\n    const first = data[0];\n    if (data.every(b => b === first))\n        return false;\n    // Check for simple patterns\n    let patternCount = 0;\n    for (let i = 1; i < data.length; i++) {\n        if (data[i] === data[i - 1])\n            patternCount++;\n    }\n    // If more than 80% are sequential duplicates, likely bad entropy\n    if (patternCount > data.length * 0.8)\n        return false;\n    return true;\n}\n/**\n * Generate a new Ed25519 identity keypair\n * Uses cryptographically secure random number generator\n *\n * Algorithm Parameters:\n * - Curve: Edwards25519\n * - Private key: 32 bytes\n * - Public key: 32 bytes (compressed point)\n * - Security level: ~128 bits\n *\n * @throws Error if entropy validation fails\n */\nexport function generateIdentity() {\n    const privateKey = ed25519.utils.randomSecretKey();\n    // Validate entropy quality\n    if (!validateEntropy(privateKey)) {\n        throw new Error('Insufficient entropy for key generation');\n    }\n    const publicKey = ed25519.getPublicKey(privateKey);\n    return {\n        publicKey,\n        privateKey,\n    };\n}\n/**\n * Sign a message with Ed25519\n *\n * Algorithm: RFC 8032 Deterministic Ed25519\n * - Uses deterministic nonce generation (no randomness during signing)\n * - Signature: 64 bytes (R point + s scalar)\n * - Resistant to nonce reuse attacks\n *\n * @param message - Message to sign\n * @param privateKey - 32-byte Ed25519 private key\n * @returns 64-byte signature\n */\nexport function signMessage(message, privateKey) {\n    if (privateKey.length !== 32) {\n        throw new Error('Private key must be 32 bytes');\n    }\n    return ed25519.sign(message, privateKey);\n}\n/**\n * Verify a message signature with Ed25519\n * Uses constant-time operations to prevent timing attacks\n *\n * @param message - Original message\n * @param signature - 64-byte signature\n * @param publicKey - 32-byte Ed25519 public key\n * @returns true if signature is valid, false otherwise\n */\nexport function verifySignature(message, signature, publicKey) {\n    try {\n        if (publicKey.length !== 32)\n            return false;\n        if (signature.length !== 64)\n            return false;\n        return ed25519.verify(signature, message, publicKey);\n    }\n    catch {\n        return false;\n    }\n}\n/**\n * Batch verify multiple signatures (more efficient than individual verification)\n *\n * @param items - Array of {message, signature, publicKey} tuples\n * @returns true if all signatures are valid, false if any are invalid\n */\nexport function batchVerifySignatures(items) {\n    try {\n        // Verify each signature individually\n        // Note: @noble/curves doesn't have built-in batch verification yet\n        // This implementation verifies each but provides the API for future optimization\n        return items.every(item => verifySignature(item.message, item.signature, item.publicKey));\n    }\n    catch {\n        return false;\n    }\n}\n/**\n * Perform ECDH key exchange using X25519 (RFC 7748)\n *\n * Algorithm: Curve25519 Diffie-Hellman\n * - Derives a shared secret between two parties\n * - Uses HKDF for proper key derivation\n * - Resistant to small subgroup attacks\n *\n * @param privateKey - Our X25519 private key (32 bytes)\n * @param peerPublicKey - Peer's X25519 public key (32 bytes)\n * @param salt - Optional salt for HKDF (default: zeros)\n * @param info - Optional context info for HKDF\n * @returns Derived 32-byte key\n */\nexport function performKeyExchange(privateKey, peerPublicKey, salt, info) {\n    if (privateKey.length !== 32) {\n        throw new Error('Private key must be 32 bytes');\n    }\n    if (peerPublicKey.length !== 32) {\n        throw new Error('Peer public key must be 32 bytes');\n    }\n    // Perform ECDH\n    const sharedSecret = x25519.getSharedSecret(privateKey, peerPublicKey);\n    // Use HKDF to derive proper key from shared secret\n    const derivedKey = hkdf(sha256, sharedSecret, salt || new Uint8Array(32), // Salt\n    info || new Uint8Array(0), // Info/context\n    32 // Output length\n    );\n    // Wipe shared secret from memory\n    secureWipe(sharedSecret);\n    return derivedKey;\n}\n/**\n * Generate ephemeral X25519 keypair for key exchange\n * Used for forward secrecy - generate new keypair for each session\n */\nexport function generateEphemeralKeyPair() {\n    const privateKey = x25519.utils.randomSecretKey();\n    const publicKey = x25519.getPublicKey(privateKey);\n    if (!validateEntropy(privateKey)) {\n        throw new Error('Insufficient entropy for ephemeral key generation');\n    }\n    return {\n        publicKey,\n        privateKey,\n    };\n}\n/**\n * Generate a session key for forward secrecy\n *\n * @param counter - Optional counter for nonce generation\n * @returns New session key with nonce\n */\nexport function generateSessionKey(counter) {\n    const key = randomBytes(32);\n    if (!validateEntropy(key)) {\n        throw new Error('Insufficient entropy for session key generation');\n    }\n    return {\n        key,\n        nonce: randomBytes(24),\n        timestamp: Date.now(),\n        messageCount: 0,\n        counter: counter || 0,\n    };\n}\n/**\n * Increment nonce counter for sequential messages\n * Prevents nonce reuse while allowing sequential message encryption\n *\n * @param sessionKey - Current session key\n * @returns New nonce based on counter\n */\nexport function incrementNonce(sessionKey) {\n    const counter = (sessionKey.counter || 0) + 1;\n    sessionKey.counter = counter;\n    // Generate deterministic nonce from base nonce + counter\n    const nonce = new Uint8Array(24);\n    nonce.set(sessionKey.nonce.slice(0, 16), 0);\n    // Encode counter in last 8 bytes (big-endian)\n    const counterBigInt = BigInt(counter);\n    for (let i = 7; i >= 0; i--) {\n        nonce[16 + (7 - i)] = Number((counterBigInt >> BigInt(i * 8)) & BigInt(0xff));\n    }\n    return nonce;\n}\n/**\n * Encrypt a message with XChaCha20-Poly1305 AEAD\n *\n * Algorithm: draft-irtf-cfrg-xchacha\n * - XChaCha20: Stream cipher with 192-bit nonce\n * - Poly1305: 128-bit authentication tag\n * - Combined: Authenticated Encryption with Associated Data (AEAD)\n *\n * Security Notes:\n * - NEVER reuse a nonce with the same key\n * - The nonce doesn't need to be secret, but must be unique\n * - Authentication tag prevents tampering\n * - Message size limits: 256 GB per message (2^38 - 64 bytes)\n *\n * @param plaintext - Data to encrypt\n * @param key - 32-byte encryption key\n * @param nonce - 24-byte nonce (must be unique per key)\n * @param associatedData - Optional data to authenticate but not encrypt\n * @returns Ciphertext with 16-byte authentication tag appended\n */\nexport function encryptMessage(plaintext, key, nonce, associatedData) {\n    if (key.length !== 32) {\n        throw new Error('Encryption key must be 32 bytes');\n    }\n    if (nonce.length !== 24) {\n        throw new Error('Nonce must be 24 bytes for XChaCha20-Poly1305');\n    }\n    const cipher = xchacha20poly1305(key, nonce);\n    return cipher.encrypt(plaintext, associatedData);\n}\n/**\n * Decrypt a message with XChaCha20-Poly1305 AEAD\n *\n * @param ciphertext - Encrypted data with authentication tag\n * @param key - 32-byte decryption key\n * @param nonce - 24-byte nonce (same as used for encryption)\n * @param associatedData - Optional associated data (must match encryption)\n * @returns Decrypted plaintext\n * @throws Error if authentication fails (tampering detected)\n */\nexport function decryptMessage(ciphertext, key, nonce, associatedData) {\n    if (key.length !== 32) {\n        throw new Error('Decryption key must be 32 bytes');\n    }\n    if (nonce.length !== 24) {\n        throw new Error('Nonce must be 24 bytes for XChaCha20-Poly1305');\n    }\n    if (ciphertext.length < 16) {\n        throw new Error('Ciphertext too short (must include 16-byte auth tag)');\n    }\n    try {\n        const cipher = xchacha20poly1305(key, nonce);\n        return cipher.decrypt(ciphertext, associatedData);\n    }\n    catch (error) {\n        // Wipe any partial decryption attempts\n        throw new Error('Decryption failed: authentication tag mismatch or corrupted data');\n    }\n}\n/**\n * Generate a fingerprint from a public key for verification\n * Uses SHA-256 for collision resistance\n *\n * @param publicKey - Public key to fingerprint\n * @returns Formatted fingerprint string (e.g., \"1a2b 3c4d 5e6f...\")\n */\nexport function generateFingerprint(publicKey) {\n    const hash = sha256(publicKey);\n    // Format as groups of 4 hex chars\n    const hex = Array.from(hash)\n        .map((b) => b.toString(16).padStart(2, '0'))\n        .join('');\n    return hex.match(/.{1,4}/g)?.join(' ') || hex;\n}\n/**\n * Derive a session key from shared secret using HKDF (RFC 5869)\n *\n * HKDF provides proper key derivation with:\n * - Extract: Derive pseudorandom key from secret\n * - Expand: Derive multiple keys from pseudorandom key\n *\n * @param sharedSecret - Shared secret from ECDH\n * @param salt - Salt value (should be random)\n * @param info - Context/application-specific info\n * @param length - Output key length (default: 32)\n * @returns Derived key\n */\nexport function deriveSessionKey(sharedSecret, salt, info, length = 32) {\n    return hkdf(sha256, sharedSecret, salt, info || new Uint8Array(0), length);\n}\n/**\n * Rotate session key for perfect forward secrecy\n *\n * Rotation Triggers:\n * - Time-based: After specified duration\n * - Message-based: After N messages\n * - Manual: On-demand rotation\n *\n * @param currentKey - Current session key\n * @param reason - Optional reason for rotation (for logging)\n * @returns New session key\n */\nexport function rotateSessionKey(currentKey, reason) {\n    // Derive new key from current key using HKDF\n    const info = reason ? new TextEncoder().encode(reason) : new Uint8Array(0);\n    const newKeyMaterial = hkdf(sha256, currentKey.key, currentKey.nonce, info, 32);\n    // Wipe old key material from memory\n    secureWipe(currentKey.key);\n    secureWipe(currentKey.nonce);\n    return {\n        key: newKeyMaterial,\n        nonce: randomBytes(24),\n        timestamp: Date.now(),\n        messageCount: 0,\n        counter: 0,\n    };\n}\n/**\n * Check if session key should be rotated\n *\n * @param sessionKey - Session key to check\n * @param maxAge - Maximum age in milliseconds (default: 1 hour)\n * @param maxMessages - Maximum messages before rotation (default: 1000)\n * @returns true if rotation is needed\n */\nexport function shouldRotateKey(sessionKey, maxAge = 60 * 60 * 1000, // 1 hour\nmaxMessages = 1000) {\n    const age = Date.now() - sessionKey.timestamp;\n    const messageCount = sessionKey.messageCount || 0;\n    return age >= maxAge || messageCount >= maxMessages;\n}\n/**\n * Initialize Double Ratchet state\n *\n * @param sharedSecret - Initial shared secret from key exchange\n * @param isInitiator - True if we initiated the session\n * @returns Initial ratchet state\n */\nexport function initializeRatchet(sharedSecret, _isInitiator) {\n    // Derive root key and initial chain keys from shared secret\n    const rootKey = hkdf(sha256, sharedSecret, new Uint8Array(32), new TextEncoder().encode('root'), 32);\n    const sendChainKey = hkdf(sha256, sharedSecret, new Uint8Array(32), new TextEncoder().encode('send'), 32);\n    const receiveChainKey = hkdf(sha256, sharedSecret, new Uint8Array(32), new TextEncoder().encode('receive'), 32);\n    const dhRatchetKey = generateEphemeralKeyPair();\n    return {\n        rootKey,\n        sendChainKey,\n        receiveChainKey,\n        sendCounter: 0,\n        receiveCounter: 0,\n        previousSendCounter: 0,\n        dhRatchetKey,\n    };\n}\n/**\n * Perform DH ratchet step\n * Updates root key and chain keys using new ephemeral keypair\n *\n * @param state - Current ratchet state\n * @param peerPublicKey - Peer's public DH ratchet key\n * @returns Updated ratchet state\n */\nexport function ratchetStep(state, peerPublicKey) {\n    // Perform DH with peer's public key\n    const dhOutput = performKeyExchange(state.dhRatchetKey.privateKey, peerPublicKey);\n    // Derive new root key and chain keys\n    const newRootKey = hkdf(sha256, dhOutput, state.rootKey, new TextEncoder().encode('ratchet'), 32);\n    const newSendChainKey = hkdf(sha256, dhOutput, state.rootKey, new TextEncoder().encode('send'), 32);\n    const newReceiveChainKey = hkdf(sha256, dhOutput, state.rootKey, new TextEncoder().encode('receive'), 32);\n    // Generate new DH keypair for next ratchet\n    const newDHKey = generateEphemeralKeyPair();\n    // Wipe old keys\n    secureWipe(state.rootKey);\n    secureWipe(state.sendChainKey);\n    secureWipe(state.receiveChainKey);\n    secureWipe(state.dhRatchetKey.privateKey);\n    secureWipe(dhOutput);\n    return {\n        rootKey: newRootKey,\n        sendChainKey: newSendChainKey,\n        receiveChainKey: newReceiveChainKey,\n        sendCounter: 0,\n        receiveCounter: 0,\n        previousSendCounter: state.sendCounter,\n        dhRatchetKey: newDHKey,\n    };\n}\n/**\n * Derive message key from chain key\n * Advances the chain by one step\n *\n * @param chainKey - Current chain key\n * @returns New { messageKey, nextChainKey }\n */\nexport function deriveMessageKey(chainKey) {\n    const messageKey = hkdf(sha256, chainKey, new Uint8Array(1).fill(0x01), new TextEncoder().encode('message'), 32);\n    const nextChainKey = hkdf(sha256, chainKey, new Uint8Array(1).fill(0x02), new TextEncoder().encode('chain'), 32);\n    // Wipe old chain key\n    secureWipe(chainKey);\n    return { messageKey, nextChainKey };\n}\n/**\n * Generate a symmetric encryption key (32 bytes for XChaCha20-Poly1305)\n * This is a convenience function for generating random symmetric keys.\n *\n * @returns 32-byte random key suitable for symmetric encryption\n * @throws Error if entropy validation fails\n */\nexport function generateKey() {\n    const key = randomBytes(32);\n    if (!validateEntropy(key)) {\n        throw new Error('Insufficient entropy for key generation');\n    }\n    return key;\n}\n/**\n * Generate a nonce for XChaCha20-Poly1305 encryption (24 bytes)\n * Nonces must NEVER be reused with the same key.\n *\n * @returns 24-byte random nonce\n */\nexport function generateNonce() {\n    return randomBytes(24);\n}\n/**\n * Alias for generateIdentity for API compatibility\n * Generates a new Ed25519 keypair for signing and identity\n */\nexport const generateKeyPair = generateIdentity;\n/**\n * Derive a shared secret using X25519 ECDH\n * Alias for performKeyExchange for API compatibility\n *\n * @param privateKey - Our private key (32 bytes)\n * @param peerPublicKey - Peer's public key (32 bytes)\n * @param salt - Optional salt for HKDF derivation\n * @param info - Optional info/context for HKDF derivation\n * @returns Derived 32-byte shared secret\n */\nexport function deriveSharedSecret(privateKey, peerPublicKey, salt, info) {\n    return performKeyExchange(privateKey, peerPublicKey, salt, info);\n}\n", "/**\n * Binary Message Format for Sovereign Communications\n *\n * Wire Protocol Documentation:\n * ===========================\n *\n * Endianness: All multi-byte integers use Big Endian (network byte order)\n *\n * Header Structure (fixed 108 bytes):\n * Offset | Size | Field      | Description\n * -------|------|------------|------------------------------------------\n * 0      | 1    | Version    | Protocol version (current: 0x01)\n * 1      | 1    | Type       | Message type (see MessageType enum)\n * 2      | 1    | TTL        | Time-to-live for mesh routing (max: 255)\n * 3      | 1    | Reserved   | Reserved for future use (must be 0x00)\n * 4      | 8    | Timestamp  | Unix timestamp in milliseconds (big-endian)\n * 12     | 32   | Sender ID  | Ed25519 public key of sender\n * 44     | 64   | Signature  | Compact Ed25519 signature of message\n *\n * Body:\n * - Encrypted payload (variable length, max: MAX_PAYLOAD_SIZE)\n *\n * Version Migration:\n * - v1 (0x01): Initial protocol version\n * - Future versions will maintain backward compatibility where possible\n */\nimport { sha256 } from '@noble/hashes/sha2.js';\nexport var MessageType;\n(function (MessageType) {\n    // Data messages\n    MessageType[MessageType[\"TEXT\"] = 1] = \"TEXT\";\n    MessageType[MessageType[\"FILE_METADATA\"] = 2] = \"FILE_METADATA\";\n    MessageType[MessageType[\"FILE_CHUNK\"] = 3] = \"FILE_CHUNK\";\n    MessageType[MessageType[\"VOICE\"] = 4] = \"VOICE\";\n    // Control messages\n    MessageType[MessageType[\"CONTROL_ACK\"] = 16] = \"CONTROL_ACK\";\n    MessageType[MessageType[\"CONTROL_PING\"] = 17] = \"CONTROL_PING\";\n    MessageType[MessageType[\"CONTROL_PONG\"] = 18] = \"CONTROL_PONG\";\n    // Peer management\n    MessageType[MessageType[\"PEER_DISCOVERY\"] = 32] = \"PEER_DISCOVERY\";\n    MessageType[MessageType[\"PEER_INTRODUCTION\"] = 33] = \"PEER_INTRODUCTION\";\n    // Cryptographic\n    MessageType[MessageType[\"KEY_EXCHANGE\"] = 48] = \"KEY_EXCHANGE\";\n    MessageType[MessageType[\"SESSION_KEY\"] = 49] = \"SESSION_KEY\";\n})(MessageType || (MessageType = {}));\n// Protocol constants\nexport const PROTOCOL_VERSION = 0x01;\nexport const MIN_SUPPORTED_VERSION = 0x01;\nexport const MAX_SUPPORTED_VERSION = 0x01;\nexport const HEADER_SIZE = 108; // 1 + 1 + 1 + 1 + 8 + 32 + 64 (compact signature)\nexport const MAX_PAYLOAD_SIZE = 1024 * 1024; // 1 MB max payload\nexport const MAX_TTL = 255;\n/**\n * Validation error with detailed context\n */\nexport class MessageValidationError extends Error {\n    constructor(message, field, value) {\n        super(message);\n        this.field = field;\n        this.value = value;\n        this.name = 'MessageValidationError';\n    }\n}\n/**\n * Validate message header fields\n * @throws {MessageValidationError} if validation fails\n */\nexport function validateHeader(header) {\n    // Validate version\n    if (header.version < MIN_SUPPORTED_VERSION || header.version > MAX_SUPPORTED_VERSION) {\n        throw new MessageValidationError(`Unsupported protocol version: ${header.version}. Supported: ${MIN_SUPPORTED_VERSION}-${MAX_SUPPORTED_VERSION}`, 'version', header.version);\n    }\n    // Validate message type\n    const validTypes = Object.values(MessageType).filter(v => typeof v === 'number');\n    if (!validTypes.includes(header.type)) {\n        throw new MessageValidationError(`Invalid message type: 0x${header.type.toString(16).padStart(2, '0')}`, 'type', header.type);\n    }\n    // Validate TTL\n    if (header.ttl < 0 || header.ttl > MAX_TTL) {\n        throw new MessageValidationError(`Invalid TTL: ${header.ttl}. Must be 0-${MAX_TTL}`, 'ttl', header.ttl);\n    }\n    // Validate timestamp\n    if (!Number.isSafeInteger(header.timestamp) || header.timestamp < 0) {\n        throw new MessageValidationError(`Invalid timestamp: ${header.timestamp}`, 'timestamp', header.timestamp);\n    }\n    // Validate sender ID size\n    if (header.senderId.length !== 32) {\n        throw new MessageValidationError(`Invalid sender ID length: ${header.senderId.length}. Expected: 32`, 'senderId', header.senderId.length);\n    }\n    // Validate signature size\n    // Ed25519 signatures can be 64 bytes (standard) or 65 bytes (compact with recovery byte)\n    if (header.signature.length !== 64 && header.signature.length !== 65) {\n        throw new MessageValidationError(`Invalid signature length: ${header.signature.length}. Expected: 64 or 65`, 'signature', header.signature.length);\n    }\n}\n/**\n * Validate complete message\n * @throws {MessageValidationError} if validation fails\n */\nexport function validateMessage(message) {\n    validateHeader(message.header);\n    // Validate payload size\n    if (message.payload.length > MAX_PAYLOAD_SIZE) {\n        throw new MessageValidationError(`Payload too large: ${message.payload.length} bytes. Max: ${MAX_PAYLOAD_SIZE}`, 'payload', message.payload.length);\n    }\n}\n/**\n * Encode a message header to binary format (Big Endian)\n * @throws {MessageValidationError} if header is invalid\n */\nexport function encodeHeader(header) {\n    // Validate before encoding\n    validateHeader(header);\n    const buffer = new Uint8Array(HEADER_SIZE);\n    let offset = 0;\n    // Version (1 byte)\n    buffer[offset++] = header.version;\n    // Type (1 byte)\n    buffer[offset++] = header.type;\n    // TTL (1 byte)\n    buffer[offset++] = header.ttl;\n    // Reserved (1 byte)\n    buffer[offset++] = 0;\n    // Timestamp (8 bytes, big-endian)\n    const timestamp = BigInt(header.timestamp);\n    for (let i = 7; i >= 0; i--) {\n        buffer[offset++] = Number((timestamp >> BigInt(i * 8)) & BigInt(0xff));\n    }\n    // Sender ID (32 bytes)\n    buffer.set(header.senderId, offset);\n    offset += 32;\n    // Signature (64 bytes - Ed25519 signature)\n    buffer.set(header.signature, offset);\n    return buffer;\n}\n/**\n * Decode a message header from binary format (Big Endian)\n * @throws {MessageValidationError} if buffer is invalid or too small\n */\nexport function decodeHeader(buffer) {\n    if (buffer.length < HEADER_SIZE) {\n        throw new MessageValidationError(`Invalid header size: ${buffer.length} bytes. Expected: ${HEADER_SIZE} bytes`, 'buffer', buffer.length);\n    }\n    let offset = 0;\n    const version = buffer[offset++];\n    const type = buffer[offset++];\n    const ttl = buffer[offset++];\n    offset++; // Skip reserved byte\n    // Timestamp (8 bytes, big-endian)\n    let timestamp = 0;\n    for (let i = 0; i < 8; i++) {\n        timestamp = (timestamp * 256) + buffer[offset++];\n    }\n    // Sender ID (32 bytes)\n    const senderId = buffer.slice(offset, offset + 32);\n    offset += 32;\n    // Signature (64 bytes)\n    const signature = buffer.slice(offset, offset + 64);\n    const header = {\n        version,\n        type,\n        ttl,\n        timestamp,\n        senderId,\n        signature,\n    };\n    // Validate decoded header\n    validateHeader(header);\n    return header;\n}\n/**\n * Encode a complete message (header + payload)\n * @throws {MessageValidationError} if message is invalid\n */\nexport function encodeMessage(message) {\n    // Validate before encoding\n    validateMessage(message);\n    const headerBytes = encodeHeader(message.header);\n    const result = new Uint8Array(headerBytes.length + message.payload.length);\n    result.set(headerBytes, 0);\n    result.set(message.payload, headerBytes.length);\n    return result;\n}\n/**\n * Decode a complete message (header + payload)\n * @throws {MessageValidationError} if buffer is invalid\n */\nexport function decodeMessage(buffer) {\n    if (buffer.length < HEADER_SIZE) {\n        throw new MessageValidationError(`Buffer too small: ${buffer.length} bytes. Minimum: ${HEADER_SIZE} bytes`, 'buffer', buffer.length);\n    }\n    const header = decodeHeader(buffer.slice(0, HEADER_SIZE));\n    const payload = buffer.slice(HEADER_SIZE);\n    const message = { header, payload };\n    // Validate complete message\n    validateMessage(message);\n    return message;\n}\n/**\n * Create a cryptographically secure message hash for deduplication\n * Uses SHA-256 for collision resistance\n */\nexport function messageHash(message) {\n    const messageBytes = encodeMessage(message);\n    const hash = sha256(messageBytes);\n    // Convert to hex string\n    return Array.from(hash)\n        .map((b) => b.toString(16).padStart(2, '0'))\n        .join('');\n}\n/**\n * Check if a version is supported\n */\nexport function isVersionSupported(version) {\n    return version >= MIN_SUPPORTED_VERSION && version <= MAX_SUPPORTED_VERSION;\n}\n/**\n * Get human-readable message type name\n */\nexport function getMessageTypeName(type) {\n    const typeNames = {\n        [MessageType.TEXT]: 'TEXT',\n        [MessageType.FILE_METADATA]: 'FILE_METADATA',\n        [MessageType.FILE_CHUNK]: 'FILE_CHUNK',\n        [MessageType.VOICE]: 'VOICE',\n        [MessageType.CONTROL_ACK]: 'CONTROL_ACK',\n        [MessageType.CONTROL_PING]: 'CONTROL_PING',\n        [MessageType.CONTROL_PONG]: 'CONTROL_PONG',\n        [MessageType.PEER_DISCOVERY]: 'PEER_DISCOVERY',\n        [MessageType.PEER_INTRODUCTION]: 'PEER_INTRODUCTION',\n        [MessageType.KEY_EXCHANGE]: 'KEY_EXCHANGE',\n        [MessageType.SESSION_KEY]: 'SESSION_KEY',\n    };\n    return typeNames[type] || `UNKNOWN(0x${type.toString(16).padStart(2, '0')})`;\n}\n", "/**\n * Mesh networking core - routing table and peer management\n */\nimport { MessageType } from \"../protocol/message.js\";\nexport var PeerState;\n(function (PeerState) {\n    PeerState[\"CONNECTING\"] = \"connecting\";\n    PeerState[\"CONNECTED\"] = \"connected\";\n    PeerState[\"DEGRADED\"] = \"degraded\";\n    PeerState[\"DISCONNECTED\"] = \"disconnected\";\n})(PeerState || (PeerState = {}));\n/**\n * Create a new peer with default values\n */\nexport function createPeer(id, publicKey, transportType = \"webrtc\") {\n    return {\n        id,\n        publicKey,\n        lastSeen: Date.now(),\n        connectedAt: Date.now(),\n        transportType,\n        connectionQuality: 100,\n        bytesSent: 0,\n        bytesReceived: 0,\n        state: PeerState.CONNECTED,\n        metadata: {\n            capabilities: {\n                supportedTransports: [transportType],\n                protocolVersion: 1,\n                features: [],\n            },\n            reputation: 50,\n            blacklisted: false,\n            failureCount: 0,\n            successCount: 0,\n        },\n    };\n}\n/**\n * In-memory routing table for mesh network\n */\nexport class RoutingTable {\n    constructor(config = {}) {\n        this.routes = new Map();\n        this.peers = new Map();\n        this.messageCache = new Map(); // hash -> timestamp\n        this.bloomFilter = new Set(); // Simple bloom filter\n        this.MAX_CACHE_SIZE = config.maxCacheSize || 10000;\n        this.CACHE_TTL = config.cacheTTL || 60000; // 60 seconds\n        this.ROUTE_TTL = config.routeTTL || 300000; // 5 minutes\n        this.MAX_ROUTES = config.maxRoutes || 10000;\n        this.ENABLE_BLOOM = config.enableBloomFilter !== false;\n    }\n    /**\n     * Add or update a peer\n     */\n    addPeer(peer) {\n        // Ensure peer has required metadata\n        if (!peer.state) {\n            peer.state = PeerState.CONNECTED;\n        }\n        if (!peer.metadata) {\n            peer.metadata = {\n                capabilities: {\n                    supportedTransports: [peer.transportType],\n                    protocolVersion: 1,\n                    features: [],\n                },\n                reputation: 50,\n                blacklisted: false,\n                failureCount: 0,\n                successCount: 0,\n            };\n        }\n        this.peers.set(peer.id, peer);\n        // Direct route to connected peer\n        this.routes.set(peer.id, {\n            destination: peer.id,\n            nextHop: peer.id,\n            hopCount: 0,\n            timestamp: Date.now(),\n            metrics: {\n                hopCount: 0,\n                latency: 0,\n                reliability: 1.0,\n                bandwidth: 0,\n                lastUsed: Date.now(),\n            },\n            expiresAt: Date.now() + this.ROUTE_TTL,\n        });\n    }\n    /**\n     * Remove a peer\n     */\n    removePeer(peerId) {\n        this.peers.delete(peerId);\n        this.routes.delete(peerId);\n        // Remove routes that go through this peer\n        for (const [dest, route] of this.routes.entries()) {\n            if (route.nextHop === peerId) {\n                this.routes.delete(dest);\n            }\n        }\n    }\n    /**\n     * Get a peer by ID\n     */\n    getPeer(peerId) {\n        return this.peers.get(peerId);\n    }\n    /**\n     * Get all connected peers\n     */\n    getAllPeers() {\n        return Array.from(this.peers.values());\n    }\n    /**\n     * Update peer last seen timestamp\n     */\n    updatePeerLastSeen(peerId) {\n        const peer = this.peers.get(peerId);\n        if (peer) {\n            peer.lastSeen = Date.now();\n        }\n    }\n    /**\n     * Add or update a route with conflict resolution\n     */\n    addRoute(route) {\n        const existing = this.routes.get(route.destination);\n        // Route conflict resolution based on metrics\n        const shouldUpdate = !existing || this.shouldReplaceRoute(existing, route);\n        if (shouldUpdate) {\n            // Ensure route has expiry\n            if (!route.expiresAt) {\n                route.expiresAt = Date.now() + this.ROUTE_TTL;\n            }\n            this.routes.set(route.destination, route);\n            this.cleanupExpiredRoutes();\n        }\n    }\n    /**\n     * Determine if new route should replace existing route\n     */\n    shouldReplaceRoute(existing, newRoute) {\n        // Check if existing route is expired\n        if (existing.expiresAt < Date.now()) {\n            return true;\n        }\n        // Prefer routes with fewer hops\n        if (newRoute.metrics.hopCount < existing.metrics.hopCount) {\n            return true;\n        }\n        // If same hop count, prefer lower latency\n        if (newRoute.metrics.hopCount === existing.metrics.hopCount) {\n            if (newRoute.metrics.latency < existing.metrics.latency) {\n                return true;\n            }\n            // If same latency, prefer higher reliability\n            if (newRoute.metrics.latency === existing.metrics.latency) {\n                if (newRoute.metrics.reliability > existing.metrics.reliability) {\n                    return true;\n                }\n                // If same reliability, prefer higher bandwidth\n                const newBw = newRoute.metrics.bandwidth || 0;\n                const existingBw = existing.metrics.bandwidth || 0;\n                if (newRoute.metrics.reliability === existing.metrics.reliability &&\n                    newBw > existingBw) {\n                    return true;\n                }\n            }\n            // If metrics equal, prefer newer route\n            if (newRoute.metrics.latency === existing.metrics.latency &&\n                newRoute.metrics.reliability === existing.metrics.reliability &&\n                (newRoute.metrics.bandwidth || 0) ===\n                    (existing.metrics.bandwidth || 0) &&\n                newRoute.timestamp > existing.timestamp) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Clean up expired routes\n     */\n    cleanupExpiredRoutes() {\n        if (this.routes.size < this.MAX_ROUTES) {\n            return;\n        }\n        const now = Date.now();\n        const toDelete = [];\n        for (const [dest, route] of this.routes.entries()) {\n            if (route.expiresAt < now) {\n                toDelete.push(dest);\n            }\n        }\n        toDelete.forEach((dest) => this.routes.delete(dest));\n        // If still over limit, remove least recently used routes\n        if (this.routes.size >= this.MAX_ROUTES) {\n            const routes = Array.from(this.routes.entries()).sort((a, b) => a[1].metrics.lastUsed - b[1].metrics.lastUsed);\n            const removeCount = this.routes.size - this.MAX_ROUTES + 100;\n            for (let i = 0; i < removeCount && i < routes.length; i++) {\n                this.routes.delete(routes[i][0]);\n            }\n        }\n    }\n    /**\n     * Update route metrics\n     */\n    updateRouteMetrics(destination, latency, success, bandwidth) {\n        const route = this.routes.get(destination);\n        if (route) {\n            route.metrics.latency = latency;\n            route.metrics.lastUsed = Date.now();\n            // Update reliability with exponential moving average\n            const alpha = 0.3;\n            route.metrics.reliability =\n                alpha * (success ? 1 : 0) + (1 - alpha) * route.metrics.reliability;\n            if (bandwidth !== undefined) {\n                route.metrics.bandwidth = bandwidth;\n            }\n        }\n    }\n    /**\n     * Get next hop for a destination\n     */\n    getNextHop(destination) {\n        const route = this.routes.get(destination);\n        return route?.nextHop;\n    }\n    /**\n     * Check if message has been seen (for deduplication)\n     * Uses Bloom filter for fast pre-check if enabled\n     */\n    hasSeenMessage(messageHash) {\n        // Fast bloom filter check\n        if (this.ENABLE_BLOOM && !this.bloomFilter.has(messageHash)) {\n            return false;\n        }\n        return this.messageCache.has(messageHash);\n    }\n    /**\n     * Mark message as seen with LRU eviction\n     */\n    markMessageSeen(messageHash) {\n        this.messageCache.set(messageHash, Date.now());\n        if (this.ENABLE_BLOOM) {\n            this.bloomFilter.add(messageHash);\n        }\n        this.cleanupMessageCache();\n    }\n    /**\n     * Clean up old entries from message cache with LRU eviction\n     */\n    cleanupMessageCache() {\n        const now = Date.now();\n        // If cache is below max size, just remove expired entries\n        if (this.messageCache.size < this.MAX_CACHE_SIZE) {\n            const toDelete = [];\n            for (const [hash, timestamp] of this.messageCache.entries()) {\n                if (now - timestamp > this.CACHE_TTL) {\n                    toDelete.push(hash);\n                }\n            }\n            toDelete.forEach((hash) => {\n                this.messageCache.delete(hash);\n                if (this.ENABLE_BLOOM) {\n                    this.bloomFilter.delete(hash);\n                }\n            });\n            return;\n        }\n        // LRU eviction: sort by timestamp and remove oldest\n        const entries = Array.from(this.messageCache.entries()).sort((a, b) => a[1] - b[1]);\n        const removeCount = this.messageCache.size - this.MAX_CACHE_SIZE + 100;\n        for (let i = 0; i < removeCount && i < entries.length; i++) {\n            this.messageCache.delete(entries[i][0]);\n            if (this.ENABLE_BLOOM) {\n                this.bloomFilter.delete(entries[i][0]);\n            }\n        }\n    }\n    /**\n     * Update peer reputation based on behavior\n     */\n    updatePeerReputation(peerId, success) {\n        const peer = this.peers.get(peerId);\n        if (!peer)\n            return;\n        if (success) {\n            peer.metadata.successCount++;\n            peer.metadata.reputation = Math.min(100, peer.metadata.reputation + 1);\n        }\n        else {\n            peer.metadata.failureCount++;\n            peer.metadata.reputation = Math.max(0, peer.metadata.reputation - 2);\n        }\n        // Update peer state based on reputation\n        if (peer.metadata.reputation < 20) {\n            peer.state = PeerState.DEGRADED;\n        }\n        else if (peer.state === PeerState.DEGRADED &&\n            peer.metadata.reputation > 40) {\n            peer.state = PeerState.CONNECTED;\n        }\n    }\n    /**\n     * Blacklist a peer temporarily or permanently\n     */\n    blacklistPeer(peerId, durationMs) {\n        const peer = this.peers.get(peerId);\n        if (!peer)\n            return;\n        peer.metadata.blacklisted = true;\n        if (durationMs) {\n            peer.metadata.blacklistExpiry = Date.now() + durationMs;\n        }\n        peer.state = PeerState.DISCONNECTED;\n    }\n    /**\n     * Remove peer from blacklist\n     */\n    unblacklistPeer(peerId) {\n        const peer = this.peers.get(peerId);\n        if (!peer)\n            return;\n        peer.metadata.blacklisted = false;\n        peer.metadata.blacklistExpiry = undefined;\n    }\n    /**\n     * Check and clean up expired blacklists\n     */\n    cleanupBlacklists() {\n        const now = Date.now();\n        for (const peer of this.peers.values()) {\n            if (peer.metadata.blacklisted &&\n                peer.metadata.blacklistExpiry &&\n                peer.metadata.blacklistExpiry < now) {\n                this.unblacklistPeer(peer.id);\n            }\n        }\n    }\n    /**\n     * Check if peer is blacklisted\n     */\n    isPeerBlacklisted(peerId) {\n        const peer = this.peers.get(peerId);\n        if (!peer)\n            return false;\n        // Check expiry\n        if (peer.metadata.blacklisted && peer.metadata.blacklistExpiry) {\n            if (peer.metadata.blacklistExpiry < Date.now()) {\n                this.unblacklistPeer(peerId);\n                return false;\n            }\n        }\n        return peer.metadata.blacklisted;\n    }\n    /**\n     * Remove stale peers (haven't been seen recently)\n     */\n    removeStalepeers(timeoutMs = 60000) {\n        const now = Date.now();\n        const stale = [];\n        for (const [id, peer] of this.peers.entries()) {\n            if (now - peer.lastSeen > timeoutMs) {\n                stale.push(id);\n            }\n        }\n        stale.forEach((id) => this.removePeer(id));\n        return stale;\n    }\n    /**\n     * Get memory usage statistics\n     */\n    getMemoryUsage() {\n        const breakdown = {\n            routes: this.routes.size * 100, // Approximate size per route\n            peers: this.peers.size * 200, // Approximate size per peer\n            messageCache: this.messageCache.size * 50, // Approximate size per hash\n            bloomFilter: this.bloomFilter.size * 50,\n        };\n        const bytes = Object.values(breakdown).reduce((sum, val) => sum + val, 0);\n        return { bytes, breakdown };\n    }\n    /**\n     * Get routing table statistics\n     */\n    getStats() {\n        return {\n            peerCount: this.peers.size,\n            routeCount: this.routes.size,\n            cacheSize: this.messageCache.size,\n            memoryUsage: this.getMemoryUsage().bytes,\n        };\n    }\n}\n/**\n * Message priority queue with starvation prevention\n */\nexport class MessageQueue {\n    constructor() {\n        this.queues = new Map();\n        this.priorities = [\n            MessageType.CONTROL_PING,\n            MessageType.CONTROL_PONG,\n            MessageType.CONTROL_ACK,\n            MessageType.VOICE,\n            MessageType.TEXT,\n            MessageType.FILE_CHUNK,\n            MessageType.FILE_METADATA,\n        ];\n        this.ESCALATION_THRESHOLD = 30000; // 30 seconds\n        this.STARVATION_CHECK_INTERVAL = 5000; // 5 seconds\n        this.lastStarvationCheck = Date.now();\n    }\n    enqueue(messageType, message) {\n        if (!this.queues.has(messageType)) {\n            this.queues.set(messageType, []);\n        }\n        this.queues.get(messageType).push({\n            message,\n            timestamp: Date.now(),\n            originalPriority: messageType,\n        });\n    }\n    dequeue() {\n        // Check for starvation periodically\n        const now = Date.now();\n        if (now - this.lastStarvationCheck > this.STARVATION_CHECK_INTERVAL) {\n            this.preventStarvation();\n            this.lastStarvationCheck = now;\n        }\n        // Process queues in priority order\n        for (const priority of this.priorities) {\n            const queue = this.queues.get(priority);\n            if (queue && queue.length > 0) {\n                const item = queue.shift();\n                return item?.message || null;\n            }\n        }\n        return null;\n    }\n    /**\n     * Prevent starvation by escalating old low-priority messages\n     */\n    preventStarvation() {\n        const now = Date.now();\n        // Check low-priority queues for old messages\n        for (let i = this.priorities.length - 1; i > 0; i--) {\n            const currentPriority = this.priorities[i];\n            const queue = this.queues.get(currentPriority);\n            if (!queue || queue.length === 0)\n                continue;\n            const itemsToEscalate = [];\n            const remainingItems = [];\n            for (const item of queue) {\n                const age = now - item.timestamp;\n                if (age > this.ESCALATION_THRESHOLD) {\n                    itemsToEscalate.push(item);\n                }\n                else {\n                    remainingItems.push(item);\n                }\n            }\n            // Update current queue\n            this.queues.set(currentPriority, remainingItems);\n            // Move escalated items to higher priority queue\n            if (itemsToEscalate.length > 0) {\n                const higherPriority = this.priorities[i - 1];\n                if (!this.queues.has(higherPriority)) {\n                    this.queues.set(higherPriority, []);\n                }\n                this.queues.get(higherPriority).push(...itemsToEscalate);\n            }\n        }\n    }\n    size() {\n        let total = 0;\n        for (const queue of this.queues.values()) {\n            total += queue.length;\n        }\n        return total;\n    }\n    /**\n     * Get size by priority level\n     */\n    getSizeByPriority() {\n        const sizes = new Map();\n        for (const [priority, queue] of this.queues.entries()) {\n            sizes.set(priority, queue.length);\n        }\n        return sizes;\n    }\n    /**\n     * Get oldest message age in queue\n     */\n    getOldestMessageAge() {\n        const now = Date.now();\n        let oldest = 0;\n        for (const queue of this.queues.values()) {\n            for (const item of queue) {\n                const age = now - item.timestamp;\n                if (age > oldest) {\n                    oldest = age;\n                }\n            }\n        }\n        return oldest;\n    }\n    clear() {\n        this.queues.clear();\n    }\n}\n", "/**\n * Envelope encryption utilities\n * Provides secure envelope sign/verify/encrypt/decrypt operations\n */\nimport { ed25519 } from '@noble/curves/ed25519.js';\nimport { x25519 } from '@noble/curves/ed25519.js';\nimport { sha256 } from '@noble/hashes/sha2.js';\nimport { xchacha20poly1305 } from '@noble/ciphers/chacha.js';\nimport { hkdf } from '@noble/hashes/hkdf.js';\nimport { randomBytes } from '@noble/hashes/utils.js';\nconst CURRENT_VERSION = 1;\nconst HKDF_INFO = new TextEncoder().encode('SC-Envelope-v1');\n/**\n * Encrypt data into a sealed envelope\n * Uses X25519 ECDH + XChaCha20-Poly1305 + Ed25519 signing\n *\n * @param data - Data to encrypt\n * @param senderPrivateKey - Sender's Ed25519 private key for signing\n * @param recipientPublicKey - Recipient's X25519 public key\n * @returns Encrypted and signed envelope\n */\nexport function encryptEnvelope(data, senderPrivateKey, recipientPublicKey) {\n    if (senderPrivateKey.length !== 32) {\n        throw new Error('Sender private key must be 32 bytes');\n    }\n    if (recipientPublicKey.length !== 32) {\n        throw new Error('Recipient public key must be 32 bytes');\n    }\n    // Generate ephemeral keypair for forward secrecy\n    const ephemeralPrivateKey = randomBytes(32);\n    const ephemeralPublicKey = x25519.getPublicKey(ephemeralPrivateKey);\n    // Perform ECDH\n    const sharedSecret = x25519.getSharedSecret(ephemeralPrivateKey, recipientPublicKey);\n    // Derive encryption key using HKDF\n    const encryptionKey = hkdf(sha256, sharedSecret, ephemeralPublicKey, // Use ephemeral public key as salt\n    HKDF_INFO, 32);\n    // Generate nonce\n    const nonce = randomBytes(24);\n    // Encrypt with XChaCha20-Poly1305\n    const cipher = xchacha20poly1305(encryptionKey, nonce);\n    const ciphertext = cipher.encrypt(data);\n    const timestamp = Date.now();\n    // Create envelope data to sign (without signature)\n    const envelopeData = new Uint8Array([\n        ...ephemeralPublicKey,\n        ...nonce,\n        ...ciphertext,\n        ...numberToBytes(timestamp),\n        CURRENT_VERSION\n    ]);\n    // Sign the envelope\n    const signature = ed25519.sign(envelopeData, senderPrivateKey);\n    // Wipe sensitive data\n    ephemeralPrivateKey.fill(0);\n    sharedSecret.fill(0);\n    encryptionKey.fill(0);\n    return {\n        ephemeralPublicKey,\n        nonce,\n        ciphertext,\n        signature,\n        timestamp,\n        version: CURRENT_VERSION\n    };\n}\n/**\n * Decrypt an envelope\n *\n * @param envelope - Encrypted envelope\n * @param recipientPrivateKey - Recipient's X25519 private key\n * @param senderPublicKey - Sender's Ed25519 public key for verification\n * @returns Decrypted data\n */\nexport function decryptEnvelope(envelope, recipientPrivateKey, senderPublicKey) {\n    if (recipientPrivateKey.length !== 32) {\n        throw new Error('Recipient private key must be 32 bytes');\n    }\n    if (senderPublicKey.length !== 32) {\n        throw new Error('Sender public key must be 32 bytes');\n    }\n    // Verify version\n    if (envelope.version !== CURRENT_VERSION) {\n        throw new Error(`Unsupported envelope version: ${envelope.version}`);\n    }\n    // Recreate envelope data for signature verification\n    const envelopeData = new Uint8Array([\n        ...envelope.ephemeralPublicKey,\n        ...envelope.nonce,\n        ...envelope.ciphertext,\n        ...numberToBytes(envelope.timestamp),\n        envelope.version\n    ]);\n    // Verify signature\n    const isValid = ed25519.verify(envelope.signature, envelopeData, senderPublicKey);\n    if (!isValid) {\n        throw new Error('Envelope signature verification failed');\n    }\n    // Perform ECDH\n    const sharedSecret = x25519.getSharedSecret(recipientPrivateKey, envelope.ephemeralPublicKey);\n    // Derive decryption key using HKDF\n    const decryptionKey = hkdf(sha256, sharedSecret, envelope.ephemeralPublicKey, HKDF_INFO, 32);\n    // Decrypt with XChaCha20-Poly1305\n    try {\n        const cipher = xchacha20poly1305(decryptionKey, envelope.nonce);\n        const plaintext = cipher.decrypt(envelope.ciphertext);\n        // Wipe sensitive data\n        sharedSecret.fill(0);\n        decryptionKey.fill(0);\n        return plaintext;\n    }\n    catch {\n        sharedSecret.fill(0);\n        decryptionKey.fill(0);\n        throw new Error('Envelope decryption failed: authentication tag mismatch');\n    }\n}\n/**\n * Sign data and create a signed envelope\n *\n * @param data - Data to sign\n * @param privateKey - Ed25519 private key\n * @returns Signed envelope\n */\nexport function signEnvelope(data, privateKey) {\n    if (privateKey.length !== 32) {\n        throw new Error('Private key must be 32 bytes');\n    }\n    const publicKey = ed25519.getPublicKey(privateKey);\n    const timestamp = Date.now();\n    // Create data to sign (data + timestamp)\n    const signedData = new Uint8Array([\n        ...data,\n        ...numberToBytes(timestamp)\n    ]);\n    const signature = ed25519.sign(signedData, privateKey);\n    return {\n        data,\n        signature,\n        senderPublicKey: publicKey,\n        timestamp\n    };\n}\n/**\n * Verify a signed envelope\n *\n * @param envelope - Signed envelope to verify\n * @param expectedPublicKey - Optional expected public key to verify against\n * @returns true if signature is valid\n */\nexport function verifyEnvelope(envelope, expectedPublicKey) {\n    // Verify public key if expected\n    if (expectedPublicKey) {\n        if (envelope.senderPublicKey.length !== expectedPublicKey.length) {\n            return false;\n        }\n        for (let i = 0; i < expectedPublicKey.length; i++) {\n            if (envelope.senderPublicKey[i] !== expectedPublicKey[i]) {\n                return false;\n            }\n        }\n    }\n    // Recreate signed data\n    const signedData = new Uint8Array([\n        ...envelope.data,\n        ...numberToBytes(envelope.timestamp)\n    ]);\n    try {\n        return ed25519.verify(envelope.signature, signedData, envelope.senderPublicKey);\n    }\n    catch {\n        return false;\n    }\n}\n/**\n * Serialize an encrypted envelope to bytes\n */\nexport function serializeEncryptedEnvelope(envelope) {\n    const timestampBytes = numberToBytes(envelope.timestamp);\n    const ciphertextLength = numberToBytes(envelope.ciphertext.length);\n    return new Uint8Array([\n        envelope.version,\n        ...envelope.ephemeralPublicKey, // 32 bytes\n        ...envelope.nonce, // 24 bytes\n        ...ciphertextLength, // 8 bytes\n        ...envelope.ciphertext, // variable\n        ...envelope.signature, // 64 bytes\n        ...timestampBytes // 8 bytes\n    ]);\n}\n/**\n * Deserialize bytes to an encrypted envelope\n */\nexport function deserializeEncryptedEnvelope(bytes) {\n    if (bytes.length < 137) { // minimum: 1 + 32 + 24 + 8 + 0 + 64 + 8\n        throw new Error('Invalid envelope: too short');\n    }\n    let offset = 0;\n    const version = bytes[offset++];\n    const ephemeralPublicKey = bytes.slice(offset, offset + 32);\n    offset += 32;\n    const nonce = bytes.slice(offset, offset + 24);\n    offset += 24;\n    const ciphertextLength = bytesToNumber(bytes.slice(offset, offset + 8));\n    offset += 8;\n    const ciphertext = bytes.slice(offset, offset + ciphertextLength);\n    offset += ciphertextLength;\n    const signature = bytes.slice(offset, offset + 64);\n    offset += 64;\n    const timestamp = bytesToNumber(bytes.slice(offset, offset + 8));\n    return {\n        version,\n        ephemeralPublicKey,\n        nonce,\n        ciphertext,\n        signature,\n        timestamp\n    };\n}\n/**\n * Serialize a signed envelope to bytes\n */\nexport function serializeSignedEnvelope(envelope) {\n    const timestampBytes = numberToBytes(envelope.timestamp);\n    const dataLength = numberToBytes(envelope.data.length);\n    return new Uint8Array([\n        ...envelope.senderPublicKey, // 32 bytes\n        ...dataLength, // 8 bytes\n        ...envelope.data, // variable\n        ...envelope.signature, // 64 bytes\n        ...timestampBytes // 8 bytes\n    ]);\n}\n/**\n * Deserialize bytes to a signed envelope\n */\nexport function deserializeSignedEnvelope(bytes) {\n    if (bytes.length < 112) { // minimum: 32 + 8 + 0 + 64 + 8\n        throw new Error('Invalid envelope: too short');\n    }\n    let offset = 0;\n    const senderPublicKey = bytes.slice(offset, offset + 32);\n    offset += 32;\n    const dataLength = bytesToNumber(bytes.slice(offset, offset + 8));\n    offset += 8;\n    const data = bytes.slice(offset, offset + dataLength);\n    offset += dataLength;\n    const signature = bytes.slice(offset, offset + 64);\n    offset += 64;\n    const timestamp = bytesToNumber(bytes.slice(offset, offset + 8));\n    return {\n        senderPublicKey,\n        data,\n        signature,\n        timestamp\n    };\n}\n/**\n * Convert a number to 8 bytes (big-endian)\n */\nfunction numberToBytes(num) {\n    const bytes = new Uint8Array(8);\n    let n = num;\n    for (let i = 7; i >= 0; i--) {\n        bytes[i] = n & 0xff;\n        n = Math.floor(n / 256);\n    }\n    return bytes;\n}\n/**\n * Convert 8 bytes to a number (big-endian)\n */\nfunction bytesToNumber(bytes) {\n    let num = 0;\n    for (let i = 0; i < 8; i++) {\n        num = num * 256 + bytes[i];\n    }\n    return num;\n}\n", "/**\n * Transport Abstraction Layer\n *\n * Defines a platform-agnostic transport interface that all mesh/routing logic\n * depends on. Concrete implementations (WebRTC, BLE, Wi-Fi Direct, etc.) are\n * provided by platform-specific code.\n *\n * This abstraction ensures protocol and routing logic remain decoupled from\n * platform-specific APIs (browser WebRTC, Android BLE, iOS CoreBluetooth, etc.).\n */\n/**\n * Default transport registry implementation.\n */\nexport class DefaultTransportRegistry {\n    constructor() {\n        this.factories = new Map();\n    }\n    register(type, factory) {\n        this.factories.set(type, factory);\n    }\n    get(type) {\n        return this.factories.get(type);\n    }\n    getTypes() {\n        return Array.from(this.factories.keys());\n    }\n}\n/**\n * Global transport registry instance.\n */\nexport const transportRegistry = new DefaultTransportRegistry();\n", "// Utility functions for public key fingerprints and validation\n/**\n * Generate a human-readable fingerprint from a public key\n * Uses SHA-256 hash and formats as hex string\n */\nexport async function generateFingerprint(publicKey) {\n    let keyBytes;\n    if (typeof publicKey === \"string\") {\n        // Convert hex string or base64 to Uint8Array\n        if (publicKey.match(/^[0-9a-fA-F]+$/)) {\n            // Hex string\n            keyBytes = hexToBytes(publicKey);\n        }\n        else {\n            // Base64 string\n            keyBytes = base64ToBytes(publicKey);\n        }\n    }\n    else {\n        keyBytes = publicKey;\n    }\n    // Hash the public key\n    const hashBuffer = await crypto.subtle.digest(\"SHA-256\", keyBytes);\n    const hashArray = Array.from(new Uint8Array(hashBuffer));\n    // Convert to hex and take first 16 characters for display\n    const hex = hashArray.map((b) => b.toString(16).padStart(2, \"0\")).join(\"\");\n    return hex.substring(0, 16).toUpperCase();\n}\n/**\n * Generate a full fingerprint (64 characters) for verification\n */\nexport async function generateFullFingerprint(publicKey) {\n    let keyBytes;\n    if (typeof publicKey === \"string\") {\n        if (publicKey.match(/^[0-9a-fA-F]+$/)) {\n            keyBytes = hexToBytes(publicKey);\n        }\n        else {\n            keyBytes = base64ToBytes(publicKey);\n        }\n    }\n    else {\n        keyBytes = publicKey;\n    }\n    const hashBuffer = await crypto.subtle.digest(\"SHA-256\", keyBytes);\n    const hashArray = Array.from(new Uint8Array(hashBuffer));\n    return hashArray\n        .map((b) => b.toString(16).padStart(2, \"0\"))\n        .join(\"\")\n        .toUpperCase();\n}\n/**\n * Format fingerprint for display (groups of 4 characters)\n * Example: \"A1B2 C3D4 E5F6 G7H8\"\n */\nexport function formatFingerprint(fingerprint) {\n    return fingerprint.match(/.{1,4}/g)?.join(\" \") || fingerprint;\n}\n/**\n * Validate public key format\n */\nexport function isValidPublicKey(publicKey) {\n    if (typeof publicKey === \"string\") {\n        // Check if it's a valid hex string (64 characters for Ed25519)\n        if (publicKey.match(/^[0-9a-fA-F]{64}$/)) {\n            return true;\n        }\n        // Check if it's a valid base64 string\n        try {\n            const decoded = atob(publicKey);\n            return decoded.length === 32; // Ed25519 public key is 32 bytes\n        }\n        catch {\n            return false;\n        }\n    }\n    else {\n        // Uint8Array should be 32 bytes for Ed25519\n        return publicKey.length === 32;\n    }\n}\n/**\n * Convert public key to base64 for storage\n */\nexport function publicKeyToBase64(publicKey) {\n    return btoa(String.fromCharCode(...publicKey));\n}\n/**\n * Convert base64 to public key bytes\n */\nexport function base64ToPublicKey(base64) {\n    const binary = atob(base64);\n    const bytes = new Uint8Array(binary.length);\n    for (let i = 0; i < binary.length; i++) {\n        bytes[i] = binary.charCodeAt(i);\n    }\n    return bytes;\n}\n// Helper functions\nfunction hexToBytes(hex) {\n    const bytes = new Uint8Array(hex.length / 2);\n    for (let i = 0; i < hex.length; i += 2) {\n        bytes[i / 2] = parseInt(hex.substr(i, 2), 16);\n    }\n    return bytes;\n}\nfunction base64ToBytes(base64) {\n    const binary = atob(base64);\n    const bytes = new Uint8Array(binary.length);\n    for (let i = 0; i < binary.length; i++) {\n        bytes[i] = binary.charCodeAt(i);\n    }\n    return bytes;\n}\n/**\n * Compare two fingerprints for equality\n */\nexport function compareFingerprints(fp1, fp2) {\n    return (fp1.toUpperCase().replace(/\\s/g, \"\") ===\n        fp2.toUpperCase().replace(/\\s/g, \"\"));\n}\n", "/**\n * Message Relay and Flood Routing Implementation\n */\nimport { MessageType, messageHash, decodeMessage } from '../protocol/message.js';\n/**\n * Default In-Memory Persistence Adapter\n */\nexport class MemoryPersistenceAdapter {\n    constructor() {\n        this.storage = new Map();\n    }\n    async saveMessage(id, message) {\n        this.storage.set(id, message);\n    }\n    async getMessage(id) {\n        return this.storage.get(id) || null;\n    }\n    async removeMessage(id) {\n        this.storage.delete(id);\n    }\n    async getAllMessages() {\n        return new Map(this.storage);\n    }\n    async pruneExpired(now) {\n        for (const [id, msg] of this.storage.entries()) {\n            if (msg.expiresAt < now) {\n                this.storage.delete(id);\n            }\n        }\n    }\n    async size() {\n        return this.storage.size;\n    }\n}\n/**\n * Message Relay Engine\n * Implements flood routing with TTL, deduplication, and store-and-forward\n */\nexport class MessageRelay {\n    constructor(localPeerId, routingTable, config = {}, persistence) {\n        this.stats = {\n            messagesReceived: 0,\n            messagesForwarded: 0,\n            messagesDuplicate: 0,\n            messagesExpired: 0,\n            messagesForSelf: 0,\n            messagesStored: 0,\n            relayFailures: 0,\n            loopsDetected: 0,\n        };\n        this.messageRoutes = new Map(); // messageHash -> path of peer IDs\n        this.peerFloodCounter = new Map(); // peerId -> timestamps\n        this.localPeerId = localPeerId;\n        this.routingTable = routingTable;\n        this.config = {\n            maxStoredMessages: config.maxStoredMessages || 1000,\n            storeTimeout: config.storeTimeout || 300000, // 5 minutes\n            maxRetries: config.maxRetries || 3,\n            retryBackoff: config.retryBackoff || 5000, // 5 seconds\n            floodRateLimit: config.floodRateLimit || 100, // 100 msg/sec per peer\n            selectiveFlooding: config.selectiveFlooding !== false,\n        };\n        this.persistence = persistence || new MemoryPersistenceAdapter();\n    }\n    /**\n     * Process incoming message and decide whether to forward, deliver, or drop\n     */\n    async processMessage(messageData, fromPeerId) {\n        this.stats.messagesReceived++;\n        let message;\n        try {\n            message = decodeMessage(messageData);\n        }\n        catch (error) {\n            console.error('Failed to decode message:', error);\n            return;\n        }\n        // Step 1: Check if we've seen this message before (deduplication)\n        const hash = messageHash(message);\n        if (this.routingTable.hasSeenMessage(hash)) {\n            this.stats.messagesDuplicate++;\n            return; // Drop duplicate\n        }\n        // Step 2: Check for routing loops\n        if (this.detectLoop(hash, fromPeerId)) {\n            this.stats.loopsDetected++;\n            return; // Drop looped message\n        }\n        // Mark as seen\n        this.routingTable.markMessageSeen(hash);\n        // Step 3: Check TTL\n        if (message.header.ttl === 0) {\n            this.stats.messagesExpired++;\n            return; // Drop expired message\n        }\n        // Step 4: Check flood rate limit\n        if (!this.checkFloodRateLimit(fromPeerId)) {\n            return; // Drop if flooding too fast\n        }\n        // Step 5: Check if message is for us\n        if (this.isMessageForSelf(message)) {\n            this.stats.messagesForSelf++;\n            this.onMessageForSelfCallback?.(message);\n            // Don't forward messages addressed to us\n            return;\n        }\n        // Step 6: Decrement TTL for forwarding\n        const forwardMessage = {\n            header: {\n                ...message.header,\n                ttl: message.header.ttl - 1,\n            },\n            payload: message.payload,\n        };\n        // Step 7: Forward to all peers except sender (flood routing)\n        if (forwardMessage.header.ttl > 0) {\n            if (this.shouldForwardMessage(forwardMessage)) {\n                this.stats.messagesForwarded++;\n                this.onForwardMessageCallback?.(forwardMessage, fromPeerId);\n            }\n        }\n    }\n    /**\n     * Detect routing loops based on message path\n     */\n    detectLoop(messageHash, fromPeerId) {\n        if (!this.messageRoutes.has(messageHash)) {\n            this.messageRoutes.set(messageHash, []);\n        }\n        const path = this.messageRoutes.get(messageHash);\n        // Check if we've seen this peer in the path\n        if (path.includes(fromPeerId)) {\n            return true; // Loop detected\n        }\n        // Add to path\n        path.push(fromPeerId);\n        // Limit path tracking (cleanup old entries)\n        if (this.messageRoutes.size > 10000) {\n            const keys = Array.from(this.messageRoutes.keys());\n            for (let i = 0; i < 1000; i++) {\n                this.messageRoutes.delete(keys[i]);\n            }\n        }\n        return false;\n    }\n    /**\n     * Check flood rate limit for a peer\n     */\n    checkFloodRateLimit(peerId) {\n        const now = Date.now();\n        if (!this.peerFloodCounter.has(peerId)) {\n            this.peerFloodCounter.set(peerId, []);\n        }\n        const timestamps = this.peerFloodCounter.get(peerId);\n        // Remove timestamps older than 1 second\n        const recentTimestamps = timestamps.filter(t => now - t < 1000);\n        // Check rate limit\n        if (recentTimestamps.length >= this.config.floodRateLimit) {\n            return false; // Rate limit exceeded\n        }\n        // Add current timestamp\n        recentTimestamps.push(now);\n        this.peerFloodCounter.set(peerId, recentTimestamps);\n        return true;\n    }\n    /**\n     * Determine if message should be forwarded (selective flooding)\n     */\n    shouldForwardMessage(message) {\n        if (!this.config.selectiveFlooding) {\n            return true; // Forward all messages\n        }\n        // Always forward control messages\n        if (this.isControlMessage(message.header.type)) {\n            return true;\n        }\n        // For other messages, use selective criteria\n        // (Can be extended with topic-based filtering, etc.)\n        return true;\n    }\n    /**\n     * Check if message type is control\n     */\n    isControlMessage(type) {\n        return (type === MessageType.CONTROL_PING ||\n            type === MessageType.CONTROL_PONG ||\n            type === MessageType.CONTROL_ACK);\n    }\n    /**\n     * Check if message is addressed to this peer\n     */\n    isMessageForSelf(message) {\n        // For broadcast messages (PEER_DISCOVERY, etc.), everyone processes them\n        if (this.isBroadcastMessage(message.header.type)) {\n            return true;\n        }\n        // For directed messages, check if we're the recipient\n        // This would require destination field in payload (to be implemented)\n        return false;\n    }\n    /**\n     * Check if message type is broadcast\n     */\n    isBroadcastMessage(type) {\n        return (type === MessageType.PEER_DISCOVERY ||\n            type === MessageType.PEER_INTRODUCTION ||\n            type === MessageType.CONTROL_PING ||\n            type === MessageType.CONTROL_PONG);\n    }\n    /**\n     * Store message for offline peer (store-and-forward)\n     */\n    async storeMessage(message, destinationPeerId) {\n        const currentSize = await this.persistence.size();\n        if (currentSize >= this.config.maxStoredMessages) {\n            // Remove oldest message\n            // Note: This is less efficient with async persistence, might need optimization\n            const allMessages = await this.persistence.getAllMessages();\n            const oldest = Array.from(allMessages.entries())\n                .sort((a, b) => a[1].lastAttempt - b[1].lastAttempt)[0];\n            if (oldest) {\n                await this.persistence.removeMessage(oldest[0]);\n            }\n        }\n        const hash = messageHash(message);\n        await this.persistence.saveMessage(hash, {\n            message,\n            destinationPeerId,\n            attempts: 0,\n            lastAttempt: Date.now(),\n            expiresAt: Date.now() + this.config.storeTimeout,\n        });\n        this.stats.messagesStored++;\n    }\n    /**\n     * Retry forwarding stored messages\n     */\n    async retryStoredMessages() {\n        const now = Date.now();\n        const toDelete = [];\n        const allMessages = await this.persistence.getAllMessages();\n        for (const [hash, stored] of allMessages.entries()) {\n            // Check expiry\n            if (stored.expiresAt < now) {\n                toDelete.push(hash);\n                continue;\n            }\n            // Check if peer is now available\n            const peer = this.routingTable.getPeer(stored.destinationPeerId);\n            if (!peer) {\n                continue; // Peer still offline\n            }\n            // Check retry backoff\n            const timeSinceLastAttempt = now - stored.lastAttempt;\n            const backoffTime = this.config.retryBackoff * Math.pow(2, stored.attempts);\n            if (timeSinceLastAttempt < backoffTime) {\n                continue; // Not time to retry yet\n            }\n            // Attempt to forward\n            stored.attempts++;\n            stored.lastAttempt = now;\n            if (stored.attempts > this.config.maxRetries) {\n                toDelete.push(hash);\n                this.stats.relayFailures++;\n            }\n            else {\n                // Try forwarding again\n                this.onForwardMessageCallback?.(stored.message, '');\n                // Update stored state\n                await this.persistence.saveMessage(hash, stored);\n            }\n        }\n        // Clean up\n        for (const hash of toDelete) {\n            await this.persistence.removeMessage(hash);\n        }\n    }\n    /**\n     * Get stored messages statistics\n     */\n    async getStoredMessagesStats() {\n        const allMessages = await this.persistence.getAllMessages();\n        return {\n            total: allMessages.size,\n            byDestination: Array.from(allMessages.values())\n                .reduce((acc, msg) => {\n                acc[msg.destinationPeerId] = (acc[msg.destinationPeerId] || 0) + 1;\n                return acc;\n            }, {}),\n        };\n    }\n    /**\n     * Register callback for messages addressed to this peer\n     */\n    onMessageForSelf(callback) {\n        this.onMessageForSelfCallback = callback;\n    }\n    /**\n     * Register callback for forwarding messages\n     */\n    onForwardMessage(callback) {\n        this.onForwardMessageCallback = callback;\n    }\n    /**\n     * Get relay statistics\n     */\n    getStats() {\n        return { ...this.stats };\n    }\n    /**\n     * Reset statistics\n     */\n    resetStats() {\n        this.stats = {\n            messagesReceived: 0,\n            messagesForwarded: 0,\n            messagesDuplicate: 0,\n            messagesExpired: 0,\n            messagesForSelf: 0,\n            messagesStored: 0,\n            relayFailures: 0,\n            loopsDetected: 0,\n        };\n    }\n}\nexport const MAX_FRAGMENT_SIZE = 16384; // 16KB per fragment\nexport const MIN_FRAGMENT_SIZE = 512; // 512 bytes minimum\n/**\n * Calculate optimal fragment size based on MTU and network conditions\n */\nexport function calculateFragmentSize(mtu = 1500, overhead = 100) {\n    const optimalSize = mtu - overhead;\n    return Math.max(MIN_FRAGMENT_SIZE, Math.min(MAX_FRAGMENT_SIZE, optimalSize));\n}\n/**\n * Fragment a large message into smaller chunks\n */\nexport function fragmentMessage(message, messageId, fragmentSize = MAX_FRAGMENT_SIZE) {\n    const fragments = [];\n    const totalFragments = Math.ceil(message.length / fragmentSize);\n    for (let i = 0; i < totalFragments; i++) {\n        const start = i * fragmentSize;\n        const end = Math.min(start + fragmentSize, message.length);\n        const data = message.slice(start, end);\n        fragments.push({\n            messageId,\n            fragmentIndex: i,\n            totalFragments,\n            data,\n            timestamp: Date.now(),\n        });\n    }\n    return fragments;\n}\n/**\n * Calculate fragmentation overhead\n */\nexport function calculateFragmentationOverhead(messageSize, fragmentSize = MAX_FRAGMENT_SIZE) {\n    const totalFragments = Math.ceil(messageSize / fragmentSize);\n    const headerOverhead = 50; // Approximate header size per fragment\n    return totalFragments * headerOverhead;\n}\n/**\n * Message Reassembly Engine with timeout and memory limits\n */\nexport class MessageReassembler {\n    constructor() {\n        this.fragments = new Map();\n        this.totalFragments = new Map();\n        this.fragmentTimestamps = new Map();\n        this.REASSEMBLY_TIMEOUT = 60000; // 60 seconds\n        this.MAX_REASSEMBLY_BUFFER = 100 * 1024 * 1024; // 100 MB\n        this.currentBufferSize = 0;\n    }\n    /**\n     * Add a fragment to the reassembly buffer\n     */\n    addFragment(fragment) {\n        const { messageId, fragmentIndex, totalFragments, data } = fragment;\n        // Check for duplicate fragments\n        if (this.fragments.has(messageId)) {\n            const messageFragments = this.fragments.get(messageId);\n            if (messageFragments.has(fragmentIndex)) {\n                return false; // Duplicate fragment\n            }\n        }\n        // Initialize fragment map for this message if needed\n        if (!this.fragments.has(messageId)) {\n            this.fragments.set(messageId, new Map());\n            this.totalFragments.set(messageId, totalFragments);\n            this.fragmentTimestamps.set(messageId, Date.now());\n        }\n        // Check memory limits\n        if (this.currentBufferSize + data.length > this.MAX_REASSEMBLY_BUFFER) {\n            this.cleanupOldest();\n        }\n        // Add fragment\n        const messageFragments = this.fragments.get(messageId);\n        messageFragments.set(fragmentIndex, data);\n        this.currentBufferSize += data.length;\n        // Check if we have all fragments\n        if (messageFragments.size === totalFragments) {\n            this.reassembleMessage(messageId);\n            return true; // Message complete\n        }\n        return false; // Still waiting for more fragments\n    }\n    /**\n     * Reassemble complete message from fragments (handles out-of-order)\n     */\n    reassembleMessage(messageId) {\n        const messageFragments = this.fragments.get(messageId);\n        const totalFragments = this.totalFragments.get(messageId);\n        if (!messageFragments || !totalFragments) {\n            return;\n        }\n        // Calculate total size\n        let totalSize = 0;\n        for (let i = 0; i < totalFragments; i++) {\n            const fragment = messageFragments.get(i);\n            if (!fragment) {\n                console.error(`Missing fragment ${i} for message ${messageId}`);\n                return;\n            }\n            totalSize += fragment.length;\n        }\n        // Reassemble in correct order\n        const completeMessage = new Uint8Array(totalSize);\n        let offset = 0;\n        for (let i = 0; i < totalFragments; i++) {\n            const fragment = messageFragments.get(i);\n            completeMessage.set(fragment, offset);\n            offset += fragment.length;\n        }\n        // Update buffer size\n        this.currentBufferSize -= totalSize;\n        // Clean up\n        this.fragments.delete(messageId);\n        this.totalFragments.delete(messageId);\n        this.fragmentTimestamps.delete(messageId);\n        // Notify completion\n        this.onCompleteCallback?.(messageId, completeMessage);\n    }\n    /**\n     * Register callback for completed messages\n     */\n    onComplete(callback) {\n        this.onCompleteCallback = callback;\n    }\n    /**\n     * Clean up expired incomplete messages\n     */\n    cleanup(maxAgeMs = this.REASSEMBLY_TIMEOUT) {\n        const now = Date.now();\n        const toDelete = [];\n        for (const [messageId, timestamp] of this.fragmentTimestamps.entries()) {\n            if (now - timestamp > maxAgeMs) {\n                toDelete.push(messageId);\n            }\n        }\n        let freedBytes = 0;\n        for (const messageId of toDelete) {\n            const messageFragments = this.fragments.get(messageId);\n            if (messageFragments) {\n                for (const fragment of messageFragments.values()) {\n                    freedBytes += fragment.length;\n                }\n            }\n            this.fragments.delete(messageId);\n            this.totalFragments.delete(messageId);\n            this.fragmentTimestamps.delete(messageId);\n        }\n        this.currentBufferSize -= freedBytes;\n        return toDelete.length;\n    }\n    /**\n     * Clean up oldest incomplete message to free memory\n     */\n    cleanupOldest() {\n        if (this.fragmentTimestamps.size === 0)\n            return;\n        const oldest = Array.from(this.fragmentTimestamps.entries())\n            .sort((a, b) => a[1] - b[1])[0];\n        if (oldest) {\n            const [messageId] = oldest;\n            const messageFragments = this.fragments.get(messageId);\n            if (messageFragments) {\n                for (const fragment of messageFragments.values()) {\n                    this.currentBufferSize -= fragment.length;\n                }\n            }\n            this.fragments.delete(messageId);\n            this.totalFragments.delete(messageId);\n            this.fragmentTimestamps.delete(messageId);\n        }\n    }\n    /**\n     * Get reassembly statistics\n     */\n    getStats() {\n        return {\n            incompleteMessages: this.fragments.size,\n            fragmentsWaiting: Array.from(this.fragments.values())\n                .reduce((sum, map) => sum + map.size, 0),\n            bufferUsage: this.currentBufferSize,\n            bufferLimit: this.MAX_REASSEMBLY_BUFFER,\n        };\n    }\n}\n"],
  "mappings": "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",
  "names": ["mobile_exports", "__export", "DefaultTransportRegistry", "MOBILE_BUNDLE", "MessageQueue", "MessageRelay", "MessageType", "PeerState", "RoutingTable", "VERSION", "base64ToPublicKey", "compareFingerprints", "createPeer", "decodeMessage", "decryptEnvelope", "decryptMessage", "deriveSharedSecret", "deserializeEncryptedEnvelope", "deserializeSignedEnvelope", "encodeMessage", "encryptEnvelope", "encryptMessage", "formatFingerprint", "generateFingerprint", "generateFullFingerprint", "generateIdentity", "generateNonce", "generateSessionKey", "isValidPublicKey", "publicKeyToBase64", "serializeEncryptedEnvelope", "serializeSignedEnvelope", "signEnvelope", "signMessage", "verifyEnvelope", "verifySignature", "isBytes", "a", "anumber", "n", "title", "prefix", "abytes", "value", "length", "bytes", "len", "needsLen", "ofLen", "got", "ahash", "h", "aexists", "instance", "checkFinished", "aoutput", "out", "min", "clean", "arrays", "i", "createView", "arr", "rotr", "word", "shift", "hasHexBuiltin", "hexes", "_", "i", "bytesToHex", "bytes", "abytes", "hex", "asciis", "asciiToBase16", "ch", "hexToBytes", "hl", "al", "array", "ai", "hi", "n1", "n2", "char", "concatBytes", "arrays", "sum", "i", "a", "abytes", "res", "pad", "createHasher", "hashCons", "info", "hashC", "msg", "opts", "tmp", "randomBytes", "bytesLength", "cr", "oidNist", "suffix", "Chi", "a", "b", "c", "Maj", "HashMD", "blockLen", "outputLen", "padOffset", "isLE", "__publicField", "createView", "data", "aexists", "abytes", "view", "buffer", "len", "pos", "take", "dataView", "out", "aoutput", "clean", "i", "oview", "outLen", "state", "res", "to", "length", "finished", "destroyed", "SHA256_IV", "SHA512_IV", "U32_MASK64", "_32n", "fromBig", "n", "le", "split", "lst", "len", "Ah", "Al", "i", "h", "l", "shrSH", "h", "_l", "s", "shrSL", "l", "rotrSH", "rotrSL", "rotrBH", "rotrBL", "add", "Ah", "Al", "Bh", "Bl", "l", "add3L", "Cl", "add3H", "low", "Ch", "add4L", "Dl", "add4H", "Dh", "add5L", "El", "add5H", "Eh", "SHA256_K", "SHA256_W", "SHA2_32B", "HashMD", "outputLen", "A", "B", "C", "D", "E", "F", "G", "H", "view", "offset", "i", "W15", "W2", "s0", "rotr", "s1", "sigma1", "T1", "Chi", "T2", "Maj", "clean", "_SHA256", "__publicField", "SHA256_IV", "K512", "split", "n", "SHA512_Kh", "SHA512_Kl", "SHA512_W_H", "SHA512_W_L", "SHA2_64B", "HashMD", "outputLen", "Ah", "Al", "Bh", "Bl", "Ch", "Cl", "Dh", "Dl", "Eh", "El", "Fh", "Fl", "Gh", "Gl", "Hh", "Hl", "view", "offset", "i", "W15h", "W15l", "s0h", "rotrSH", "shrSH", "s0l", "rotrSL", "shrSL", "W2h", "W2l", "s1h", "rotrBH", "s1l", "rotrBL", "SUMl", "add4L", "SUMh", "add4H", "sigma1h", "sigma1l", "CHIh", "CHIl", "T1ll", "add5L", "T1h", "add5H", "T1l", "sigma0h", "sigma0l", "MAJh", "MAJl", "add", "All", "add3L", "add3H", "clean", "_SHA512", "__publicField", "SHA512_IV", "sha256", "createHasher", "_SHA256", "oidNist", "sha512", "createHasher", "_SHA512", "oidNist", "_0n", "_1n", "abool", "value", "title", "prefix", "abignumber", "n", "isPosBig", "anumber", "hexToNumber", "hex", "_0n", "bytesToNumberBE", "bytes", "bytesToHex", "bytesToNumberLE", "copyBytes", "abytes", "numberToBytesBE", "n", "len", "anumber", "abignumber", "res", "hexToBytes", "numberToBytesLE", "copyBytes", "bytes", "isPosBig", "n", "_0n", "inRange", "min", "max", "aInRange", "title", "bitMask", "n", "_1n", "validateObject", "object", "fields", "optFields", "checkField", "fieldName", "expectedType", "isOpt", "val", "current", "iter", "f", "k", "v", "memoized", "fn", "map", "arg", "args", "val", "computed", "_0n", "_1n", "_2n", "_3n", "_4n", "_5n", "_7n", "_8n", "_9n", "_16n", "mod", "a", "b", "result", "pow2", "x", "power", "modulo", "res", "_0n", "invert", "number", "a", "mod", "b", "y", "_1n", "u", "v", "q", "r", "m", "n", "assertIsSquare", "Fp", "root", "sqrt3mod4", "p1div4", "_4n", "sqrt5mod8", "p5div8", "_5n", "_8n", "n2", "_2n", "nv", "i", "sqrt9mod16", "P", "Fp_", "Field", "tn", "tonelliShanks", "c1", "c2", "c3", "c4", "_7n", "_16n", "tv1", "tv2", "tv3", "tv4", "e1", "e2", "e3", "_3n", "Q", "S", "Z", "_Fp", "FpLegendre", "cc", "Q1div2", "M", "c", "t", "R", "t_tmp", "exponent", "FpSqrt", "_9n", "isNegativeLE", "num", "FIELD_FIELDS", "validateField", "field", "initial", "opts", "map", "val", "validateObject", "FpPow", "p", "d", "FpInvertBatch", "nums", "passZero", "inverted", "multipliedAcc", "acc", "invertedAcc", "FpLegendre", "Fp", "n", "p1mod2", "_1n", "_2n", "powered", "yes", "zero", "no", "nLength", "n", "nBitLength", "anumber", "_nBitLength", "nByteLength", "_Field", "ORDER", "opts", "__publicField", "_0n", "_1n", "_nbitLength", "num", "mod", "lhs", "rhs", "power", "FpPow", "invert", "FpSqrt", "numberToBytesLE", "numberToBytesBE", "bytes", "skipValidation", "abytes", "allowedLengths", "BYTES", "isLE", "modFromBytes", "padded", "scalar", "bytesToNumberLE", "bytesToNumberBE", "lst", "FpInvertBatch", "a", "b", "condition", "Field", "_0n", "_1n", "negateCt", "condition", "item", "neg", "normalizeZ", "c", "points", "invertedZs", "FpInvertBatch", "p", "i", "validateW", "W", "bits", "calcWOpts", "scalarBits", "windows", "windowSize", "maxNumber", "mask", "bitMask", "shiftBy", "calcOffsets", "n", "window", "wOpts", "wbits", "nextN", "offsetStart", "offset", "isZero", "isNeg", "isNegF", "pointPrecomputes", "pointWindowSizes", "getW", "P", "assert0", "n", "_0n", "wNAF", "Point", "bits", "__publicField", "elm", "p", "d", "_1n", "point", "W", "windows", "windowSize", "calcWOpts", "points", "base", "window", "i", "precomputes", "f", "wo", "nextN", "offset", "isZero", "isNeg", "isNegF", "offsetF", "calcOffsets", "negateCt", "acc", "item", "transform", "comp", "scalar", "prev", "validateW", "createField", "order", "field", "isLE", "validateField", "Field", "createCurveFields", "type", "CURVE", "curveOpts", "FpFnLE", "p", "val", "_0n", "Fp", "Fn", "params", "createKeygen", "randomSecretKey", "getPublicKey", "seed", "secretKey", "_0n", "_1n", "_2n", "_8n", "isEdValidXY", "Fp", "CURVE", "x", "y", "x2", "y2", "left", "right", "edwards", "params", "extraOpts", "validated", "createCurveFields", "Fn", "cofactor", "validateObject", "MASK", "modP", "n", "uvRatio", "u", "v", "acoord", "title", "banZero", "min", "aInRange", "aedpoint", "other", "Point", "toAffineMemo", "memoized", "p", "iz", "X", "Y", "Z", "is0", "zz", "assertValidMemo", "a", "T", "X2", "Y2", "Z2", "Z4", "aX2", "XY", "ZT", "_Point", "__publicField", "bytes", "zip215", "len", "d", "copyBytes", "abytes", "abool", "normed", "lastByte", "bytesToNumberLE", "max", "isValid", "isXOdd", "isLastByteOdd", "hex", "hexToBytes", "windowSize", "isLazy", "wnaf", "X1", "Y1", "Z1", "X1Z2", "X2Z1", "Y1Z2", "Y2Z1", "A", "B", "C", "D", "x1y1", "E", "G", "F", "H", "X3", "Y3", "T3", "Z3", "T1", "T2", "scalar", "f", "normalizeZ", "acc", "invertedZ", "bytesToHex", "wNAF", "eddsa", "Point", "cHash", "eddsaOpts", "validateObject", "prehash", "BASE", "Fp", "Fn", "randomBytes", "adjustScalarBytes", "bytes", "domain", "data", "ctx", "phflag", "abool", "modN_LE", "hash", "bytesToNumberLE", "getPrivateScalar", "key", "len", "lengths", "abytes", "hashed", "head", "prefix", "scalar", "getExtendedPublicKey", "secretKey", "point", "pointBytes", "getPublicKey", "hashDomainToScalar", "context", "msgs", "msg", "concatBytes", "sign", "options", "r", "R", "k", "s", "rs", "verifyOpts", "verify", "sig", "publicKey", "zip215", "mid", "A", "SB", "_size", "randomSecretKey", "seed", "isValidSecretKey", "isBytes", "isValidPublicKey", "utils", "y", "size", "is25519", "u", "_1n", "createKeygen", "_0n", "_1n", "_2n", "validateOpts", "curve", "validateObject", "montgomery", "curveDef", "CURVE", "P", "type", "adjustScalarBytes", "powPminus2", "rand", "is25519", "randomBytes_", "randomBytes", "montgomeryBits", "fieldLen", "Gu", "a24", "minScalar", "maxAdded", "maxScalar", "modP", "n", "mod", "GuBytes", "encodeU", "u", "numberToBytesLE", "decodeU", "_u", "copyBytes", "abytes", "bytesToNumberLE", "decodeScalar", "scalar", "scalarMult", "pu", "montgomeryLadder", "scalarMultBase", "getPublicKey", "getSharedSecret", "cswap", "swap", "x_2", "x_3", "dummy", "aInRange", "k", "x_1", "z_2", "z_3", "t", "k_t", "A", "AA", "B", "BB", "E", "C", "D", "DA", "CB", "dacb", "da_cb", "z2", "lengths", "randomSecretKey", "seed", "utils", "createKeygen", "_1n", "_2n", "_3n", "_5n", "_8n", "ed25519_CURVE_p", "ed25519_CURVE", "ed25519_pow_2_252_3", "x", "_10n", "_20n", "_40n", "_80n", "P", "b2", "b4", "pow2", "b5", "b10", "b20", "b40", "b80", "b160", "b240", "b250", "adjustScalarBytes", "bytes", "ED25519_SQRT_M1", "uvRatio", "u", "v", "v3", "mod", "v7", "pow", "vx2", "root1", "root2", "useRoot1", "useRoot2", "noRoot", "isNegativeLE", "ed25519_Point", "edwards", "ed", "opts", "eddsa", "ed25519_Point", "sha512", "adjustScalarBytes", "ed25519", "x25519", "P", "ed25519_CURVE_p", "montgomery", "x", "pow_p_5_8", "b2", "ed25519_pow_2_252_3", "mod", "pow2", "_3n", "adjustScalarBytes", "isBytes", "a", "abool", "b", "anumber", "n", "abytes", "value", "length", "title", "bytes", "len", "needsLen", "prefix", "ofLen", "got", "aexists", "instance", "checkFinished", "aoutput", "out", "min", "u32", "arr", "clean", "arrays", "i", "createView", "isLE", "checkOpts", "defaults", "opts", "equalBytes", "a", "b", "diff", "i", "wrapCipher", "params", "constructor", "wrappedCipher", "key", "args", "abytes", "isLE", "nonce", "tagl", "cipher", "checkOutput", "fnLength", "output", "called", "data", "getOutput", "expectedLength", "out", "onlyAligned", "isAligned32", "u64Lengths", "dataLength", "aadLength", "abool", "num", "view", "createView", "bytes", "copyBytes", "encodeStr", "str", "c", "sigma16", "sigma32", "sigma16_32", "u32", "sigma32_32", "rotl", "a", "b", "isAligned32", "BLOCK_LEN", "BLOCK_LEN32", "MAX_COUNTER", "U32_EMPTY", "runCipher", "core", "sigma", "key", "nonce", "data", "output", "counter", "rounds", "len", "block", "b32", "isAligned", "d32", "o32", "pos", "take", "pos32", "j", "posj", "createCipher", "opts", "allowShortKeys", "extendNonceFn", "counterLength", "counterRight", "checkOpts", "anumber", "abool", "abytes", "toClean", "l", "k", "copyBytes", "k32", "nonceNcLen", "nc", "n32", "clean", "u8to16", "a", "i", "Poly1305", "key", "__publicField", "copyBytes", "abytes", "t0", "u8to16", "t1", "t2", "t3", "t4", "t5", "t6", "t7", "i", "data", "offset", "isLast", "hibit", "h", "r", "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7", "r8", "r9", "h0", "h1", "h2", "h3", "h4", "h5", "h6", "h7", "h8", "h9", "c", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "pad", "g", "mask", "f", "clean", "aexists", "buffer", "blockLen", "len", "pos", "take", "out", "aoutput", "opos", "outputLen", "res", "wrapConstructorWithKey", "hashCons", "hashC", "msg", "tmp", "poly1305", "chachaCore", "s", "k", "out", "cnt", "rounds", "y00", "y01", "y02", "y03", "y04", "y05", "y06", "y07", "y08", "y09", "y10", "y11", "y12", "y13", "y14", "y15", "x00", "x01", "x02", "x03", "x04", "x05", "x06", "x07", "x08", "x09", "x10", "x11", "x12", "x13", "x14", "x15", "r", "rotl", "oi", "hchacha", "i", "chacha20", "createCipher", "chachaCore", "xchacha20", "hchacha", "ZEROS16", "updatePadded", "h", "msg", "leftover", "ZEROS32", "computeTag", "fn", "key", "nonce", "ciphertext", "AAD", "abytes", "authKey", "lengths", "u64Lengths", "poly1305", "res", "clean", "_poly1305_aead", "xorStream", "plaintext", "output", "plength", "getOutput", "oPlain", "tag", "data", "passedTag", "equalBytes", "chacha20poly1305", "wrapCipher", "chacha20", "xchacha20poly1305", "xchacha20", "_HMAC", "hash", "key", "__publicField", "ahash", "abytes", "blockLen", "pad", "i", "clean", "buf", "aexists", "out", "to", "oHash", "iHash", "finished", "destroyed", "outputLen", "hmac", "message", "extract", "hash", "ikm", "salt", "ahash", "hmac", "HKDF_COUNTER", "EMPTY_BUFFER", "expand", "prk", "info", "length", "anumber", "olen", "blocks", "abytes", "okm", "HMAC", "HMACTmp", "T", "counter", "clean", "hkdf", "randomBytes", "secureWipe", "data", "validateEntropy", "b", "first", "patternCount", "i", "generateIdentity", "privateKey", "ed25519", "signMessage", "message", "verifySignature", "signature", "publicKey", "performKeyExchange", "privateKey", "peerPublicKey", "salt", "info", "sharedSecret", "x25519", "derivedKey", "hkdf", "sha256", "secureWipe", "generateSessionKey", "counter", "key", "randomBytes", "validateEntropy", "encryptMessage", "plaintext", "key", "nonce", "associatedData", "xchacha20poly1305", "decryptMessage", "ciphertext", "generateFingerprint", "publicKey", "hash", "sha256", "hex", "b", "generateNonce", "randomBytes", "deriveSharedSecret", "privateKey", "peerPublicKey", "salt", "info", "performKeyExchange", "MessageType", "MIN_SUPPORTED_VERSION", "MAX_SUPPORTED_VERSION", "HEADER_SIZE", "MAX_PAYLOAD_SIZE", "MAX_TTL", "MessageValidationError", "message", "field", "value", "validateHeader", "header", "MessageType", "v", "validateMessage", "encodeHeader", "buffer", "offset", "timestamp", "i", "decodeHeader", "version", "type", "ttl", "senderId", "signature", "encodeMessage", "headerBytes", "result", "decodeMessage", "payload", "messageHash", "messageBytes", "hash", "sha256", "b", "PeerState", "createPeer", "id", "publicKey", "transportType", "RoutingTable", "config", "peer", "peerId", "dest", "route", "existing", "newRoute", "newBw", "existingBw", "now", "toDelete", "routes", "a", "b", "removeCount", "i", "destination", "latency", "success", "bandwidth", "alpha", "messageHash", "hash", "timestamp", "entries", "durationMs", "timeoutMs", "stale", "breakdown", "sum", "val", "MessageQueue", "MessageType", "messageType", "message", "priority", "queue", "currentPriority", "itemsToEscalate", "remainingItems", "item", "higherPriority", "total", "sizes", "oldest", "age", "CURRENT_VERSION", "HKDF_INFO", "encryptEnvelope", "data", "senderPrivateKey", "recipientPublicKey", "ephemeralPrivateKey", "randomBytes", "ephemeralPublicKey", "x25519", "sharedSecret", "encryptionKey", "hkdf", "sha256", "nonce", "ciphertext", "xchacha20poly1305", "timestamp", "envelopeData", "numberToBytes", "signature", "ed25519", "decryptEnvelope", "envelope", "recipientPrivateKey", "senderPublicKey", "decryptionKey", "plaintext", "signEnvelope", "privateKey", "publicKey", "signedData", "verifyEnvelope", "expectedPublicKey", "i", "serializeEncryptedEnvelope", "timestampBytes", "ciphertextLength", "deserializeEncryptedEnvelope", "bytes", "offset", "version", "bytesToNumber", "serializeSignedEnvelope", "dataLength", "deserializeSignedEnvelope", "num", "DefaultTransportRegistry", "type", "factory", "transportRegistry", "generateFullFingerprint", "publicKey", "keyBytes", "hexToBytes", "base64ToBytes", "hashBuffer", "b", "formatFingerprint", "fingerprint", "isValidPublicKey", "publicKeyToBase64", "base64ToPublicKey", "base64", "binary", "bytes", "i", "hex", "compareFingerprints", "fp1", "fp2", "MemoryPersistenceAdapter", "id", "message", "now", "msg", "MessageRelay", "localPeerId", "routingTable", "config", "persistence", "messageData", "fromPeerId", "decodeMessage", "error", "hash", "messageHash", "forwardMessage", "path", "keys", "i", "peerId", "recentTimestamps", "t", "type", "MessageType", "destinationPeerId", "allMessages", "oldest", "a", "b", "toDelete", "stored", "timeSinceLastAttempt", "backoffTime", "acc", "callback", "VERSION", "MOBILE_BUNDLE"]
}
