// Real imports from @sc/core
import {
  signMessage,
  verifySignature,
  generateIdentity,
} from "../../core/src/crypto/primitives";
import { sanitizeHTML } from "../../core/src/validation";

describe("Vulnerability Scanning Security Test", () => {
  describe("XSS Prevention", () => {
    it("should prevent XSS in message content rendering", () => {
      const maliciousContent =
        '<script>alert("xss")</script><img src=x onerror=alert(1)>';

      const sanitized = sanitizeHTML(maliciousContent);

      // Use real sanitizer from core
      expect(sanitized).not.toContain("<script>");
      expect(sanitized).not.toContain("onerror");
      expect(sanitized).not.toContain("<img>");
      // The fallback sanitizer (regex) leaves the text content, which is safe to render as text
      // but strips the tags that would execute it.
    });

    it("should escape HTML entities in message display", () => {
      // sanitizeHTML removes tags. For entity escaping, we expect the output to be safe.
      const htmlContent = '<b>Bold</b> & "quotes"';
      const result = sanitizeHTML(htmlContent);
      expect(result).toBe('Bold & "quotes"');
    });
  });

  describe("Prototype Pollution Prevention", () => {
    it("should prevent prototype pollution in JSON parsing", () => {
      const maliciousJson = '{"__proto__": {"isAdmin": true}}';
      const parsed = JSON.parse(maliciousJson);

      // Ensure prototype is not polluted
      expect((parsed as any).isAdmin).toBeUndefined();
      expect(({} as any).isAdmin).toBeUndefined();
      expect((Object.prototype as any).isAdmin).toBeUndefined();
    });
  });

  describe("Cryptographic Security", () => {
    it("should use constant-time comparison for signatures", async () => {
      const message = new Uint8Array([1, 2, 3, 4, 5]);
      const keyPair = generateIdentity();
      const signature = signMessage(message, keyPair.privateKey);

      const startTime = process.hrtime.bigint();
      // Use real verification which uses timingSafeEqual internally
      const isValid = verifySignature(message, signature, keyPair.publicKey);
      const endTime = process.hrtime.bigint();

      expect(isValid).toBe(true);
      expect(endTime - startTime).toBeGreaterThan(0n);
    });

    it("should handle edge cases in crypto operations", async () => {
      // Test empty message
      const keyPair = generateIdentity();

      // signMessage likely allows empty messages
      expect(() => {
        signMessage(new Uint8Array(0), keyPair.privateKey);
      }).not.toThrow();

      // Test invalid key sizes
      expect(() => {
        signMessage(new Uint8Array([1, 2, 3]), new Uint8Array(16));
      }).toThrow();
    });
  });
});
