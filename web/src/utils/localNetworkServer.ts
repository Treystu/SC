/**
 * Local Network Server for sharing SC app on the local network
 * Uses WebRTC to discover local IPs and service worker for serving content
 */

import type { PendingInvite } from '@sc/core';

export interface LocalShareInfo {
  urls: string[];
  qrCodes: string[];
}

export class LocalNetworkServer {
  /**
   * Start sharing the app on the local network
   */
  async startSharing(invite: PendingInvite): Promise<LocalShareInfo> {
    const ips = await this.getLocalIPs();
    const port = window.location.port || '80';
    
    // Register service worker route for sharing
    await this.registerShareRoute(invite);
    
    // Build URLs for each local IP
    const urls = ips.map(ip => {
      const protocol = window.location.protocol;
      const portStr = port !== '80' && port !== '443' ? `:${port}` : '';
      return `${protocol}//${ip}${portStr}/join#${invite.code}`;
    });

    return {
      urls,
      qrCodes: [], // QR codes will be generated by the QRCodeShare component
    };
  }

  /**
   * Get local network IP addresses using WebRTC
   */
  private async getLocalIPs(): Promise<string[]> {
    return new Promise((resolve) => {
      const ips = new Set<string>();
      
      // Create RTCPeerConnection with no STUN/TURN servers
      const pc = new RTCPeerConnection({ iceServers: [] });
      
      // Create a dummy data channel
      pc.createDataChannel('');
      
      // Create offer to trigger ICE candidate gathering
      pc.createOffer()
        .then(offer => pc.setLocalDescription(offer))
        .catch(err => {
          console.error('Failed to create offer:', err);
          resolve([window.location.hostname]);
        });
      
      // Set timeout to resolve after ICE gathering
      const timeout = setTimeout(() => {
        pc.close();
        if (ips.size === 0) {
          // Fallback to current hostname
          resolve([window.location.hostname]);
        } else {
          resolve(Array.from(ips));
        }
      }, 2000);
      
      // Listen for ICE candidates
      pc.onicecandidate = (event) => {
        if (!event.candidate) {
          // ICE gathering complete
          clearTimeout(timeout);
          pc.close();
          
          if (ips.size === 0) {
            resolve([window.location.hostname]);
          } else {
            resolve(Array.from(ips));
          }
          return;
        }
        
        // Parse ICE candidate to extract IP
        const candidate = event.candidate.candidate;
        const parts = candidate.split(' ');
        
        // Look for host candidates (local IPs)
        if (parts.length > 7 && parts[7] === 'host') {
          const ip = parts[4];
          
          // Filter out IPv6 and invalid IPs
          if (ip && !ip.includes(':') && ip !== '0.0.0.0') {
            ips.add(ip);
          }
        }
      };
    });
  }

  /**
   * Register a service worker route for sharing
   * This allows the service worker to serve the join page with the invite embedded
   */
  private async registerShareRoute(invite: PendingInvite): Promise<void> {
    if (!('serviceWorker' in navigator)) {
      console.warn('Service Worker not supported');
      return;
    }

    try {
      const registration = await navigator.serviceWorker.ready;
      
      // Post message to service worker to register the invite
      if (registration.active) {
        registration.active.postMessage({
          type: 'REGISTER_INVITE',
          invite: {
            code: invite.code,
            inviterName: invite.inviterName,
          },
        });
      }
    } catch (error) {
      console.error('Failed to register share route:', error);
    }
  }

  /**
   * Stop sharing and clean up
   */
  async stopSharing(): Promise<void> {
      if (!('serviceWorker' in navigator) || !navigator.serviceWorker) {
        return;
      }
  
      try {
        const registration = await navigator.serviceWorker.ready;
        
        if (registration && registration.active) {
          registration.active.postMessage({
            type: 'UNREGISTER_INVITE',
          });
        }
      } catch (error) {
        console.error('Failed to unregister share route:', error);
      }
    }
}
